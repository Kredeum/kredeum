{
  "language": "Solidity",
  "sources": {
    "contracts/next/OpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//  OpenERC165 (supports)\n//      |\n//      ———————————————————————————————————————————————\n//      |                 |             |             |\n//  OpenERC721 (NFT)  OpenERC173  OpenChecker  OpenCloneable\n//      |             (ownable)         |             |\n//      |                 |             |             |\n//      |                 |             |             |\n//      |            OpenPauseable      |             |\n//      |                 |             |             |\n//      ———————————————————————————————————————————————\n//      |\n//  OpenBound --- IOpenBound --- IERC721Enumerable --- IERC721Metadata\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\n\nimport \"../interfaces/IOpenBound.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenBound smartcontract\n/// limited to one nft per address\ncontract OpenBound is\n    IOpenBound,\n    IERC721Enumerable,\n    IERC721Metadata,\n    OpenCloneable,\n    OpenChecker,\n    OpenPauseable,\n    OpenERC721\n{\n    uint256 public maxSupply;\n\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) internal _tokenOfOwner;\n    mapping(address => uint256) internal _tokenIndexOfOwner;\n    mapping(uint256 => uint256) internal _cidOfToken;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    function mint(uint256 cid) external override(IOpenBound) onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, cid);\n    }\n\n    function claim(uint256 tokenID, uint256 cid) external override(IOpenBound) onlyWhenNotPaused {\n        require(tokenID == _tokenID(msg.sender, cid), \"Not owner\");\n        _mint(msg.sender, cid);\n    }\n\n    function burn(uint256 tokenID) external override(IOpenBound) {\n        address from = ownerOf(tokenID);\n        require(from == msg.sender, \"Not owner\");\n\n        _burn(tokenID);\n    }\n\n    function getMyTokenID(uint256 cid) external view override(IOpenBound) returns (uint256 myTokenID) {\n        myTokenID = _tokenID(msg.sender, cid);\n    }\n\n    function getCID(uint256 tokenID) external view override(IOpenBound) returns (uint256 cid) {\n        cid = _cidOfToken[tokenID];\n    }\n\n    /// IERC721Enumerable\n    function totalSupply() external view override(IERC721Enumerable) returns (uint256 tokensLength) {\n        tokensLength = _tokens.length;\n    }\n\n    function tokenOfOwnerByIndex(address tokenOwner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256 tokenID)\n    {\n        require(index == 0 && balanceOf(tokenOwner) == 1, \"Invalid index\");\n\n        tokenID = _tokenOfOwner[tokenOwner];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256 tokenID) {\n        require(index < _tokens.length, \"Invalid index\");\n\n        tokenID = _tokens[index];\n    }\n\n    /// IERC721Metadata\n    function tokenURI(uint256 tokenID)\n        external\n        view\n        override(IERC721Metadata)\n        existsToken(tokenID)\n        returns (string memory)\n    {\n        return _tokenURI(_cidOfToken[tokenID]);\n    }\n\n    function getTokenID(address addr, uint256 cid) external pure override(IOpenBound) returns (uint256 tokenID) {\n        tokenID = _tokenID(addr, cid);\n    }\n\n    /// IOpenBound\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        uint256 maxSupply_\n    ) public override(IOpenBound) {\n        OpenCloneable._initialize(\"OpenBound\", 1);\n        OpenERC173._initialize(owner_);\n\n        name = name_;\n        symbol = symbol_;\n        maxSupply = maxSupply_;\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public override(OpenCloneable) {\n        initialize(name_, symbol_, owner_, abi.decode(params_, (uint256)));\n    }\n\n    /// IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(OpenPauseable, OpenCloneable, OpenERC721, OpenChecker)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenBound).interfaceId ||\n            interfaceId == type(IOpenNFTsOld).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, uint256 cid) internal returns (uint256 tokenID) {\n        require((maxSupply == 0) || _tokens.length < maxSupply, \"Max supply reached\");\n        require(balanceOf(to) == 0, \"Already minted or claimed\");\n\n        tokenID = _tokenID(to, cid);\n\n        _tokens.push(tokenID);\n        _tokenOfOwner[to] = tokenID;\n        _tokenIndexOfOwner[to] = _tokens.length - 1;\n        _cidOfToken[tokenID] = cid;\n\n        _mint(to, _tokenURI(cid), tokenID);\n    }\n\n    function _mint(\n        address to,\n        string memory newTokenURI,\n        uint256 tokenID\n    ) internal override(OpenERC721) {\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721) {\n        address from = ownerOf(tokenID);\n        uint256 index = _tokenIndexOfOwner[from];\n        uint256 lastIndex = _tokens.length - 1;\n\n        if (index != lastIndex) {\n            _tokens[index] = _tokens[lastIndex];\n            _tokenIndexOfOwner[ownerOf(_tokens[lastIndex])] = index;\n        }\n        _tokens.pop();\n\n        delete _cidOfToken[tokenID];\n        delete _tokenIndexOfOwner[from];\n        delete _tokenOfOwner[from];\n\n        super._burn(tokenID);\n    }\n\n    function _tokenID(address addr, uint256 cid) internal pure returns (uint256 tokenID) {\n        tokenID = uint256(keccak256(abi.encodePacked(cid, addr)));\n    }\n\n    function _tokenURI(uint256 cid) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(cid)));\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 // tokenId\n    ) internal pure override {\n        require(from == address(0) || to == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "contracts/interfaces/IOpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenBound {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        uint256 maxSupply\n    ) external;\n\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getTokenID(address addr, uint256 cid) external view returns (uint256 tokenID);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOpenNFTs.old.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTs {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenPauseable –– IOpenPauseable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseable is IOpenPauseable, OpenERC173 {\n    bool private _paused;\n\n    modifier onlyWhenNotPaused() {\n        require(!_paused, \"Paused!\");\n        _;\n    }\n\n    function togglePause() external override (IOpenPauseable) onlyOwner {\n        _setPaused(!_paused);\n    }\n\n    function paused() external view override (IOpenPauseable) returns (bool) {\n        return _paused;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC173)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenPauseable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _setPaused(bool paused_) private {\n        _paused = paused_;\n        emit SetPaused(_paused, msg.sender);\n    }\n}\n"
    },
    "OpenNFTs/contracts/libraries/Bafkrey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nlibrary Bafkrey {\n    bytes32 private constant _BASE32_SYMBOLS = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    /// Transfom uint256 to IPFS CID V1 base32 raw (starting with \"bafkrei\")\n    function uint256ToCid(uint256 id) internal pure returns (string memory) {\n        // IPFS CID V1 base32 raw \"bafrei...\" => 5 bits => uint32\n        // uint256 id  = 256 bits = 1 bit + 51 uint32 = 1 + 51 * 5 = 256\n        // 00 added right =>\n        // uint8 + uint256 + 00 = 258 bits = uint8 + 50 uint32 + (3 bits + 00) = uint8 + 51 uint32 = 3 + 51 * 5 = 258\n\n        bytes memory buffer = new bytes(52);\n        uint8 high3 = uint8(id >> 253);\n        buffer[0] = _BASE32_SYMBOLS[high3 & 0x1f];\n\n        id <<= 2;\n        for (uint256 i = 51; i > 0; i--) {\n            buffer[i] = _BASE32_SYMBOLS[id & 0x1f];\n            id >>= 5;\n        }\n\n        return string(abi.encodePacked(\"bafkrei\", buffer));\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721Enumerable {\n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC721 —— IERC721\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\nabstract contract OpenERC721 is IERC721, OpenERC165 {\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    modifier onlyTokenOwnerOrApproved(uint256 tokenID) {\n        require(_isOwnerOrApproved(msg.sender, tokenID), \"Not token owner nor approved\");\n        _;\n    }\n\n    modifier existsToken(uint256 tokenID) {\n        require(_owners[tokenID] != address(0), \"Invalid token ID\");\n        _;\n    }\n\n    function approve(address spender, uint256 tokenID) external override (IERC721) {\n        require(_isOwnerOrOperator(msg.sender, tokenID), \"Not token owner nor operator\");\n\n        _tokenApprovals[tokenID] = spender;\n        emit Approval(ownerOf(tokenID), spender, tokenID);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external override (IERC721) {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenID)\n        external\n        payable\n        override (IERC721)\n    {\n        _transferFrom(from, to, tokenID);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data)\n        external\n        payable\n        override (IERC721)\n    {\n        _safeTransferFrom(from, to, tokenID, data);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenID)\n        public\n        payable\n        override (IERC721)\n    {\n        _safeTransferFrom(from, to, tokenID, \"\");\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x80ac58cd // = type(IERC721).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view override (IERC721) returns (uint256) {\n        require(owner != address(0), \"Invalid zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenID)\n        public\n        view\n        override (IERC721)\n        existsToken(tokenID)\n        returns (address)\n    {\n        return _owners[tokenID];\n    }\n\n    function getApproved(uint256 tokenID)\n        public\n        view\n        override (IERC721)\n        existsToken(tokenID)\n        returns (address)\n    {\n        return _tokenApprovals[tokenID];\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override (IERC721)\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function _mint(address to, string memory, uint256 tokenID) internal virtual {\n        require(to != address(0), \"Mint to zero address\");\n        require(_owners[tokenID] == address(0), \"Token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenID] = to;\n\n        emit Transfer(address(0), to, tokenID);\n        require(_isERC721Receiver(address(0), to, tokenID, \"\"), \"Not ERC721Received\");\n    }\n\n    function _burn(uint256 tokenID) internal virtual {\n        address owner = ownerOf(tokenID);\n        require(owner != address(0), \"Invalid token ID\");\n\n        assert(_balances[owner] > 0);\n\n        _balances[owner] -= 1;\n        delete _tokenApprovals[tokenID];\n        delete _owners[tokenID];\n\n        emit Transfer(owner, address(0), tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID) internal virtual {}\n\n    function _isOwnerOrOperator(address spender, uint256 tokenID)\n        internal\n        view\n        virtual\n        returns (bool ownerOrOperator)\n    {\n        address tokenOwner = ownerOf(tokenID);\n        ownerOrOperator = (tokenOwner == spender || isApprovedForAll(tokenOwner, spender));\n    }\n\n    function _safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data)\n        private\n    {\n        _transferFrom(from, to, tokenID);\n\n        require(_isERC721Receiver(from, to, tokenID, data), \"Not ERC721Receiver\");\n    }\n\n    function _transferFrom(address from, address to, uint256 tokenID)\n        private\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        require(from != address(0), \"Transfer from zero address\");\n        require(to != address(0), \"Transfer to zero address\");\n        require(from == ownerOf(tokenID), \"From not owner\");\n\n        _transferFromBefore(from, to, tokenID);\n\n        delete _tokenApprovals[tokenID];\n\n        if (from != to) {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n            _owners[tokenID] = to;\n        }\n\n        emit Transfer(from, to, tokenID);\n    }\n\n    function _isERC721Receiver(address from, address to, uint256 tokenID, bytes memory data)\n        private\n        returns (bool)\n    {\n        return to.code.length == 0\n            || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenID, data)\n                == IERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    function _isOwnerOrApproved(address spender, uint256 tokenID)\n        private\n        view\n        returns (bool ownerOrApproved)\n    {\n        ownerOrApproved =\n            (_isOwnerOrOperator(spender, tokenID) || (getApproved(tokenID) == spender));\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external\n        payable;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n    function transferFrom(address from, address to, uint256 tokenId) external payable;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenChecker —— IOpenChecker\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\n\nabstract contract OpenChecker is IOpenChecker, OpenERC165 {\n    /// _ercInterfaceIds : ERC interfacesIds\n    /// 0xffffffff :  O Invalid\n    /// 0x01ffc9a7 :  1 ERC165\n    /// 0x80ac58cd :  2 ERC721\n    /// 0x5b5e139f :  3 ERC721Metadata\n    /// 0x780e9d63 :  4 ERC721Enumerable\n    /// 0x150b7a02 :  5 ERC721TokenReceiver\n    /// 0xd9b67a26 :  6 ERC1155\n    /// 0x0e89341c :  7 ERC1155MetadataURI\n    /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n    /// 0x7f5828d0 :  9 ERC173\n    /// 0x2a55205a : 10 ERC2981\n    bytes4[] private _ercInterfaceIds = [\n        bytes4(0xffffffff),\n        bytes4(0x01ffc9a7),\n        bytes4(0x80ac58cd),\n        bytes4(0x5b5e139f),\n        bytes4(0x780e9d63),\n        bytes4(0x150b7a02),\n        bytes4(0xd9b67a26),\n        bytes4(0x0e89341c),\n        bytes4(0x4e2312e0),\n        bytes4(0x7f5828d0),\n        bytes4(0x2a55205a)\n    ];\n\n    modifier onlyContract(address account) {\n        require(account.code.length > 0, \"Not smartcontract\");\n        _;\n    }\n\n    function isCollections(address[] memory smartcontracts)\n        public\n        view\n        override (IOpenChecker)\n        returns (bool[] memory checks)\n    {\n        checks = new bool[](smartcontracts.length);\n\n        for (uint256 i = 0; i < smartcontracts.length; i++) {\n            checks[i] = isCollection(smartcontracts[i]);\n        }\n    }\n\n    function isCollection(address smartcontract)\n        public\n        view\n        override (IOpenChecker)\n        onlyContract(smartcontract)\n        returns (bool)\n    {\n        bool[] memory checks = checkErcInterfaces(smartcontract);\n\n        // ERC165 and (ERC721 or ERC1155)\n        return !checks[0] && checks[1] && (checks[2] || checks[6]);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenChecker).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function checkErcInterfaces(address smartcontract)\n        public\n        view\n        override (IOpenChecker)\n        returns (bool[] memory)\n    {\n        return checkSupportedInterfaces(smartcontract, true, new bytes4[](0));\n    }\n\n    function checkSupportedInterfaces(address smartcontract, bool erc, bytes4[] memory interfaceIds)\n        public\n        view\n        override (IOpenChecker)\n        onlyContract(smartcontract)\n        returns (bool[] memory interfaceIdsChecks)\n    {\n        uint256 i;\n        uint256 len = (erc ? _ercInterfaceIds.length : 0) + interfaceIds.length;\n\n        interfaceIdsChecks = new bool[](len);\n\n        if (erc) {\n            for (uint256 j = 0; j < _ercInterfaceIds.length; j++) {\n                interfaceIdsChecks[i++] =\n                    IERC165(smartcontract).supportsInterface(_ercInterfaceIds[j]);\n            }\n        }\n        for (uint256 k = 0; k < interfaceIds.length; k++) {\n            interfaceIdsChecks[i++] = IERC165(smartcontract).supportsInterface(interfaceIds[k]);\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenCloner/OpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenCloneable —— IOpenCloneable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloneable is IOpenCloneable, OpenERC165 {\n    bool public initialized;\n    string public template;\n    uint256 public version;\n\n    function parent() external view override (IOpenCloneable) returns (address parent_) {\n        // eip1167 deployed code = 45 bytes = 10 bytes + 20 bytes address + 15 bytes\n        // extract bytes 10 to 30: shift 2 bytes (16 bits) then truncate to address 20 bytes (uint160)\n        return\n            (address(this).code.length == 45)\n            ? address(uint160(uint256(bytes32(address(this).code)) >> 16))\n            : address(0);\n    }\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bytes memory params\n    )\n        public\n        virtual\n        override (IOpenCloneable);\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenCloneable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory template_, uint256 version_) internal {\n        require(initialized == false, \"Already initialized\");\n        initialized = true;\n\n        template = template_;\n        version = version_;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenPauseable {\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function paused() external returns (bool);\n\n    function togglePause() external;\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-173: Contract Ownership Standard\n// https://eips.ethereum.org/EIPS/eip-173\n//\n// Derived from OpenZeppelin Contracts (access/Ownable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/access/Ownable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC173 —— IERC173\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenERC173 is IERC173, OpenERC165 {\n    bool private _openERC173Initialized;\n    address private _owner;\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Not owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external override (IERC173) onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function owner() public view override (IERC173) returns (address) {\n        return _owner;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x7f5828d0 || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(address owner_) internal {\n        require(_openERC173Initialized == false, \"Already initialized\");\n        _openERC173Initialized = true;\n\n        _transferOwnership(owner_);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function transferOwnership(address newOwner) external;\n\n    function owner() external view returns (address currentOwner);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-165: Standard Interface Detection\n// https://eips.ethereum.org/EIPS/eip-165\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/utils/introspection/ERC165.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165 —— IERC165\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract OpenERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7; //  type(IERC165).interfaceId\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenChecker {\n    function checkErcInterfaces(address smartcontract)\n        external\n        view\n        returns (bool[] memory interfaceIdsChecks);\n\n    function checkSupportedInterfaces(address smartcontract, bool erc, bytes4[] memory interfaceIds)\n        external\n        view\n        returns (bool[] memory interfaceIdsChecks);\n\n    function isCollection(address collection) external view returns (bool check);\n\n    function isCollections(address[] memory collection)\n        external\n        view\n        returns (bool[] memory checks);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenCloneable {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bytes memory params\n    )\n        external;\n\n    function initialized() external view returns (bool);\n\n    function template() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function parent() external view returns (address);\n}\n"
    },
    "contracts/tests/OpenBound/OpenBoundTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenBound.sol\";\n\nimport \"./OpenBoundSupportsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721NonTransferableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol\";\n\ncontract OpenBoundTest is OpenNFTsTest, ERC173Test, ERC721NonTransferableTest, OpenPauseableTest, OpenBoundSupportsTest {\n    uint256 private _cid = 777;\n\n    function constructorTest(address owner)\n        public\n        override (OpenNFTsTest, ERC173Test, ERC721NonTransferableTest, OpenPauseableTest, OpenBoundSupportsTest)\n        returns (address)\n    {\n        changePrank(owner);\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        OpenBound collection = new OpenBound();\n        collection.initialize(\"OpenBound\", \"BOUND\", owner, 0);\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override (OpenNFTsTest, OpenPauseableTest, ERC721NonTransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        uint256 tokenID = OpenBound(payable(collection)).mint(_cid++);\n        string memory tokenURI = OpenBound(payable(collection)).tokenURI(tokenID);\n        return (tokenID, tokenURI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override (OpenNFTsTest, ERC721NonTransferableTest) {\n        changePrank(OpenBound(payable(collection)).ownerOf(tokenID));\n        OpenBound(payable(collection)).burn(tokenID);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpPausable();\n        setUpOpenNFTs(\"OpenBound\", \"BOUND\");\n        setUpERC721NonTransferable();\n        setUpOpenBoundSupports();\n    }\n}\n"
    },
    "contracts/tests/OpenBound/OpenBoundSupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"../../interfaces/IOpenBound.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenBoundSupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenBoundSupports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, _owner);\n    }\n\n    function testOpenBoundCheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenBoundCheckSupportedInterfaces() public {\n        bytes4[5] memory ids = [\n            type(IOpenChecker).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenCloneable).interfaceId,\n            type(IOpenBound).interfaceId,\n            type(IOpenMarketable).interfaceId\n        ];\n        bool[5] memory expected = [true, true, true, true, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](5);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "forge-std/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nabstract contract OpenNFTsTest is ERC721FullTest {\n    function constructorTest(address owner_)\n        public\n        virtual\n        override (ERC721FullTest)\n        returns (address);\n\n    function mintTest(address collection, address minter_)\n        public\n        virtual\n        override (ERC721FullTest)\n        returns (uint256, string memory);\n\n    function burnTest(address collection, uint256 tokenID)\n        public\n        virtual\n        override (ERC721FullTest);\n\n    function setUpOpenNFTs(string memory name_, string memory symbol_) public {\n        setUpERC721Full(name_, symbol_);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721NonTransferableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nabstract contract ERC721NonTransferableTest is Test, IERC721Events {\n    address private _collection;\n    bool private _transferable;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpERC721NonTransferable() public {\n        _transferable = false;\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testFailERC721SafeTransferFrom() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721SafeTransferFromWithData() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n    }\n\n    function testFailERC721SafeTransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n        IERC721(_collection).safeTransferFrom(from, to, tokenID);\n    }\n\n    function testFailERC721SafeTransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(_collection), _tokenID0);\n    }\n\n    function testFailERC721TransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, address(_collection), _tokenID0);\n    }\n\n    function testFailERC721TransferFrom() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721TransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n        IERC721(_collection).transferFrom(from, to, tokenID);\n    }\n\n    function testFailERC721Approve() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n\n    function testFailERC721SetApprovalForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC173Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC173Test is Test {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpERC173() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testERC173Owner() public {\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testERC173TransferOwnership() public {\n        changePrank(_owner);\n        IERC173(_collection).transferOwnership(_tester);\n        assertEq(IERC173(_collection).owner(), _tester);\n    }\n\n    function testFailERC173NotTransferOwnership() public {\n        changePrank(_tester);\n        IERC173(_collection).transferOwnership(_minter);\n    }\n\n    function testERC173EmitTransferOwnership() public {\n        changePrank(_owner);\n        vm.expectEmit(true, true, false, false);\n        emit OwnershipTransferred(_owner, _tester);\n        IERC173(_collection).transferOwnership(_tester);\n    }\n\n    function testERC173SupportsInterface() public {\n        assertTrue(IERC165(address(_collection)).supportsInterface(type(IERC173).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseableTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _tester = address(0x4);\n\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpPausable() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testPausable() public {\n        assertEq(IOpenPauseable(_collection).paused(), false);\n    }\n\n    function testPausableTogglePause() public {\n        changePrank(_owner);\n\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), true);\n\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), false);\n    }\n\n    function testFailPausableTogglePauseNotOwner() public {\n        changePrank(_tester);\n        IOpenPauseable(_collection).togglePause();\n    }\n\n    function testFailPausableOnlyWhenNotPaused() public {\n        changePrank(_owner);\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), true);\n\n        mintTest(_collection, _owner);\n    }\n\n    function testPausableEmitSetPause() public {\n        changePrank(_owner);\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(true, _owner);\n        IOpenPauseable(_collection).togglePause();\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(false, _owner);\n        IOpenPauseable(_collection).togglePause();\n    }\n\n    function testPausableSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IOpenPauseable).interfaceId));\n    }\n}\n"
    },
    "contracts/next/OpenNFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//    OpenERC165\n//        |\n//  OpenResolver\n//        |\n//  OpenNFTsResolver —— IOpenNFTsResolver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenResolver.sol\";\nimport \"../interfaces/IOpenNFTsResolver.sol\";\nimport \"../interfaces/IAll.sol\";\n\ncontract OpenNFTsResolver is IOpenNFTsResolver, OpenResolver {\n    bytes4[] private _interfaceIds = new bytes4[](12);\n\n    uint8 private constant _IERC_2981 = 10;\n    uint8 private constant _IERC_LENGTH = 11;\n\n    uint8 private constant _IOPEN_NFTS = _IERC_LENGTH + 0;\n    uint8 private constant _IOPEN_CHECKER = _IERC_LENGTH + 1;\n    uint8 private constant _IOPEN_CLONEABLE = _IERC_LENGTH + 2;\n    uint8 private constant _IOPEN_MARKETABLE = _IERC_LENGTH + 3;\n    uint8 private constant _IOPEN_PAUSEABLE = _IERC_LENGTH + 4;\n\n    uint8 private constant _IOPEN_NFTS_V0 = _IERC_LENGTH + 5;\n    uint8 private constant _IOPEN_NFTS_V1 = _IERC_LENGTH + 6;\n    uint8 private constant _IOPEN_NFTS_V2 = _IERC_LENGTH + 7;\n    uint8 private constant _IOPEN_NFTS_V3 = _IERC_LENGTH + 8;\n    uint8 private constant _IOPEN_NFTS_V4 = _IERC_LENGTH + 9;\n    uint8 private constant _IOPEN_AUTOMARKET = _IERC_LENGTH + 10;\n    uint8 private constant _IOPEN_BOUND = _IERC_LENGTH + 11;\n\n    constructor(address owner_, address registerer_) {\n        OpenERC173._initialize(owner_);\n        OpenRegistry._setRegisterer(registerer_);\n\n        /// 0xffffffff :  O Invalid\n        /// 0x01ffc9a7 :  1 ERC165\n        /// 0x80ac58cd :  2 ERC721\n        /// 0x5b5e139f :  3 ERC721Metadata\n        /// 0x780e9d63 :  4 ERC721Enumerable\n        /// 0x150b7a02 :  5 ERC721TokenReceiver\n        /// 0xd9b67a26 :  6 ERC1155\n        /// 0x0e89341c :  7 ERC1155MetadataURI\n        /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n        /// 0x7f5828d0 :  9 ERC173\n        /// 0x2a55205a : 10 ERC2981\n\n        _interfaceIds[_IOPEN_NFTS - _IERC_LENGTH] = type(IOpenNFTs).interfaceId;\n        _interfaceIds[_IOPEN_CHECKER - _IERC_LENGTH] = type(IOpenChecker).interfaceId;\n        _interfaceIds[_IOPEN_CLONEABLE - _IERC_LENGTH] = type(IOpenCloneable).interfaceId;\n        _interfaceIds[_IOPEN_MARKETABLE - _IERC_LENGTH] = type(IOpenMarketable).interfaceId;\n        _interfaceIds[_IOPEN_PAUSEABLE - _IERC_LENGTH] = type(IOpenPauseable).interfaceId;\n\n        _interfaceIds[_IOPEN_NFTS_V0 - _IERC_LENGTH] = type(IOpenNFTsV0).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V1 - _IERC_LENGTH] = type(IOpenNFTsV1).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V2 - _IERC_LENGTH] = type(IOpenNFTsV2).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V3 - _IERC_LENGTH] = type(IOpenNFTsV3).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V4 - _IERC_LENGTH] = type(IOpenNFTsV4).interfaceId;\n        _interfaceIds[_IOPEN_AUTOMARKET - _IERC_LENGTH] = type(IOpenAutoMarket).interfaceId;\n        _interfaceIds[_IOPEN_BOUND - _IERC_LENGTH] = type(IOpenBound).interfaceId;\n    }\n\n    function getOpenNFTsNftsInfos(\n        address collection,\n        address account,\n        uint256 limit,\n        uint256 offset\n    )\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        (nftInfos, count, total) = OpenGetter.getNftsInfos(collection, account, limit, offset);\n\n        openNTFsNftInfos = new OpenNFTsNftInfos[](nftInfos.length);\n        for (uint256 i = 0; i < nftInfos.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, nftInfos[i].tokenID, collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftsInfos(\n        address collection,\n        uint256[] memory tokenIDs,\n        address account\n    )\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, address(0), _interfaceIds);\n\n        nftInfos = OpenGetter.getNftsInfos(collection, tokenIDs, account);\n        openNTFsNftInfos = new OpenNFTsNftInfos[](tokenIDs.length);\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, tokenIDs[i], collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftInfos(\n        address collection,\n        uint256 tokenID,\n        address account\n    )\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        nftInfos = OpenGetter.getNftInfos(collection, tokenID, account);\n        openNTFsNftInfos = _getOpenNFTsNftInfos(collection, tokenID, collectionInfos.supported);\n    }\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        CollectionInfos[] memory collectionsInfosAll = getCollectionsInfos(getAddresses(), account, _interfaceIds);\n        total = collectionsInfosAll.length;\n\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                count++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](count);\n        openNFTsCollectionsInfos = new OpenNFTsCollectionInfos[](count);\n\n        uint256 j;\n        for (uint256 i = 0; i < total; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j] = collectionsInfosAll[i];\n                openNFTsCollectionsInfos[j] = _getOpenNFTsCollectionInfos(\n                    collectionsInfosAll[i].collection,\n                    collectionsInfosAll[i].supported\n                );\n                j++;\n            }\n        }\n    }\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos)\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n        openNTFscollectionInfos = _getOpenNFTsCollectionInfos(collection, collectionInfos.supported);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(OpenResolver) returns (bool) {\n        return interfaceId == type(IOpenNFTsResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _getOpenNFTsNftInfos(\n        address collection,\n        uint256 tokenID,\n        bool[] memory supported\n    ) internal view returns (OpenNFTsNftInfos memory nftInfos) {\n        if (supported[_IERC_2981]) {\n            uint256 fee;\n            (nftInfos.receiver, fee) = IERC2981(collection).royaltyInfo(tokenID, 10000);\n            nftInfos.fee = uint96(fee);\n        }\n        if (supported[_IOPEN_MARKETABLE]) {\n            nftInfos.price = IOpenMarketable(payable(collection)).tokenPrice(tokenID);\n        }\n    }\n\n    function _getOpenNFTsCollectionInfos(address collection, bool[] memory supported)\n        internal\n        view\n        returns (OpenNFTsCollectionInfos memory collInfos)\n    {\n        if (supported[_IOPEN_CLONEABLE]) {\n            collInfos.version = IOpenCloneable(collection).version(); // 4\n            collInfos.template = IOpenCloneable(collection).template(); // OpenNFTsV4 or OpenBound\n            collInfos.open = IOpenNFTsV4(collection).open();\n        } else if (supported[_IOPEN_NFTS_V3]) {\n            collInfos.version = 3;\n            collInfos.template = \"OpenNFTsV3\";\n            collInfos.open = IOpenNFTsV3(collection).open();\n        } else if (supported[_IOPEN_NFTS_V2]) {\n            collInfos.version = 2;\n        } else if (supported[_IOPEN_NFTS_V1]) {\n            collInfos.version = 1;\n        } else if (supported[_IOPEN_NFTS_V0]) {\n            collInfos.version = 0;\n        }\n\n        if (supported[_IOPEN_MARKETABLE]) {\n            (collInfos.receiver, collInfos.fee) = IOpenMarketable(payable(collection)).getDefaultRoyalty();\n            collInfos.price = IOpenMarketable(payable(collection)).defaultPrice();\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC4973.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\n"
    },
    "contracts/interfaces/IOpenNFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IOpenNFTsInfos.sol\";\n\ninterface IOpenNFTsResolver is IOpenNFTsInfos {\n    function getOpenNFTsNftsInfos(\n        address collection,\n        address account,\n        uint256 limit,\n        uint256 offset\n    )\n        external\n        view\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        );\n\n    function getOpenNFTsNftsInfos(\n        address collection,\n        uint256[] memory tokenIDs,\n        address account\n    )\n        external\n        view\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos\n        );\n\n    function getOpenNFTsNftInfos(\n        address collection,\n        uint256 tokenID,\n        address account\n    )\n        external\n        view\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos\n        );\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        );\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos);\n}\n"
    },
    "contracts/interfaces/IAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport \"./ICloneFactoryV2.sol\";\nimport \"./INFTsFactoryV2.sol\";\nimport \"./IOpenFactoryV3.sol\";\nimport \"./IOpenNFTsV0.sol\";\nimport \"./IOpenNFTsV1.sol\";\nimport \"./IOpenNFTsV2.sol\";\nimport \"./IOpenNFTsV3.sol\";\nimport \"./IOpenNFTsV4.sol\";\nimport \"./IOpenAutoMarket.sol\";\nimport \"./IOpenBound.sol\";\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//        ————————————————\n//        |              |\n//   OpenChecker     OpenERC173\n//        |              |\n//    OpenGetter    OpenRegistry\n//        |              |\n//        ————————————————\n//        |\n//  OpenResolver —— IOpenResolver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenRegistry.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenResolver.sol\";\n\nabstract contract OpenResolver is IOpenResolver, OpenRegistry, OpenGetter {\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address addr) override (OpenRegistry) {\n        require(isCollection(addr), \"Not Collection\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenRegistry, OpenGetter)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenResolver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    )\n        public\n        view\n        override (IOpenResolver)\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        collectionsInfos = new CollectionInfos[](collections.length);\n        for (uint256 i = 0; i < collections.length; i++) {\n            collectionsInfos[i] = _getCollectionInfos(collections[i], account, interfaceIds);\n        }\n    }\n\n    function _getCollectionsInfos(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        CollectionInfos[] memory collectionsInfosAll =\n            getCollectionsInfos(getAddresses(), account, interfaceIds);\n\n        uint256 len;\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                len++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](len);\n\n        uint256 j;\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j++] = collectionsInfosAll[i];\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTsInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenNFTsInfos is IERCNftInfos {\n    struct OpenNFTsCollectionInfos {\n        uint256 version;\n        string template;\n        bool open;\n        uint256 price;\n        address receiver;\n        uint96 fee;\n    }\n\n    struct OpenNFTsNftInfos {\n        uint256 price;\n        address receiver;\n        uint96 fee;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERCNftInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n// Infos of either ERC721 or ERC1155 NFT\ninterface IERCNftInfos {\n    enum NftType {\n        ERC721,\n        ERC1155\n    }\n\n    struct CollectionInfos {\n        address collection;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n        uint256 balanceOf;\n        bool[] supported;\n        NftType erc;\n    }\n\n    struct NftInfos {\n        uint256 tokenID;\n        string tokenURI;\n        address owner;\n        address approved;\n        uint256 balanceOf;\n        NftType erc;\n    }\n}\n"
    },
    "contracts/interfaces/ICloneFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICloneFactoryV2 {\n    /// @notice New Implementation Event\n    /// @param implementation Address of the implementation\n    /// @param creator Address of the creator\n    /// @return index Index inside implementations array (starts at 0)\n    event ImplementationNew(address indexed implementation, address indexed creator, uint256 index);\n\n    /// @notice Set Template Event\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    event TemplateSet(string indexed templateName, address indexed template);\n\n    /// @notice Set Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template) external;\n\n    /// @notice Add Implementation\n    /// @param implementationToAdd Addresses of implementations to add\n    function implementationsAdd(address[] calldata implementationToAdd) external;\n\n    /// @notice Get Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templates(string calldata templateName) external view returns (address template);\n\n    /// @notice Count Implementations\n    /// @return count Number of implementations\n    function implementationsCount() external view returns (uint256 count);\n\n    /// @notice Get Implementation from Implementations array\n    /// @param index Index of implementation\n    /// @return implementation Address of implementation\n    function implementations(uint256 index) external view returns (address implementation);\n}\n"
    },
    "contracts/interfaces/INFTsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface INFTsFactoryV2 {\n    struct NftData {\n        address nft;\n        uint256 balanceOf;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external returns (address);\n\n    function balancesOf(address owner) external view returns (NftData[] memory);\n}\n"
    },
    "contracts/interfaces/IOpenFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenFactoryV3 {\n    event Clone(string indexed templateName, address indexed clone, string indexed name, string symbol);\n\n    event SetResolver(address indexed resolver);\n\n    event SetTemplate(string indexed templateName, address indexed template, uint256 index);\n\n    function setResolver(address resolver) external;\n\n    function setTemplate(string memory templateName, address template) external;\n\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bytes memory params\n    ) external returns (address);\n\n    function template(string memory templateName) external view returns (address);\n\n    function templates(uint256 num) external view returns (address);\n\n    function countTemplates() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV0 {\n    function addUser(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV1 {\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV2 {\n    function transferOwnership(address newOwner) external;\n\n    function initialize(string memory name, string memory symbol) external;\n\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID_);\n\n    function owner() external view returns (address owner_);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV3 {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTsV4 {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenAutoMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenAutoMarket {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        uint256 defaultPrice,\n        address receiver,\n        uint96 fee,\n        bool[] memory options\n    ) external;\n\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(\n        address minter,\n        string memory tokenURI,\n        uint256 price,\n        address receiver,\n        uint96 fee\n    ) external payable returns (uint256 tokenID);\n\n    function buy(uint256 tokenID) external payable;\n\n    function open() external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity 0.8.9;\n\ninterface IERC1155 {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155TokenReceiver.sol)\n\npragma solidity 0.8.9;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    )\n        external\n        returns (bytes4);\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155METADATAURI.sol)\n\npragma solidity 0.8.9;\n\ninterface IERC1155MetadataURI {\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenMarketable {\n    event SetDefaultRoyalty(address receiver, uint96 fee);\n\n    event SetTokenRoyalty(uint256 tokenID, address receiver, uint96 fee);\n\n    event SetDefaultPrice(uint256 price);\n\n    event SetTokenPrice(uint256 tokenID, uint256 price);\n\n    event Pay(\n        uint256 tokenID,\n        uint256 price,\n        address seller,\n        uint256 paid,\n        address receiver,\n        uint256 royalties,\n        address buyer,\n        uint256 unspent\n    );\n\n    receive() external payable;\n\n    function setDefaultRoyalty(address receiver, uint96 fee) external;\n\n    function setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee) external;\n\n    function setTokenRoyaltyReceiver(uint256 tokenID, address receiver) external;\n\n    function setDefaultPrice(uint256 price) external;\n\n    function setTokenPrice(uint256 tokenID, uint256 price) external;\n\n    function defaultPrice() external view returns (uint256 defPrice);\n\n    function tokenPrice(uint256 tokenID) external view returns (uint256 price);\n\n    function getDefaultRoyalty() external view returns (address receiver, uint96 fee);\n\n    function getTokenRoyalty(uint256 tokenID)\n        external\n        view\n        returns (address receiver, uint96 fee);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721Events {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC2981 {\n    function royaltyInfo(uint256 tokenID, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTs {\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n\n    function withdraw() external;\n\n    function withdraw(address token) external;\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenRegistry —— IOpenRegistry\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\n\nabstract contract OpenRegistry is IOpenRegistry, OpenERC173 {\n    mapping(address => uint256) private _numAddress;\n    address[] private _addresses;\n    address public registerer;\n\n    /// @notice onlyRegisterer, by default owner is registerer and can add addresses, can be overriden\n    modifier onlyRegisterer() virtual {\n        require(msg.sender == owner() || msg.sender == registerer, \"Not registerer nor owner\");\n        _;\n    }\n\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address) virtual {\n        _;\n    }\n\n    function setRegisterer(address registerer_) external override (IOpenRegistry) onlyOwner {\n        _setRegisterer(registerer_);\n    }\n\n    function addAddresses(address[] memory addrs) external override (IOpenRegistry) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            _addAddress(addrs[i]);\n        }\n    }\n\n    function addAddress(address addr) external override (IOpenRegistry) {\n        _addAddress(addr);\n    }\n\n    function removeAddress(address addr) external override (IOpenRegistry) {\n        _removeAddress(addr);\n    }\n\n    function countAddresses() external view override (IOpenRegistry) returns (uint256) {\n        return _addresses.length;\n    }\n\n    function isRegistered(address addr) public view returns (bool) {\n        return _numAddress[addr] >= 1;\n    }\n\n    function getAddresses() public view override (IOpenRegistry) returns (address[] memory) {\n        return _addresses;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC173)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenRegistry).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _setRegisterer(address registerer_) internal {\n        registerer = registerer_;\n    }\n\n    function _addAddress(address addr) private onlyRegisterer onlyValid(addr) {\n        if (!isRegistered(addr)) {\n            _addresses.push(addr);\n            _numAddress[addr] = _addresses.length;\n        }\n    }\n\n    function _removeAddress(address addr) private onlyRegisterer {\n        require(isRegistered(addr), \"Not registered\");\n\n        uint256 num = _numAddress[addr];\n        if (num != _addresses.length) {\n            address addrLast = _addresses[_addresses.length - 1];\n            _addresses[num - 1] = addrLast;\n            _numAddress[addrLast] = num;\n        }\n\n        delete (_numAddress[addr]);\n        _addresses.pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenChecker\n//        |\n//  OpenGetter —— IOpenGetter\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenGetter is IOpenGetter, OpenChecker {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenChecker)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenGetter).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionInfos(address collection, address account)\n        public\n        view\n        override (IOpenGetter)\n        returns (\n            // override(IOpenGetter)\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = _getCollectionInfos(collection, account, new bytes4[](0));\n    }\n\n    function getNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        public\n        view\n        override (IOpenGetter)\n        returns (NftInfos[] memory nftsInfos)\n    {\n        nftsInfos = new NftInfos[](tokenIDs.length);\n        for (uint256 i; i < tokenIDs.length; i++) {\n            nftsInfos[i] = _getNftInfos(collection, tokenIDs[i], account);\n        }\n    }\n\n    function getNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        public\n        view\n        override (IOpenGetter)\n        returns (NftInfos[] memory nftsInfos, uint256 count, uint256 total)\n    {\n        bool[] memory supported = checkErcInterfaces(collection);\n\n        // IF ERC721 & ERC721Enumerable supported\n        if (supported[2] && supported[4]) {\n            if (account == address(0)) {\n                total = IERC721Enumerable(collection).totalSupply();\n\n                require(offset <= total, \"Invalid offset\");\n                count = (offset + limit <= total) ? limit : total - offset;\n\n                nftsInfos = new NftInfos[](count);\n                for (uint256 i; i < count; i++) {\n                    nftsInfos[i] = _getNftInfos(\n                        collection, IERC721Enumerable(collection).tokenByIndex(offset + i), account\n                    );\n                }\n            } else {\n                total = IERC721(collection).balanceOf(account);\n\n                require(offset <= total, \"Invalid offset\");\n                count = (offset + limit <= total) ? limit : total - offset;\n\n                nftsInfos = new NftInfos[](count);\n                for (uint256 i; i < count; i++) {\n                    nftsInfos[i] = _getNftInfos(\n                        collection,\n                        IERC721Enumerable(collection).tokenOfOwnerByIndex(account, offset + i),\n                        account\n                    );\n                }\n            }\n        }\n    }\n\n    function getNftInfos(address collection, uint256 tokenID, address account)\n        public\n        view\n        override (IOpenGetter)\n        returns (NftInfos memory nftInfos)\n    {\n        return _getNftInfos(collection, tokenID, account);\n    }\n\n    function _getNftInfos(address collection, uint256 tokenID, address account)\n        internal\n        view\n        onlyContract(collection)\n        returns (NftInfos memory nftInfos)\n    {\n        nftInfos.tokenID = tokenID;\n        nftInfos.approved = IERC721(collection).getApproved(tokenID);\n        nftInfos.owner = IERC721(collection).ownerOf(tokenID);\n\n        if (IERC165(collection).supportsInterface(0x5b5e139f)) {\n            // ERC721Metadata\n            nftInfos.tokenURI = IERC721Metadata(collection).tokenURI(tokenID);\n        } else if (IERC165(collection).supportsInterface(0x0e89341c)) {\n            // ERC1155MetadataURI\n            nftInfos.tokenURI = IERC1155MetadataURI(collection).uri(tokenID);\n            nftInfos.balanceOf = IERC1155(collection).balanceOf(account, tokenID);\n        }\n    }\n\n    function _getCollectionInfos(address collection, address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        onlyContract(collection)\n        returns (CollectionInfos memory collectionInfos)\n    {\n        bool[] memory supported = checkSupportedInterfaces(collection, true, interfaceIds);\n        collectionInfos.supported = supported;\n\n        // ERC165 must be supported\n        require(!supported[0] && supported[1], \"Not ERC165\");\n\n        // ERC721 or ERC1155 must be supported\n        require(supported[2] || supported[6], \"Not NFT smartcontract\");\n\n        collectionInfos.collection = collection;\n\n        // try ERC173 owner\n        try IERC173(collection).owner() returns (address owner) {\n            collectionInfos.owner = owner;\n        } catch {}\n\n        // try ERC721Metadata name\n        try IERC721Metadata(collection).name() returns (string memory name) {\n            collectionInfos.name = name;\n        } catch {}\n\n        // try ERC721Metadata symbol\n        try IERC721Metadata(collection).symbol() returns (string memory symbol) {\n            collectionInfos.symbol = symbol;\n        } catch {}\n\n        // try ERC721Enumerable totalSupply\n        try IERC721Enumerable(collection).totalSupply() returns (uint256 totalSupply) {\n            collectionInfos.totalSupply = totalSupply;\n        } catch {}\n\n        if (account != address(0)) {\n            try IERC721(collection).balanceOf(account) returns (uint256 balanceOf) {\n                collectionInfos.balanceOf = balanceOf;\n            } catch {}\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenResolver is IERCNftInfos {\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    )\n        external\n        view\n        returns (CollectionInfos[] memory collectionsInfos);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenRegistry {\n    function setRegisterer(address registerer) external;\n\n    function removeAddress(address addr) external;\n\n    function addAddress(address addr) external;\n\n    function addAddresses(address[] memory addrs) external;\n\n    function getAddresses() external view returns (address[] memory);\n\n    function registerer() external view returns (address);\n\n    function countAddresses() external view returns (uint256);\n\n    function isRegistered(address addr) external view returns (bool registered);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenGetter is IERCNftInfos {\n    function getCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos);\n\n    function getNftInfos(address collection, uint256 tokenID, address account)\n        external\n        view\n        returns (NftInfos memory nftInfos);\n\n    function getNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        external\n        view\n        returns (NftInfos[] memory nftsInfos, uint256 count, uint256 total);\n\n    function getNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        external\n        view\n        returns (NftInfos[] memory nftsInfos);\n}\n"
    },
    "forge-std/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapated from Solmate implementation (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))));\n    }\n\n    function addressFromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n}\n"
    },
    "ds-test/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "forge-std/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns(uint256);\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns(bool);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata,uint256) external returns(uint256);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns(uint256);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns(uint256);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    /// Returns the RPC url for the given alias\n\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address) external;\n    function makePersistent(address, address) external;\n    function makePersistent(address, address, address) external;\n    function makePersistent(address[] calldata) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address) external;\n    function revokePersistent(address[] calldata) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address) external returns (bool);\n\n    function rpcUrl(string calldata) external returns(string memory);\n    /// Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns(string[2][] memory);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "OpenNFTs/contracts/interfaces/IERC4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC4973 {\n    event Attest(address indexed to, uint256 indexed tokenID);\n\n    // event Revoke(address indexed to, uint256 indexed tokenID);\n\n    function ownerOf(uint256 tokenID) external view returns (address);\n\n    // function burn(uint256 tokenID) external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/ITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface ITest {\n    function setUp() external;\n}\n"
    },
    "OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/units/ERC165Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721MetadataTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721EnumerableTest.t.sol\";\n\nabstract contract ERC721FullTest is\n    ERC165Test,\n    ERC721Test,\n    ERC721MetadataTest,\n    ERC721EnumerableTest\n{\n    string internal constant _TOKEN_URI =\n        \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n    bool private _transferable = true;\n\n    function constructorTest(address owner_)\n        public\n        virtual\n        override (ERC165Test, ERC721Test, ERC721MetadataTest, ERC721EnumerableTest)\n        returns (address);\n\n    function mintTest(address collection, address minter_)\n        public\n        virtual\n        override (ERC721Test, ERC721MetadataTest, ERC721EnumerableTest)\n        returns (uint256, string memory);\n\n    function burnTest(address collection, uint256 tokenID) public virtual override (ERC721Test);\n\n    function setUpERC721Full(string memory name_, string memory symbol_) public {\n        // setUpERC165();\n        setUpERC165();\n        setUpERC721();\n        setUpERC721Metadata(name_, symbol_);\n        setUpERC721Enumerable();\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nabstract contract ERC721Test is Test, IERC721Events {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpERC721() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721BalanceOf() public {\n        assertEq(IERC721(_collection).balanceOf(_minter), 1);\n        assertEq(IERC721(_collection).balanceOf(_tester), 0);\n    }\n\n    function testERC721BalanceOfBis() public {\n        mintTest(_collection, _tester);\n        assertEq(IERC721(_collection).balanceOf(_tester), 1);\n    }\n\n    function testERC721OwnerOf() public {\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721OwnerOfBis() public {\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        assertEq(IERC721(_collection).ownerOf(tokenID), _tester);\n    }\n\n    function testFailERC721NotOnlyTokenOwner() public {\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721ApproveChange() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n        IERC721(_collection).approve(address(0), _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n\n    function testERC721GetApproved() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        assertEq(IERC721(_collection).getApproved(_tokenID0), _tester);\n    }\n\n    function testFailERC721GetApproved() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n        IERC721(_collection).approve(_buyer, _tokenID0);\n\n        assertEq(IERC721(_collection).getApproved(_tokenID0), _tester);\n    }\n\n    function testERC721IsApprovedForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n        assertTrue(IERC721(_collection).isApprovedForAll(_minter, _tester));\n    }\n\n    function testERC721IsNotApprovedForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n        IERC721(_collection).setApprovalForAll(_tester, false);\n\n        assertFalse(IERC721(_collection).isApprovedForAll(_minter, _tester));\n    }\n\n    function testERC721SupportsInterface() public {\n        assertTrue(IERC165(address(_collection)).supportsInterface(type(IERC721).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721MetadataTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC721MetadataTest is Test {\n    address private _collection;\n    string private _name;\n    string private _symbol;\n    string private _tokenURI0;\n    uint256 private _tokenID0;\n    address private _minter = address(0x23);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpERC721Metadata(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _collection = constructorTest(_minter);\n        (_tokenID0, _tokenURI0) = mintTest(_collection, _minter);\n    }\n\n    function testERC721MetadataName() public {\n        assertEq(IERC721Metadata(_collection).name(), _name);\n    }\n\n    function testERC721MetadataSymbol() public {\n        assertEq(IERC721Metadata(_collection).symbol(), _symbol);\n    }\n\n    function testERC721MetadataURI() public {\n        assertEq(IERC721Metadata(_collection).tokenURI(_tokenID0), _tokenURI0);\n    }\n\n    function testERC721MetadataSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC721Metadata).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721EnumerableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC721EnumerableTest is Test {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x2);\n    address private _minter = address(0x22);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpERC721Enumerable() public {\n        _collection = constructorTest(_owner);\n        (_tokenID0,) = mintTest(_collection, _minter);\n    }\n\n    function testERC721EnumerableTotalSupply() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n    }\n\n    function testERC721EnumerableTotalSupplyIncrement() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        mintTest(_collection, _tester);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 2);\n    }\n\n    function testERC721EnumerableTokenByIndex() public {\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n    }\n\n    function testFailERC721EnumerableTokenByIndex() public view {\n        IERC721Enumerable(_collection).tokenByIndex(1);\n    }\n\n    function testERC721EnumerableTokenByIndexSecond() public {\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(1), tokenID);\n    }\n\n    function testERC721EnumerableTokenOfOwnerByIndex() public {\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n    }\n\n    function testFailERC721EnumerableTokenOfOwnerByIndex() public view {\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 1);\n    }\n\n    function testERC721EnumerableTokenOfOwnerByIndexOther() public {\n        console.log(\"_tokenID0\", _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        console.log(\"tokenID\", tokenID);\n\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0), tokenID);\n    }\n\n    function testERC721EnumerableSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC721Enumerable).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC165Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC165Test is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpERC165() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testERC165SupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC165).interfaceId));\n        assertFalse(IERC165(_collection).supportsInterface(0xffffffff));\n    }\n}\n"
    },
    "contracts/next/OpenFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————\n//       |        |            |\n//       |   OpenERC173    OpenCloner\n//       |    (ownable)        |\n//       |        |            |\n//       ———————————————————————\n//       |\n// OpenFactoryV3 —— IOpenFactoryV3\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloner.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\nimport \"../interfaces/IOpenFactoryV3.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\nimport \"../interfaces/IOpenAutoMarket.sol\";\n\n/// @title OpenFactory smartcontract\n/// @notice Factory for NFTs contracts: ERC721 or ERC1155\n/// @notice Create new NFTs Collections smartcontracts by cloning templates\ncontract OpenFactoryV3 is IOpenFactoryV3, OpenERC173, OpenCloner {\n    /// @notice Named Templates\n\n    mapping(string => uint256) private _numTemplates;\n    address[] public templates;\n\n    address public nftsResolver;\n\n    constructor(address initialOwner) {\n        OpenERC173._transferOwnership(initialOwner);\n    }\n\n    /// @notice clone template\n    /// @param name name of Clone collection\n    /// @param symbol symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bytes memory params\n    ) external override(IOpenFactoryV3) returns (address clone_) {\n        clone_ = clone(template(templateName));\n\n        IOpenCloneable(clone_).initialize(name, symbol, msg.sender, params);\n\n        IOpenRegistry(nftsResolver).addAddress(clone_);\n\n        emit Clone(templateName, clone_, name, symbol);\n    }\n\n    function countTemplates() external view override(IOpenFactoryV3) returns (uint256 count) {\n        count = templates.length;\n    }\n\n    function setResolver(address resolver_) public override(IOpenFactoryV3) onlyOwner {\n        nftsResolver = resolver_;\n\n        emit SetResolver(nftsResolver);\n    }\n\n    /// @notice Set Template by Name\n    /// @param templateName_ Name of the template\n    /// @param template_ Address of the template\n    function setTemplate(string memory templateName_, address template_) public override(IOpenFactoryV3) onlyOwner {\n        require(IERC165(template_).supportsInterface(type(IOpenCloneable).interfaceId), \"Not OpenCloneable\");\n        require(IOpenCloneable(template_).initialized(), \"Not initialized\");\n        require(template_.code.length != 45, \"Clone not valid template\");\n\n        uint256 num = _numTemplates[templateName_];\n        if (num >= 1) {\n            templates[num - 1] = template_;\n        } else {\n            templates.push(template_);\n            num = templates.length;\n\n            _numTemplates[templateName_] = num;\n        }\n\n        IOpenRegistry(nftsResolver).addAddress(template_);\n\n        emit SetTemplate(templateName_, template_, num);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC173, OpenCloner) returns (bool) {\n        return interfaceId == type(IOpenFactoryV3).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get Template\n    /// @param  templateName : template name\n    /// @return template_ : template address\n    function template(string memory templateName) public view override(IOpenFactoryV3) returns (address template_) {\n        uint256 num = _numTemplates[templateName];\n        require(num >= 1, \"Invalid Template\");\n\n        template_ = templates[num - 1];\n        require(template_ != address(0), \"No Template\");\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenCloner/OpenCloner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-1167: Minimal Proxy Contract\n// https://eips.ethereum.org/EIPS/eip-1167\n//\n// Derived from OpenZeppelin Contracts (proxy/Clones.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/Clones.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//        |\n//   OpenCloner —— IOpenCloner\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloner.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloner is IOpenCloner, OpenERC165 {\n    /// @notice Clone template (via EIP-1167)\n    /// @param  template_ : template address\n    /// @return clone_ : clone address\n    function clone(address template_) public virtual returns (address clone_) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, template_))\n            mstore(\n                add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            clone_ := create(0, ptr, 0x37)\n        }\n        assert(clone_ != address(0));\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenCloner).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenCloner {\n    function clone(address template) external returns (address);\n}\n"
    },
    "contracts/tests/OpenFactoryV3/OpenFactoryV3Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenFactoryV3.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\nimport \"../../next/OpenNFTsV4.sol\";\nimport \"../../next/OpenAutoMarket.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"./OpenFactoryV3CloneTest.t.sol\";\n\ncontract OpenFactoryV3Test is ERC173Test, OpenFactoryV3CloneTest {\n    function constructorTest(address owner) public override(ERC173Test, OpenFactoryV3CloneTest) returns (address) {\n        changePrank(owner);\n\n        // FACTORY\n        OpenFactoryV3 factory = new OpenFactoryV3(owner);\n\n        // RESOLVER\n        OpenNFTsResolver resolver = new OpenNFTsResolver(owner, address(factory));\n        factory.setResolver(address(resolver));\n\n        // OPEN_NFTS\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        // TEMPLATE OpenNFTsV4\n        OpenNFTsV4 _openNFTsV4 = new OpenNFTsV4();\n        _openNFTsV4.initialize(\"OpenNFTsV4 for OpenFactoryV3Test\", \"OPTEST\", owner, options);\n        factory.setTemplate(\"OpenNFTsV4\", address(_openNFTsV4));\n\n        // TEMPLATE OpenAutoMarket\n        OpenAutoMarket _openAutoMarket = new OpenAutoMarket();\n        _openAutoMarket.initialize(\"OpenFactoryV3Test\", \"OPTEST\", owner, 0, address(0), 0, options);\n        factory.setTemplate(\"OpenAutoMarket\", address(_openAutoMarket));\n\n        return address(factory);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpOpenFactoryV3Clone();\n    }\n}\n"
    },
    "contracts/next/OpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————————————————————————————————\n//       |                                    |            |\n//   OpenERC721                          OpenERC173  OpenCloneable\n//     (NFT)                              (ownable)        |\n//       |                                    |            |\n//       ——————————————————————————           |            |\n//       |                        |           |            |\n//  OpenERC721Metadata  OpenERC721Enumerable  |            |\n//       |                        |           |            |\n//       ———————————————————————————————————————————————————\n//       |\n//   OpenNFTsV4 —— IOpenNFTsV4\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsV4 is IOpenNFTsV4, OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable {\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function mint(string memory tokenURI_) external override(IOpenNFTsV4) returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, tokenURI_);\n    }\n\n    function mint(address minter, string memory tokenURI_)\n        external\n        override(IOpenNFTsV4)\n        onlyOwner\n        returns (uint256 tokenID)\n    {\n        tokenID = _mint(minter, tokenURI_);\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID) external override(IOpenNFTsV4) onlyTokenOwnerOrApproved(tokenID) {\n        _burn(tokenID);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bool[] memory options_\n    ) public override(IOpenNFTsV4) {\n        tokenIdNext = 1;\n\n        OpenCloneable._initialize(\"OpenNFTsV4\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n\n        open = options_[0];\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public override(OpenCloneable) {\n        initialize(name_, symbol_, owner_, abi.decode(params_, (bool[])));\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTsV4).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address minter, string memory tokenURI) internal returns (uint256 tokenID) {\n        tokenID = tokenIdNext++;\n\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    function _mint(\n        address minter,\n        string memory tokenURI,\n        uint256 tokenID\n    ) internal override(OpenERC721Enumerable, OpenERC721Metadata) {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721Enumerable, OpenERC721Metadata) {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal override(OpenERC721, OpenERC721Enumerable) {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "contracts/next/OpenAutoMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————————————————————————————————————————————————————————\n//       |                                                         |               |\n//   OpenERC721                                               OpenERC173     OpenCloneable\n//     (NFT)                                                   (ownable)           |\n//       |                                                         |               |\n//       —————————————————————————————————————————————      ————————               |\n//       |                        |                  |      |      |               |\n//  OpenERC721Metadata  OpenERC721Enumerable   OpenERC2981  |      |               |\n//       |                        |           (RoyaltyInfo) |      |               |\n//       |                        |                  |      |      |               |\n//       |                        |                  ————————      |               |\n//       |                        |                  |             |               |\n//       |                        |            OpenMarketable OpenPauseable        |\n//       |                        |                  |             |               |\n//       ———————————————————————————————————————————————————————————————————————————\n//       |\n//    OpenNFTs\n//       |\n//   OpenAutoMarket —— IOpenAutoMarket\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol\";\nimport \"../interfaces/IOpenAutoMarket.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenAutoMarket is IOpenAutoMarket, OpenNFTs {\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() override(OpenNFTs) {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function buy(uint256 tokenID) external payable override(IOpenAutoMarket) existsToken(tokenID) {\n        /// Get token price\n        uint256 price = tokenPrice[tokenID];\n\n        /// Require price defined\n        require(price > 0, \"Not to sell\");\n\n        /// Require enough value sent\n        require(msg.value >= price, \"Not enough funds\");\n\n        /// Get previous token owner\n        address from = ownerOf(tokenID);\n        assert(from != address(0));\n        require(from != msg.sender, \"Already token owner!\");\n\n        /// Transfer token\n        this.safeTransferFrom{value: msg.value}(from, msg.sender, tokenID, \"\");\n\n        /// Reset token price (to be eventualy defined by new owner)\n        delete tokenPrice[tokenID];\n    }\n\n    function mint(string memory tokenURI) external override(IOpenAutoMarket) returns (uint256 tokenID) {\n        tokenID = mint(msg.sender, tokenURI, 0, address(0), 0);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        uint256 defaultPrice_,\n        address receiver_,\n        uint96 fee_,\n        bool[] memory options\n    ) public override(IOpenAutoMarket) {\n        OpenNFTs._initialize(name_, symbol_, owner_);\n        open = options[0];\n\n        OpenMarketable._setDefaultPrice(defaultPrice_);\n        OpenMarketable._setDefaultRoyalty(receiver_, fee_);\n    }\n\n    function mint(\n        address minter_,\n        string memory tokenURI_,\n        uint256 tokenPrice_,\n        address receiver_,\n        uint96 fee_\n    ) public payable override(IOpenAutoMarket) onlyMinter onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = OpenNFTs.mint(minter_, tokenURI_);\n\n        OpenMarketable._setTokenPrice(tokenID, tokenPrice_);\n        OpenMarketable._setTokenRoyalty(tokenID, receiver_, fee_);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public virtual override(OpenCloneable) {\n        (uint256 defaultPrice_, address receiver_, uint96 fee_, bool[] memory options_) = abi.decode(\n            params_,\n            (uint256, address, uint96, bool[])\n        );\n        initialize(name_, symbol_, owner_, defaultPrice_, receiver_, fee_, options_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenNFTs) returns (bool) {\n        return interfaceId == type(IOpenAutoMarket).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/tests/OpenFactoryV3/OpenFactoryV3CloneTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenFactoryV3.sol\";\nimport \"../../next/OpenNFTsV4.sol\";\nimport \"../../next/OpenAutoMarket.sol\";\n\nabstract contract OpenFactoryV3CloneTest is Test {\n    address private _factory;\n    address private _template;\n    address private _clone;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenFactoryV3Clone() public {\n        _factory = constructorTest(_owner);\n    }\n\n    function testOpenFactoryV3CloneOpenNFTsV4() public {\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        _clone = OpenFactoryV3(_factory).clone(\"NFT test\", \"NFT\", \"OpenNFTsV4\", abi.encode(options));\n\n        assertTrue(OpenNFTsV4(_clone).initialized());\n        assertEq(OpenNFTsV4(_clone).name(), \"NFT test\");\n    }\n\n    function testOpenFactoryV3CloneOpenAutoMarket() public {\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        _clone = OpenFactoryV3(_factory).clone(\n            \"NFT test\",\n            \"NFT\",\n            \"OpenAutoMarket\",\n            abi.encode(42000000000, _tester, 420, options)\n        );\n        assertEq(OpenAutoMarket(payable(_clone)).name(), \"NFT test\");\n        assertEq(OpenAutoMarket(payable(_clone)).symbol(), \"NFT\");\n\n        assertEq(OpenAutoMarket(payable(_clone)).defaultPrice(), 42000000000);\n\n        (address receiver, uint96 fee) = OpenAutoMarket(payable(_clone)).getDefaultRoyalty();\n        assertEq(receiver, _tester);\n        assertEq(fee, 420);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//     OpenERC165\n//          |\n//     OpenERC721\n//          |\n//  OpenERC721Metadata —— IERC721Metadata\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\n\nabstract contract OpenERC721Metadata is IERC721Metadata, OpenERC721 {\n    bool private _openERC721MetadataInitialized;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => string) private _tokenURIs;\n\n    function name() external view virtual override (IERC721Metadata) returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view virtual override (IERC721Metadata) returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenID)\n        external\n        view\n        virtual\n        override (IERC721Metadata)\n        existsToken(tokenID)\n        returns (string memory)\n    {\n        return _tokenURIs[tokenID];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC721)\n        returns (bool)\n    {\n        return interfaceId == 0x5b5e139f || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory name_, string memory symbol_) internal {\n        require(_openERC721MetadataInitialized == false, \"Already initialized\");\n        _openERC721MetadataInitialized = true;\n\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function _mint(address to, string memory newTokenURI, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _tokenURIs[tokenID] = newTokenURI;\n\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override (OpenERC721) {\n        delete _tokenURIs[tokenID];\n\n        super._burn(tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/extensions/ERC721Enumerable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/...\n// ...contracts/token/ERC721/extensions/ERC721Enumerable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721Enumerable —— IERC721Enumerable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenERC721Enumerable is IERC721Enumerable, OpenERC721 {\n    // Array of all tokens ID\n    uint256[] private _allTokens;\n\n    // Mapping from owner to list of token IDs owned\n    // mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to owned index\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Mapping from token ID to all index\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override (IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < OpenERC721.balanceOf(owner), \"Invalid index!\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() external view override (IERC721Enumerable) returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index)\n        external\n        view\n        override (IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < _allTokens.length, \"Invalid index!\");\n        return _allTokens[index];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC721)\n        returns (bool)\n    {\n        return interfaceId == 0x780e9d63 || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, string memory tokenURI, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _addOwnedToken(to, tokenID);\n\n        _allTokensIndex[tokenID] = _allTokens.length;\n        _allTokens.push(tokenID);\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override (OpenERC721) {\n        address from = ownerOf(tokenID);\n\n        _removeOwnedToken(from, tokenID);\n\n        uint256 allBurnIndex = _allTokensIndex[tokenID];\n        uint256 allLastIndex = _allTokens.length - 1;\n        uint256 allLastTokenId = _allTokens[allLastIndex];\n\n        _allTokensIndex[allLastTokenId] = allBurnIndex;\n        delete _allTokensIndex[tokenID];\n\n        _allTokens[allBurnIndex] = allLastTokenId;\n        _allTokens.pop();\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _removeOwnedToken(from, tokenID);\n        _addOwnedToken(to, tokenID);\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _addOwnedToken(address owner, uint256 tokenID) private {\n        _ownedTokensIndex[tokenID] = _ownedTokens[owner].length;\n        _ownedTokens[owner].push(tokenID);\n    }\n\n    function _removeOwnedToken(address owner, uint256 tokenID) private {\n        uint256 burnIndex = _ownedTokensIndex[tokenID];\n        uint256 lastIndex = OpenERC721.balanceOf(owner) - 1;\n\n        if (burnIndex != lastIndex) {\n            uint256 lastTokenId = _ownedTokens[owner][lastIndex];\n            _ownedTokens[owner][burnIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = burnIndex;\n        }\n\n        delete _ownedTokensIndex[tokenID];\n        _ownedTokens[owner].pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ——————————————————————————————————————————————————————————————————————\n//       |                                       |             |              |\n//   OpenERC721                            OpenERC2981    OpenERC173    OpenCloneable\n//     (NFT)                              (RoyaltyInfo)    (ownable)          |\n//       |                                        |            |              |\n//       ——————————————————————————————————————   |     ————————              |\n//       |                        |           |   |     |      |              |\n//  OpenERC721Metadata  OpenERC721Enumerable  |   ———————      |              |\n//       |                        |           |   |            |              |\n//       |                        |      OpenMarketable   OpenPauseable       |\n//       |                        |             |              |              |\n//       ——————————————————————————————————————————————————————————————————————\n//       |\n//    OpenNFTs —— IOpenNFTs\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\n\n/// @title OpenNFTs smartcontract\nabstract contract OpenNFTs is\n    IOpenNFTs,\n    OpenERC721Metadata,\n    OpenERC721Enumerable,\n    OpenMarketable,\n    OpenPauseable,\n    OpenCloneable\n{\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice onlyMinter, by default only owner can mint, can be overriden\n    modifier onlyMinter() virtual {\n        require(msg.sender == owner(), \"Not minter\");\n        _;\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID)\n        external\n        override (IOpenNFTs)\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _burn(tokenID);\n    }\n\n    /// @notice withdraw eth\n    function withdraw() external override (IOpenNFTs) onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /// @notice withdraw token\n    function withdraw(address token) external override (IOpenNFTs) onlyOwner {\n        require(\n            IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))),\n            \"Withdraw failed\"\n        );\n    }\n\n    function mint(address minter, string memory tokenURI)\n        public\n        override (IOpenNFTs)\n        onlyMinter\n        returns (uint256 tokenID)\n    {\n        tokenID = tokenIdNext++;\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (\n            OpenMarketable, OpenERC721Metadata, OpenERC721Enumerable, OpenCloneable, OpenPauseable\n        )\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTs).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice _initialize\n    /// @param name_ name of the NFT Collection\n    /// @param symbol_ symbol of the NFT Collection\n    /// @param owner_ owner of the NFT Collection\n    // solhint-disable-next-line comprehensive-interface\n    function _initialize(string memory name_, string memory symbol_, address owner_) internal {\n        tokenIdNext = 1;\n        OpenCloneable._initialize(\"OpenNFTs\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n    }\n\n    /// @notice _mint\n    /// @param minter minter address\n    /// @param tokenURI token metdata URI\n    /// @param tokenID token ID\n    function _mint(address minter, string memory tokenURI, uint256 tokenID)\n        internal\n        override (OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable)\n    {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID)\n        internal\n        override (OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable)\n    {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        override (OpenERC721, OpenMarketable, OpenERC721Enumerable)\n    {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//        |\n//        ————————————————————————————\n//        |            |             |\n//   OpenERC721    OpenERC173   OpenERC2981\n//      (NFT)      (Ownable)   (RoyaltyInfo)\n//        |            |             |\n//        ————————————————————————————\n//        |\n//  OpenMarketable —— IOpenMarketable - OpenGuard\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC2981.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenGuard.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenMarketable is\n    IOpenMarketable,\n    OpenERC721,\n    OpenERC173,\n    OpenERC2981,\n    OpenGuard\n{\n    mapping(uint256 => uint256) public tokenPrice;\n    uint256 public defaultPrice;\n\n    receive() external payable override (IOpenMarketable) {}\n\n    /// @notice SET default mint price\n    /// @param price : default price in wei\n    function setDefaultPrice(uint256 price) public override (IOpenMarketable) onlyOwner {\n        _setDefaultPrice(price);\n    }\n\n    /// @notice SET default royalty info\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10000\n    function setDefaultRoyalty(address receiver, uint96 fee)\n        public\n        override (IOpenMarketable)\n        onlyOwner\n    {\n        _setDefaultRoyalty(receiver, fee);\n    }\n\n    /// @notice SET token price\n    /// @param tokenID : token ID\n    /// @param price : token price in wei\n    function setTokenPrice(uint256 tokenID, uint256 price)\n        public\n        override (IOpenMarketable)\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _setTokenPrice(tokenID, price);\n    }\n\n    /// @notice SET token royalty info\n    /// @param tokenID : token ID\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10_000\n    function setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee)\n        public\n        override (IOpenMarketable)\n        existsToken(tokenID)\n        onlyOwner\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    /// @notice SET token royalty receiver\n    /// @param tokenID : token ID\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    function setTokenRoyaltyReceiver(uint256 tokenID, address receiver)\n        public\n        override (IOpenMarketable)\n        existsToken(tokenID)\n        onlyOwner\n    {\n        _tokenRoyaltyInfo[tokenID].receiver = receiver;\n    }\n\n    /// @notice GET default royalty info\n    /// @return receiver : address of the royalty receiver, or address(0) to reset\n    /// @return fee : fee Numerator, less than 10_000\n    function getDefaultRoyalty()\n        public\n        view\n        override (IOpenMarketable)\n        returns (address receiver, uint96 fee)\n    {\n        receiver = _defaultRoyaltyInfo.receiver;\n        fee = _defaultRoyaltyInfo.fee;\n    }\n\n    /// @notice GET token royalty info\n    /// @param tokenID : token ID\n    /// @return receiver : address of the royalty receiver, or address(0) to reset\n    /// @return fee : fee Numerator, less than 10_000\n    function getTokenRoyalty(uint256 tokenID)\n        public\n        view\n        override (IOpenMarketable)\n        returns (address receiver, uint96 fee)\n    {\n        receiver = _tokenRoyaltyInfo[tokenID].receiver;\n        fee = _tokenRoyaltyInfo[tokenID].fee;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC721, OpenERC173, OpenERC2981)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenMarketable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, string memory tokenURI, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _setTokenRoyalty(tokenID, _defaultRoyaltyInfo.receiver, _defaultRoyaltyInfo.fee);\n\n        _pay(tokenID, defaultPrice, to, owner());\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override (OpenERC721) {\n        delete _tokenRoyaltyInfo[tokenID];\n        delete tokenPrice[tokenID];\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        /// Transfer: pay token price (including royalties) to previous token owner (and royalty receiver)\n        _pay(tokenID, tokenPrice[tokenID], to, ownerOf(tokenID));\n\n        delete tokenPrice[tokenID];\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _setDefaultRoyalty(address receiver, uint96 fee) internal lessThanMaxFee(fee) {\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, fee);\n\n        emit SetDefaultRoyalty(receiver, fee);\n    }\n\n    function _setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee)\n        internal\n        lessThanMaxFee(fee)\n    {\n        _tokenRoyaltyInfo[tokenID] = RoyaltyInfo(receiver, fee);\n\n        emit SetTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function _setTokenPrice(uint256 tokenID, uint256 price) internal notTooExpensive(price) {\n        tokenPrice[tokenID] = price;\n\n        emit SetTokenPrice(tokenID, price);\n    }\n\n    function _setDefaultPrice(uint256 price) internal notTooExpensive(price) {\n        defaultPrice = price;\n\n        emit SetDefaultPrice(price);\n    }\n\n    function _pay(uint256 tokenID, uint256 price, address buyer, address seller)\n        private\n        reEntryGuard\n    {\n        require(msg.value >= price, \"Not enough funds\");\n        if (msg.value == 0) {\n            return;\n        }\n\n        require(buyer != address(0), \"Invalid buyer\");\n        require(seller != address(0), \"Invalid seller\");\n\n        address receiver;\n        uint256 royalties;\n        uint256 paid;\n        uint256 unspent = msg.value;\n\n        if (price > 0 && buyer != seller) {\n            (receiver, royalties) = royaltyInfo(tokenID, price);\n            if (receiver == address(0)) {\n                royalties = 0;\n            }\n\n            require(royalties <= price, \"Invalid royalties\");\n\n            /// Transfer amount to be paid to seller, the previous owner\n            paid = price - royalties;\n            if (paid > 0) {\n                unspent = unspent - paid;\n                payable(seller).transfer(paid);\n            }\n\n            /// Transfer royalties to receiver\n            if (royalties > 0) {\n                unspent = unspent - royalties;\n                payable(receiver).transfer(royalties);\n            }\n        }\n\n        assert(paid + royalties + unspent == msg.value);\n\n        /// Transfer back unspent funds to buyer\n        if (unspent > 0) {\n            payable(buyer).transfer(unspent);\n        }\n\n        emit Pay(tokenID, price, seller, paid, receiver, royalties, buyer, unspent);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-2981: NFT Royalty Standard\n// https://eips.ethereum.org/EIPS/eip-2981\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/common/ERC2981.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC2981 —— IERC2981\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nabstract contract OpenERC2981 is IERC2981, OpenERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 fee;\n    }\n\n    RoyaltyInfo internal _defaultRoyaltyInfo;\n    mapping(uint256 => RoyaltyInfo) internal _tokenRoyaltyInfo;\n\n    uint96 private constant _MAX_FEE = 10_000;\n\n    modifier notTooExpensive(uint256 price) {\n        /// otherwise may overflow\n        require(price < 2 ** 128, \"Too expensive\");\n        _;\n    }\n\n    modifier lessThanMaxFee(uint256 fee) {\n        require(fee <= _MAX_FEE, \"Royalty fee exceed price\");\n        _;\n    }\n\n    function royaltyInfo(uint256 tokenID, uint256 price)\n        public\n        view\n        override (IERC2981)\n        notTooExpensive(price)\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenID];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        royaltyAmount = (price * royalty.fee) / _MAX_FEE;\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenGuard\n//\npragma solidity 0.8.9;\n\nabstract contract OpenGuard {\n    bool private _locked;\n\n    modifier reEntryGuard() {\n        require(!_locked, \"No re-entry!\");\n\n        _locked = true;\n\n        _;\n\n        _locked = false;\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenV4AutoMarketTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenAutoMarket.sol\";\n\nimport \"./OpenAutoMarketInitializeTest.t.sol\";\nimport \"./OpenAutoMarketSupportsTest.t.sol\";\nimport \"./OpenAutoMarketBuyTest.t.sol\";\nimport \"./OpenAutoMarketMintTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC2981Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsSetupTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenMarketableTest.t.sol\";\n\ncontract OpenAutoMarketTest is\n    ERC721TransferableTest,\n    ERC173Test,\n    ERC2981Test,\n    OpenAutoMarketInitializeTest,\n    OpenAutoMarketSupportsTest,\n    OpenAutoMarketBuyTest,\n    OpenAutoMarketMintTest,\n    OpenNFTsTest,\n    OpenNFTsBurnTest,\n    OpenNFTsSetupTest,\n    OpenPauseableTest,\n    OpenMarketableTest\n{\n    function constructorTest(address owner)\n        public\n        override(\n            ERC721TransferableTest,\n            ERC173Test,\n            ERC2981Test,\n            OpenNFTsTest,\n            OpenAutoMarketSupportsTest,\n            OpenAutoMarketBuyTest,\n            OpenAutoMarketMintTest,\n            OpenNFTsBurnTest,\n            OpenNFTsSetupTest,\n            OpenPauseableTest,\n            OpenMarketableTest\n        )\n        returns (address)\n    {\n        return constructorTest(owner, true);\n    }\n\n    function constructorTest(address owner, bool init) public override(OpenAutoMarketInitializeTest) returns (address) {\n        changePrank(owner);\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        OpenAutoMarket collection = new OpenAutoMarket();\n        if (init) {\n            collection.initialize(\"OpenERC721Test\", \"OPTEST\", owner, 0, address(0), 0, options);\n        }\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(\n            OpenAutoMarketBuyTest,\n            OpenNFTsTest,\n            OpenNFTsBurnTest,\n            OpenNFTsSetupTest,\n            ERC2981Test,\n            OpenPauseableTest,\n            OpenMarketableTest,\n            ERC721TransferableTest\n        )\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenAutoMarket(payable(collection)).mint(_TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(OpenNFTsTest, OpenNFTsBurnTest) {\n        changePrank(OpenAutoMarket(payable(collection)).ownerOf(tokenID));\n        OpenAutoMarket(payable(collection)).burn(tokenID);\n    }\n\n    function setPriceTest(\n        address collection,\n        uint256 tokenID,\n        uint256 price\n    ) public {\n        // changePrank(OpenAutoMarket(payable(collection)).ownerOf(tokenID));\n        OpenAutoMarket(payable(collection)).setTokenPrice(tokenID, price);\n    }\n\n    function setRoyaltyTest(\n        address collection,\n        address receiver,\n        uint96 fee\n    ) public override(ERC2981Test, OpenMarketableTest) returns (uint256 tokenID) {\n        changePrank(OpenAutoMarket(payable(collection)).owner());\n        (tokenID, ) = (OpenAutoMarket(payable(collection)).mint(_TOKEN_URI), _TOKEN_URI);\n        OpenAutoMarket(payable(collection)).setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpERC2981();\n        setUpPausable();\n        setUpMarketable();\n        setUpOpenNFTs(\"OpenERC721Test\", \"OPTEST\");\n        setUpERC721Transferable();\n        setUpOpenNFTsBurn();\n        setUpOpenNFTsBuy();\n        setUpOpenNFTsMint();\n        setUpOpenNFTsSetup();\n        setUpOpenAutoMarketInitialize();\n        setUpOpenAutoMarketSupports();\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketInitializeTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\n\nabstract contract OpenAutoMarketInitializeTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_, bool init_) public virtual returns (address);\n\n    function setUpOpenAutoMarketInitialize() public {\n        _collection = constructorTest(_owner, false);\n\n        _options[0] = true;\n    }\n\n    function testInitializeName() public {\n        IOpenAutoMarket(_collection).initialize(\"OpenAutoMarketTest\", \"TEST\", _owner, 0, address(0), 0, _options);\n        // assertEq(IERC721Metadata(_collection).name(), \"OpenAutoMarketTest\");\n    }\n\n    function testInitializeSymbol() public {\n        IOpenAutoMarket(_collection).initialize(\"OpenAutoMarketTest\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IERC721Metadata(_collection).symbol(), \"TEST\");\n    }\n\n    function testInitializeOwner() public {\n        IOpenAutoMarket(_collection).initialize(\"OpenAutoMarketTest\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testInitializeOpen() public {\n        IOpenAutoMarket(_collection).initialize(\"OpenAutoMarketTest\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IOpenAutoMarket(_collection).open(), true);\n    }\n\n    function testInitializeNotOpen() public {\n        _options[0] = false;\n        IOpenAutoMarket(_collection).initialize(\"OpenAutoMarketTest\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IOpenAutoMarket(_collection).open(), false);\n    }\n\n    function testFailInitializeTwice() public {\n        IOpenAutoMarket(_collection).initialize(\"OpenAutoMarketTest\", \"TEST\", _owner, 0, address(0), 0, _options);\n        IOpenAutoMarket(_collection).initialize(\"OpenNFTsOldTestTwice\", \"OPTEST2\", _tester, 0, address(0), 0, _options);\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketSupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenAutoMarketSupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenAutoMarketSupports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, address(this));\n    }\n\n    function testOpenAutoMarketCheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, true];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenAutoMarketCheckSupportedInterfaces() public {\n        bytes4[9] memory ids = [\n            type(IOpenCloneable).interfaceId,\n            type(IOpenMarketable).interfaceId,\n            type(IOpenAutoMarket).interfaceId,\n            type(IOpenNFTs).interfaceId,\n            type(IOpenAutoMarket).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenChecker).interfaceId,\n            type(IERC721TokenReceiver).interfaceId,\n            0xffffffff\n        ];\n        bool[9] memory expected = [true, true, true, true, true, true, false, false, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](9);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            console.log(\"testOpenAutoMarketCheckErcInterfaces ~ i\", i);\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketBuyTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\n\nabstract contract OpenAutoMarketBuyTest is Test {\n    address payable private _collection;\n    address private _owner = makeAddr(\"owner\");\n    address private _buyer = makeAddr(\"buyer\");\n    address private _tester = makeAddr(\"tester\");\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpOpenNFTsBuy() public {\n        _collection = payable(constructorTest(_owner));\n\n        (_tokenID0, ) = mintTest(_collection, _owner);\n    }\n\n    function testBuyOk() public {\n        changePrank(_owner);\n        IERC721(_collection).setApprovalForAll(_collection, true);\n\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n        uint256 balMinter = _owner.balance;\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _owner);\n        IOpenAutoMarket(_collection).buy{value: 1.5 ether}(_tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n\n        assertEq(_buyer.balance, 9 ether);\n        assertEq(_collection.balance, 0 ether);\n        assertEq(_tester.balance, 0.01 ether);\n        assertEq(_owner.balance, balMinter + 0.99 ether);\n    }\n\n    function testFailBuyTwice() public {\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        IOpenAutoMarket(_collection).buy{value: 1 ether}(_tokenID0);\n        IOpenAutoMarket(_collection).buy{value: 1 ether}(_tokenID0);\n    }\n\n    function testFailBuyNotEnoughFunds() public {\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        IOpenAutoMarket(_collection).buy{value: 0.5 ether}(_tokenID0);\n    }\n\n    function testFailBuyNotToSell() public {\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 0);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _owner);\n        IOpenAutoMarket(_collection).buy{value: 1 ether}(_tokenID0);\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketMintTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\n\nabstract contract OpenAutoMarketMintTest is Test {\n    string private constant _TOKEN_URI = \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n\n    address payable private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsMint() public {\n        _collection = payable(constructorTest(_owner));\n        changePrank(_minter);\n    }\n\n    function testOpenAutoMarketMint1() public {\n        IOpenAutoMarket(_collection).mint(_TOKEN_URI);\n    }\n\n    function testOpenAutoMarketMint5() public {\n        IOpenAutoMarket(_collection).mint(_minter, _TOKEN_URI, 10000, address(_minter), 100);\n    }\n\n    function testOpenAutoMarketMint2() public {\n        IOpenNFTs(_collection).mint(_minter, _TOKEN_URI);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721TokenReceiver.sol\";\n\nabstract contract ERC721TransferableTest is Test, IERC721Events {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpERC721Transferable() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721SafeTransferFrom() public {\n        changePrank(_minter);\n\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721SafeTransferFromWithData() public {\n        changePrank(_minter);\n\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721SafeTransferFromEmit() public {\n        changePrank(_minter);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(_minter, _tester, _tokenID0);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testERC721SafeTransferFromWithDataEmit() public {\n        changePrank(_minter);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(_minter, _tester, _tokenID0);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n    }\n\n    function testERC721SafeTransferFromEOAFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, tokenID);\n        IERC721(_collection).safeTransferFrom(from, to, tokenID);\n        assertEq(IERC721(_collection).ownerOf(tokenID), to);\n    }\n\n    function testERC721TransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n\n        IERC721(_collection).transferFrom(_minter, address(_collection), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(_collection));\n    }\n\n    function testERC721TransferFrom() public {\n        changePrank(_minter);\n\n        IERC721(_collection).transferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721TransferFromEOAFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, tokenID);\n        IERC721(_collection).transferFrom(from, to, tokenID);\n        assertEq(IERC721(_collection).ownerOf(tokenID), to);\n    }\n\n    function testERC721transferFromToContract() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, address(this), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(this));\n    }\n\n    function testFailERC721SafeTransferFromToNotReceiverContract() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(this), _tokenID0);\n    }\n\n    function testERC721SafeTransferFromToReceiverContract() public {\n        OpenERC721TokenReceiver receiverContract = new OpenERC721TokenReceiver();\n\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(receiverContract), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(receiverContract));\n    }\n\n    function testERC721Approve() public {\n        changePrank(_minter);\n        vm.expectEmit(true, true, true, false);\n        emit Approval(_minter, _tester, _tokenID0);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n    }\n\n    function testERC721SetApprovalForAll() public {\n        changePrank(_minter);\n        vm.expectEmit(true, true, true, false);\n        emit ApprovalForAll(_minter, _tester, true);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n    }\n\n    function testFailERC721TransferFromToZeroAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(0), _tokenID0);\n    }\n\n    function testFailERC721TransferFromFromZeroAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(address(0), _tester, _tokenID0);\n    }\n\n    function testERC721TransferFromToSameAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC2981Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract ERC2981Test is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address contract_);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setRoyaltyTest(address collection_, address receiver_, uint96 fee_)\n        public\n        virtual\n        returns (uint256 tokenID_);\n\n    function setUpERC2981() public {\n        _collection = constructorTest(_owner);\n\n        _tokenID0 = setRoyaltyTest(_collection, _minter, 420);\n    }\n\n    function testERC2981RoyaltyInfo(uint256 price) public {\n        vm.assume(price < 2 ** 128);\n        IERC2981(_collection).royaltyInfo(_tokenID0, price);\n    }\n\n    function testFailERC2981RoyaltyInfoTooExpensive(uint256 price) public {\n        vm.assume(price >= 2 ** 128);\n        IERC2981(_collection).royaltyInfo(_tokenID0, price);\n    }\n\n    function testERC2981SupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC2981).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenNFTsSetupTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenNFTsSetupTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    string private _tokenURI0;\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpOpenNFTsSetup() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, _tokenURI0) = mintTest(_collection, _minter);\n    }\n\n    function testContract() public {\n        assertEq(IERC721Metadata(_collection).name(), \"OpenERC721Test\");\n        assertEq(IERC721Metadata(_collection).symbol(), \"OPTEST\");\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testCount() public {\n        assertEq(IERC721(_collection).balanceOf(_minter), 1);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n    }\n\n    function testToken() public {\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n        assertEq(IERC721Metadata(_collection).tokenURI(_tokenID0), _tokenURI0);\n    }\n\n    function testPrice() public {\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(1), 0);\n    }\n\n    function testRoyalties() public {\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(1, 1);\n        assertEq(receiver, address(0));\n        assertEq(royalties, 0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenNFTsBurnTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    uint256 randNonce;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpOpenNFTsBurn() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n    }\n\n    function testBurn() public {\n        burnTest(_collection, _tokenID0);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 0);\n    }\n\n    function testBurnWithEnumerable() public {}\n\n    function testBurnWithMetadata() public {}\n\n    function testFailBurnTokenByIndex() public {\n        burnTest(_collection, _tokenID0);\n        IERC721Enumerable(_collection).tokenByIndex(0);\n    }\n\n    function testFailBurnTokenOfOwnerByIndex() public {\n        burnTest(_collection, _tokenID0);\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0);\n    }\n\n    function testBurnSecondOne() public {\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 2);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(1), tokenID);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0), tokenID);\n\n        burnTest(_collection, tokenID);\n\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n    }\n\n    function testFailBurnSecondOneTokenByIndex() public {\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        burnTest(_collection, tokenID);\n        IERC721Enumerable(_collection).tokenByIndex(1);\n    }\n\n    function testFailBurnSecondOneTokennOfOwnerByIndex() public {\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        burnTest(_collection, tokenID);\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0);\n    }\n\n    function testBurnEnumerable() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        burnTest(_collection, _tokenID0);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 0);\n    }\n\n    function testBurnERC721EnumerableShuffleUp(uint160 rnd) public {\n        burnTest(_collection, _tokenID0);\n\n        uint160 first = 2 ** 100;\n        uint160 total = 20;\n        uint256 totalSupply;\n\n        for (uint160 index = 1; index <= total; index++) {\n            address address1 = address(first + (random(rnd) % index));\n            address address2 = address(first + (random(rnd) % index));\n            uint256 rand3 = (random(rnd) % index);\n\n            mintTest(_collection, address1);\n            mintTest(_collection, address2);\n\n            uint256 randomTokenID1 = IERC721Enumerable(_collection).tokenByIndex(rand3);\n            address owner1 = IERC721(_collection).ownerOf(randomTokenID1);\n            changePrank(owner1);\n            IERC721(_collection).transferFrom(owner1, address2, randomTokenID1);\n\n            uint256 randomTokenID2 = IERC721Enumerable(_collection).tokenByIndex(uint256(rand3));\n            burnTest(_collection, randomTokenID2);\n\n            assertEq(IERC721Enumerable(_collection).totalSupply(), index);\n        }\n        assertEq(IERC721Enumerable(_collection).totalSupply(), total);\n\n        for (uint160 index = 1; index <= total; index++) {\n            totalSupply += IERC721(_collection).balanceOf(address(first + index - 1));\n        }\n        assertEq(totalSupply, total);\n    }\n\n    function random(uint160 rnd) public returns (uint160) {\n        randNonce++;\n        return uint160(uint256(keccak256(abi.encodePacked(msg.sender, randNonce, rnd))));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenMarketableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenMarketableTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x2);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    uint256 private _notTokenID = 42;\n\n    uint96 private _maxFee = 10_000;\n\n    // uint256 private maxPrice = uint256(((2**256) - 1)) / _maxFee;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setRoyaltyTest(address collection_, address receiver_, uint96 fee_)\n        public\n        virtual\n        returns (uint256 tokenID_);\n\n    function setUpMarketable() public {\n        _collection = constructorTest(_owner);\n\n        _tokenID0 = setRoyaltyTest(_collection, _owner, 420);\n    }\n\n    function testSetDefaultRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price < 2 ** 128);\n        vm.assume(fee < 10_000);\n\n        (uint256 tokenID,) = mintTest(_collection, _owner);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, price);\n        assertEq(receiver, _minter);\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testSetTokenRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price != 0);\n        vm.assume(price < 2 ** 128);\n        vm.assume(fee < 10_000);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _owner);\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(_tokenID0, price);\n        assertEq(receiver, _tester);\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testFailSetTokenRoyaltyNoToken() public {\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_notTokenID, _tester, 100);\n    }\n\n    function testSetTokenPrice(uint256 price) public {\n        vm.assume(price < 2 ** 128);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, price);\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(_tokenID0), price);\n    }\n\n    function testSetTokenPriceFromDefault(uint256 price) public {\n        vm.assume(price < 2 ** 128);\n\n        changePrank(_owner);\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(_tokenID0), 0);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(_tokenID0), 1 ether);\n    }\n\n    function testFailSetDefaultPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2 ** 128);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultPrice(price);\n    }\n\n    function testFailSetTokenPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2 ** 128);\n\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, price);\n    }\n\n    function testFailSetTokenPriceNoToken() public {\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_notTokenID, 1 ether);\n    }\n\n    function testRoyaltyInfoCalculation(uint256 price, uint96 fee) public {\n        vm.assume(price < 2 ** 128);\n        vm.assume(fee < _maxFee);\n\n        (uint256 tokenID,) = mintTest(_collection, _owner);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, price);\n        assertEq(receiver, _minter);\n\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testTokenOwner() public {\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n    }\n\n    function testFailTokenOwner() public {\n        /// must be collection owner\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n    }\n\n    function testFailSetTokenRoyaltyNotOwner() public {\n        changePrank(_tester);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n    }\n\n    function testFailSetTokenPriceNotOwner() public {\n        changePrank(_tester);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IOpenMarketable).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721TokenReceiver —— IERC721TokenReceiver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\ncontract OpenERC721TokenReceiver is IERC721TokenReceiver, OpenERC721 {\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        virtual\n        override (IERC721TokenReceiver)\n        returns (bytes4)\n    {\n        return OpenERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenNFTsV4.sol\";\n\nimport \"./OpenNFTsV4InitializeTest.t.sol\";\nimport \"./OpenNFTsV4SupportsTest.t.sol\";\nimport \"./OpenNFTsV4MintTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\n\ncontract OpenNFTsV4Test is\n    ERC721FullTest,\n    ERC173Test,\n    OpenNFTsV4InitializeTest,\n    OpenNFTsV4MintTest,\n    OpenNFTsV4SupportsTest\n{\n    function constructorTest(address owner)\n        public\n        override(ERC721FullTest, ERC173Test, OpenNFTsV4SupportsTest, OpenNFTsV4MintTest)\n        returns (address)\n    {\n        return constructorTest(owner, true);\n    }\n\n    function constructorTest(address owner, bool init) public override(OpenNFTsV4InitializeTest) returns (address) {\n        changePrank(owner);\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        OpenNFTsV4 collection = new OpenNFTsV4();\n        if (init) {\n            collection.initialize(\"OpenNFTsV4Test\", \"OPTEST\", owner, options);\n        }\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(ERC721FullTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV4(collection).mint(_TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(ERC721FullTest) {\n        console.log(\"burnTest ~ tokenID\", tokenID);\n        changePrank(OpenNFTsV4(collection).ownerOf(tokenID));\n        OpenNFTsV4(collection).burn(tokenID);\n    }\n\n    function setUp() public {\n        setUpERC721Full(\"OpenNFTsV4Test\", \"OPTEST\");\n        setUpERC173();\n        setUpOpenNFTsV4Initialize();\n        setUpOpenNFTsV4Mint();\n        setUpOpenNFTsV4Supports();\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4InitializeTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\n\nabstract contract OpenNFTsV4InitializeTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_, bool init_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Initialize() public {\n        _collection = constructorTest(_owner, false);\n\n        _options[0] = true;\n    }\n\n    function testInitializeName() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _options);\n        // assertEq(IERC721Metadata(_collection).name(), \"OpenNFTsV4InitializeTest\");\n    }\n\n    function testInitializeSymbol() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _options);\n        assertEq(IERC721Metadata(_collection).symbol(), \"TEST\");\n    }\n\n    function testInitializeOwner() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _options);\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testInitializeOpen() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _options);\n        assertEq(IOpenNFTsV4(_collection).open(), true);\n    }\n\n    function testInitializeNotOpen() public {\n        _options[0] = false;\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _options);\n        assertEq(IOpenNFTsV4(_collection).open(), false);\n    }\n\n    function testFailInitializeTwice() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _options);\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsOldTestTwice\", \"OPTEST2\", _tester, _options);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4SupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenNFTsV4SupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Supports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, address(this));\n    }\n\n    function testOpenNFTsV4CheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenNFTsV4CheckSupportedInterfaces() public {\n        bytes4[9] memory ids = [\n            type(IOpenCloneable).interfaceId,\n            type(IOpenMarketable).interfaceId,\n            type(IOpenAutoMarket).interfaceId,\n            type(IOpenNFTs).interfaceId,\n            type(IOpenNFTsV4).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenChecker).interfaceId,\n            type(IERC721TokenReceiver).interfaceId,\n            0xffffffff\n        ];\n        bool[9] memory expected = [true, false, false, false, true, false, false, false, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](9);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            console.log(\"testOpenNFTsV4CheckSupportedInterfaces\", i);\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4MintTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\n\nabstract contract OpenNFTsV4MintTest is Test {\n    string private constant _TOKEN_URI = \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Mint() public {\n        _collection = constructorTest(_owner);\n        changePrank(_minter);\n    }\n\n    function testOpenNFTsV4Mint1() public {\n        IOpenNFTsV4(_collection).mint(_TOKEN_URI);\n    }\n\n    function testOpenNFTsV4Mint5() public {\n        IOpenNFTsV4(_collection).mint(_minter, _TOKEN_URI);\n    }\n\n    function testOpenNFTsV4Mint2() public {\n        IOpenNFTs(_collection).mint(_minter, _TOKEN_URI);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}