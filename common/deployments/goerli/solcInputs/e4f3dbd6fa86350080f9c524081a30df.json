{
  "language": "Solidity",
  "sources": {
    "contracts/CloneFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/ICloneFactoryV2.sol\";\n\n/// @title Abstract Clone Factory V2\n/// @notice Generic Clone Factory to clone Templates\n/// @dev CloneFactory is ICloneFactoryV2 and Ownable\nabstract contract CloneFactoryV2 is ICloneFactoryV2, Ownable {\n    /// @notice Implementations addresses\n    address[] public implementations;\n\n    /// @notice Named Templates\n    mapping(string => address) public templates;\n\n    /// @notice Add Implementations, public onlyOwner\n    /// @param  implementationsToAdd : new implementations addresses\n    function implementationsAdd(address[] calldata implementationsToAdd) external override(ICloneFactoryV2) onlyOwner {\n        for (uint256 i = 0; i < implementationsToAdd.length; i += 1) {\n            _implementationNew(implementationsToAdd[i]);\n        }\n    }\n\n    /// @notice Implementations count\n    /// @return count : number of implementations\n    function implementationsCount() external view override(ICloneFactoryV2) returns (uint256) {\n        return implementations.length;\n    }\n\n    /// @notice Set Template by Name\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template)\n        public\n        virtual\n        override(ICloneFactoryV2)\n        onlyOwner\n    {\n        templates[templateName] = template;\n\n        /// @notice emit event ImplementationNew\n        emit TemplateSet(templateName, template);\n    }\n\n    /// @notice New Implementation\n    /// @param  implementation : implementation address\n    function _implementationNew(address implementation) internal virtual {\n        implementations.push(implementation);\n\n        emit ImplementationNew(implementation, _msgSender(), implementations.length - 1);\n    }\n\n    /// @notice Clone Template\n    /// @param  templateName : template name\n    /// @return clone_ : clone address\n    function _clone(string memory templateName) internal returns (address clone_) {\n        /// @notice clone template and get clone address\n        clone_ = Clones.clone(_template(templateName));\n\n        /// @notice register clone as new implementation\n        _implementationNew(clone_);\n    }\n\n    /// @notice Get Template\n    /// @param  templateName : template name\n    /// @return  template : template address\n    function _template(string memory templateName) internal view virtual returns (address template) {\n        require(templates[templateName] != address(0), \"Bad Template\");\n\n        template = templates[templateName];\n    }\n}\n"
    },
    "contracts/interfaces/ICloneFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICloneFactoryV2 {\n    /// @notice New Implementation Event\n    /// @param implementation Address of the implementation\n    /// @param creator Address of the creator\n    /// @return index Index inside implementations array (starts at 0)\n    event ImplementationNew(address indexed implementation, address indexed creator, uint256 index);\n\n    /// @notice Set Template Event\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    event TemplateSet(string indexed templateName, address indexed template);\n\n    /// @notice Set Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template) external;\n\n    /// @notice Add Implementation\n    /// @param implementationToAdd Addresses of implementations to add\n    function implementationsAdd(address[] calldata implementationToAdd) external;\n\n    /// @notice Get Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templates(string calldata templateName) external view returns (address template);\n\n    /// @notice Count Implementations\n    /// @return count Number of implementations\n    function implementationsCount() external view returns (uint256 count);\n\n    /// @notice Get Implementation from Implementations array\n    /// @param index Index of implementation\n    /// @return implementation Address of implementation\n    function implementations(uint256 index) external view returns (address implementation);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/NFTsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IOpenNFTsV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./CloneFactoryV2.sol\";\nimport \"./interfaces/INFTsFactoryV2.sol\";\nimport \"./interfaces/IOpenNFTs.old.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\n/// @title NFTsFactory smartcontract\n/// @dev is CloneFactory\n/// @notice Templates are OPEN_NFTS contracts\n/// @notice Implementations are ERC721 contracts (including OPEN_NFTS clones)\n/// @notice Factory can clone OPEN_NFTs templates to implementations\n/// @notice Factory can also add ERC721 contracts to implementations\ncontract NFTsFactoryV2 is CloneFactoryV2, INFTsFactoryV2 {\n    using ERC165Checker for address;\n\n    uint8 internal constant _IERC721 = 0;\n    uint8 internal constant _IERC721_METADATA = 1;\n    uint8 internal constant _IERC721_ENUMERABLE = 2;\n    uint8 internal constant _IERC173 = 3;\n    uint8 internal constant _IOPEN_NFTS = 4;\n\n    bytes4 internal constant _IERC721_SIG = bytes4(0x80ac58cd);\n    bytes4 internal constant _IERC721_METADATA_SIG = bytes4(0x780e9d63);\n    bytes4 internal constant _IERC721_ENUMERABLE_SIG = (0x780e9d63);\n    bytes4 internal constant _IERC173_SIG = bytes4(0x7f5828d0);\n    bytes4 internal constant _IOPEN_NFTS_SIG = type(IOpenNFTs).interfaceId;\n\n    constructor(address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    /// @notice clone template\n    /// @param name name of Clone collection\n    /// @param symbol symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external override(INFTsFactoryV2) returns (address clone_) {\n        clone_ = _clone(templateName);\n        IOpenNFTs(clone_).initialize(name, symbol, _msgSender(), options);\n    }\n\n    /// @notice balancesOf address for each implementations\n    /// @param addr  address of account\n    /// @return nftData Array of nftData balances\n    function balancesOf(address addr) external view override(INFTsFactoryV2) returns (NftData[] memory nftData) {\n        nftData = new NftData[](implementations.length);\n        for (uint256 i = 0; i < implementations.length; i += 1) {\n            nftData[i] = _balanceOf(implementations[i], addr);\n        }\n    }\n\n    /// @notice Set Template, overrides generic CloneFactory\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template) public override(CloneFactoryV2) onlyOwner {\n        require(template.supportsInterface(_IOPEN_NFTS_SIG), \"Not valid OpenNFTs Template\");\n\n        super.templateSet(templateName, template);\n    }\n\n    /// @notice New Implementation internal, overrides generic CloneFactory\n    /// @param  implementation : implementation address\n    function _implementationNew(address implementation) internal override(CloneFactoryV2) {\n        require(implementation.supportsInterface(_IERC721_SIG), \"Not ERC721\");\n\n        super._implementationNew(implementation);\n    }\n\n    /// @notice _balanceOf\n    /// @param nft nft address of NFT collection\n    /// @param owner address of account\n    /// @return nftData nftData balances\n    function _balanceOf(address nft, address owner) internal view returns (NftData memory nftData) {\n        bytes4[] memory iface = new bytes4[](5);\n        iface[_IERC721] = _IERC721_SIG;\n        iface[_IERC721_METADATA] = _IERC721_METADATA_SIG;\n        iface[_IERC721_ENUMERABLE] = _IERC721_ENUMERABLE_SIG;\n        iface[_IERC173] = _IERC173_SIG;\n\n        bool[] memory supportInterface = nft.getSupportedInterfaces(iface);\n\n        if (supportInterface[_IERC721]) {\n            nftData.nft = nft;\n            nftData.balanceOf = IERC721(nft).balanceOf(owner);\n\n            if (supportInterface[_IERC721_METADATA]) {\n                nftData.name = IERC721Metadata(nft).name();\n                nftData.symbol = IERC721Metadata(nft).symbol();\n            }\n\n            if (supportInterface[_IERC721_ENUMERABLE]) {\n                nftData.totalSupply = IERC721Enumerable(nft).totalSupply();\n            }\n\n            if (supportInterface[_IERC173]) {\n                nftData.owner = IERC173(nft).owner();\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV2 {\n    function transferOwnership(address newOwner) external;\n\n    function initialize(string memory name, string memory symbol) external;\n\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID_);\n\n    function owner() external view returns (address owner_);\n}\n"
    },
    "contracts/interfaces/INFTsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface INFTsFactoryV2 {\n    struct NftData {\n        address nft;\n        uint256 balanceOf;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external returns (address);\n\n    function balancesOf(address owner) external view returns (NftData[] memory);\n}\n"
    },
    "contracts/interfaces/IOpenNFTs.old.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTs {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function transferOwnership(address newOwner) external;\n\n    function owner() external view returns (address currentOwner);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/dev/OpenPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"../interfaces/IOpenPass.sol\";\n\ncontract OpenPass is ERC721, IOpenPass, ERC721Burnable, Ownable {\n    using Counters for Counters.Counter;\n\n    string private _tokenURI;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() ERC721(\"NFT Pass\", \"PASS\") {}\n\n    function safeMint(address to) public override(IOpenPass) onlyOwner {\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n        _safeMint(to, tokenId);\n    }\n\n    function setTokenURI(string memory tokenURI_) public override(IOpenPass) onlyOwner {\n        _tokenURI = tokenURI_;\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId), \"Nonexistent token\");\n        return _tokenURI;\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721) {\n        super._burn(tokenId);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenPass {\n    function setTokenURI(string memory tokenURI) external;\n\n    function safeMint(address to) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/dev/OpenMulti.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\nimport \"../interfaces/IOpenMulti.sol\";\n\ncontract OpenMulti is IOpenMulti, ERC721, ERC721Enumerable, Ownable {\n    bytes32 private constant _BASE32_SYMBOLS = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    string private constant _BASE_URI = \"https://ipfs.io/ipfs/\";\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function claim(uint256 tokenId) public override(IOpenMulti) {\n        _safeMint(msg.sender, tokenId);\n    }\n\n    function exists(uint256 tokenId) public view override(IOpenMulti) returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId), \"ERC721: token doesn't exists\");\n\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(tokenId)));\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return\n            interfaceId == type(IOpenMulti).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenMulti.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenMulti {\n    function claim(uint256 tokenID) external;\n\n    function exists(uint256) external returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/libraries/Bafkrey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nlibrary Bafkrey {\n    bytes32 private constant _BASE32_SYMBOLS = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    /// Transfom uint256 to IPFS CID V1 base32 raw (starting with \"bafkrei\")\n    function uint256ToCid(uint256 id) internal pure returns (string memory) {\n        // IPFS CID V1 base32 raw \"bafrei...\" => 5 bits => uint32\n        // uint256 id  = 256 bits = 1 bit + 51 uint32 = 1 + 51 * 5 = 256\n        // 00 added right =>\n        // uint8 + uint256 + 00 = 258 bits = uint8 + 50 uint32 + (3 bits + 00) = uint8 + 51 uint32 = 3 + 51 * 5 = 258\n\n        bytes memory buffer = new bytes(52);\n        uint8 high3 = uint8(id >> 253);\n        buffer[0] = _BASE32_SYMBOLS[high3 & 0x1f];\n\n        id <<= 2;\n        for (uint256 i = 51; i > 0; i--) {\n            buffer[i] = _BASE32_SYMBOLS[id & 0x1f];\n            id >>= 5;\n        }\n\n        return string(abi.encodePacked(\"bafkrei\", buffer));\n    }\n}\n"
    },
    "contracts/next/OpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//  OpenERC165 (supports)\n//      |\n//      \n//      |                 |             |             |\n//  OpenERC721 (NFT)  OpenERC173  OpenChecker  OpenCloneable\n//      |             (ownable)         |             |\n//      |                 |             |             |\n//      |                 |             |             |\n//      |            OpenPauseable      |             |\n//      |                 |             |             |\n//      \n//      |\n//  OpenBound --- IOpenBound --- IERC721Enumerable --- IERC721Metadata\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\n\nimport \"../interfaces/IOpenBound.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenBound smartcontract\n/// limited to one nft per address\ncontract OpenBound is\n    IOpenBound,\n    IERC721Enumerable,\n    IERC721Metadata,\n    OpenCloneable,\n    OpenChecker,\n    OpenPauseable,\n    OpenERC721\n{\n    uint256 public maxSupply;\n\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) internal _tokenOfOwner;\n    mapping(address => uint256) internal _tokenIndexOfOwner;\n    mapping(uint256 => uint256) internal _cidOfToken;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    function mint(uint256 cid) external override(IOpenBound) onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, cid);\n    }\n\n    function claim(uint256 tokenID, uint256 cid) external override(IOpenBound) onlyWhenNotPaused {\n        require(tokenID == _tokenID(msg.sender, cid), \"Not owner\");\n        _mint(msg.sender, cid);\n    }\n\n    function burn(uint256 tokenID) external override(IOpenBound) {\n        address from = ownerOf(tokenID);\n        require(from == msg.sender, \"Not owner\");\n\n        _burn(tokenID);\n    }\n\n    function getMyTokenID(uint256 cid) external view override(IOpenBound) returns (uint256 myTokenID) {\n        myTokenID = _tokenID(msg.sender, cid);\n    }\n\n    function getCID(uint256 tokenID) external view override(IOpenBound) returns (uint256 cid) {\n        cid = _cidOfToken[tokenID];\n    }\n\n    /// IERC721Enumerable\n    function totalSupply() external view override(IERC721Enumerable) returns (uint256 tokensLength) {\n        tokensLength = _tokens.length;\n    }\n\n    function tokenOfOwnerByIndex(address tokenOwner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256 tokenID)\n    {\n        require(index == 0 && balanceOf(tokenOwner) == 1, \"Invalid index\");\n\n        tokenID = _tokenOfOwner[tokenOwner];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256 tokenID) {\n        require(index < _tokens.length, \"Invalid index\");\n\n        tokenID = _tokens[index];\n    }\n\n    /// IERC721Metadata\n    function tokenURI(uint256 tokenID)\n        external\n        view\n        override(IERC721Metadata)\n        existsToken(tokenID)\n        returns (string memory)\n    {\n        return _tokenURI(_cidOfToken[tokenID]);\n    }\n\n    function getTokenID(address addr, uint256 cid) external pure override(IOpenBound) returns (uint256 tokenID) {\n        tokenID = _tokenID(addr, cid);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public override(OpenCloneable) {\n        (bytes memory subparams_, , ) = abi.decode(params_, (bytes, address, uint96));\n        maxSupply = abi.decode(subparams_, (uint256));\n\n        OpenCloneable._initialize(\"OpenBound\", maxSupply);\n        OpenERC173._initialize(owner_);\n\n        name = name_;\n        symbol = symbol_;\n    }\n\n    /// IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(OpenPauseable, OpenCloneable, OpenERC721, OpenChecker)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenBound).interfaceId ||\n            interfaceId == type(IOpenNFTsOld).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, uint256 cid) internal returns (uint256 tokenID) {\n        require((maxSupply == 0) || _tokens.length < maxSupply, \"Max supply reached\");\n        require(balanceOf(to) == 0, \"Already minted or claimed\");\n\n        tokenID = _tokenID(to, cid);\n\n        _tokens.push(tokenID);\n        _tokenOfOwner[to] = tokenID;\n        _tokenIndexOfOwner[to] = _tokens.length - 1;\n        _cidOfToken[tokenID] = cid;\n\n        _mint(to, _tokenURI(cid), tokenID);\n    }\n\n    function _mint(\n        address to,\n        string memory newTokenURI,\n        uint256 tokenID\n    ) internal override(OpenERC721) {\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721) {\n        address from = ownerOf(tokenID);\n        uint256 index = _tokenIndexOfOwner[from];\n        uint256 lastIndex = _tokens.length - 1;\n\n        if (index != lastIndex) {\n            _tokens[index] = _tokens[lastIndex];\n            _tokenIndexOfOwner[ownerOf(_tokens[lastIndex])] = index;\n        }\n        _tokens.pop();\n\n        delete _cidOfToken[tokenID];\n        delete _tokenIndexOfOwner[from];\n        delete _tokenOfOwner[from];\n\n        super._burn(tokenID);\n    }\n\n    function _tokenID(address addr, uint256 cid) internal pure returns (uint256 tokenID) {\n        tokenID = uint256(keccak256(abi.encodePacked(cid, addr)));\n    }\n\n    function _tokenURI(uint256 cid) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(cid)));\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 // tokenId\n    ) internal pure override {\n        require(from == address(0) || to == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "contracts/interfaces/IOpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenBound {\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getTokenID(address addr, uint256 cid) external view returns (uint256 tokenID);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC721  IERC721\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\nabstract contract OpenERC721 is IERC721, OpenERC165 {\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    modifier onlyTokenOwnerOrApproved(uint256 tokenID) {\n        require(_isOwnerOrApproved(msg.sender, tokenID), \"Not token owner nor approved\");\n        _;\n    }\n\n    modifier existsToken(uint256 tokenID) {\n        require(_owners[tokenID] != address(0), \"Invalid token ID\");\n        _;\n    }\n\n    function transferFrom(address from, address to, uint256 tokenID)\n        external\n        payable\n        override (IERC721)\n    {\n        _transferFrom(from, to, tokenID);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data)\n        external\n        payable\n        override (IERC721)\n    {\n        _safeTransferFrom(from, to, tokenID, data);\n    }\n\n    function approve(address spender, uint256 tokenID) public override (IERC721) {\n        require(_isOwnerOrOperator(msg.sender, tokenID), \"Not token owner nor operator\");\n\n        _tokenApprovals[tokenID] = spender;\n        emit Approval(ownerOf(tokenID), spender, tokenID);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override (IERC721) {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenID)\n        public\n        payable\n        override (IERC721)\n    {\n        _safeTransferFrom(from, to, tokenID, \"\");\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x80ac58cd // = type(IERC721).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view override (IERC721) returns (uint256) {\n        require(owner != address(0), \"Invalid zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenID)\n        public\n        view\n        override (IERC721)\n        existsToken(tokenID)\n        returns (address)\n    {\n        return _owners[tokenID];\n    }\n\n    function getApproved(uint256 tokenID)\n        public\n        view\n        override (IERC721)\n        existsToken(tokenID)\n        returns (address)\n    {\n        return _tokenApprovals[tokenID];\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override (IERC721)\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function _mint(address to, string memory, uint256 tokenID) internal virtual {\n        require(to != address(0), \"Mint to zero address\");\n        require(_owners[tokenID] == address(0), \"Token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenID] = to;\n\n        emit Transfer(address(0), to, tokenID);\n        require(_isERC721Receiver(address(0), to, tokenID, \"\"), \"Not ERC721Received\");\n    }\n\n    function _burn(uint256 tokenID) internal virtual {\n        address owner = ownerOf(tokenID);\n        require(owner != address(0), \"Invalid token ID\");\n\n        assert(_balances[owner] > 0);\n\n        _balances[owner] -= 1;\n        delete _tokenApprovals[tokenID];\n        delete _owners[tokenID];\n\n        emit Transfer(owner, address(0), tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID) internal virtual {}\n\n    function _isOwnerOrOperator(address spender, uint256 tokenID)\n        internal\n        view\n        virtual\n        returns (bool ownerOrOperator)\n    {\n        address tokenOwner = ownerOf(tokenID);\n        ownerOrOperator = (tokenOwner == spender || isApprovedForAll(tokenOwner, spender));\n    }\n\n    function _safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data)\n        private\n    {\n        _transferFrom(from, to, tokenID);\n\n        require(_isERC721Receiver(from, to, tokenID, data), \"Not ERC721Receiver\");\n    }\n\n    function _transferFrom(address from, address to, uint256 tokenID)\n        private\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        require(from != address(0), \"Transfer from zero address\");\n        require(to != address(0), \"Transfer to zero address\");\n        require(from == ownerOf(tokenID), \"From not owner\");\n\n        _transferFromBefore(from, to, tokenID);\n\n        delete _tokenApprovals[tokenID];\n\n        if (from != to) {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n            _owners[tokenID] = to;\n        }\n\n        emit Transfer(from, to, tokenID);\n    }\n\n    function _isERC721Receiver(address from, address to, uint256 tokenID, bytes memory data)\n        private\n        returns (bool)\n    {\n        return to.code.length == 0\n            || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenID, data)\n                == IERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    function _isOwnerOrApproved(address spender, uint256 tokenID)\n        private\n        view\n        returns (bool ownerOrApproved)\n    {\n        ownerOrApproved =\n            (_isOwnerOrOperator(spender, tokenID) || (getApproved(tokenID) == spender));\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external\n        payable;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n    function transferFrom(address from, address to, uint256 tokenId) external payable;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/OpenCloner/OpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenCloneable  IOpenCloneable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloneable is IOpenCloneable, OpenERC165 {\n    bool public initialized;\n    string public template;\n    uint256 public version;\n\n    function parent() external view override (IOpenCloneable) returns (address parent_) {\n        // eip1167 deployed code = 45 bytes = 10 bytes + 20 bytes address + 15 bytes\n        // extract bytes 10 to 30: shift 2 bytes (16 bits) then truncate to address 20 bytes (uint160)\n        return (address(this).code.length == 45)\n            ? address(uint160(uint256(bytes32(address(this).code)) >> 16))\n            : address(0);\n    }\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bytes memory params\n    ) public virtual override (IOpenCloneable);\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenCloneable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory template_, uint256 version_) internal {\n        require(initialized == false, \"Already initialized\");\n        initialized = true;\n\n        template = template_;\n        version = version_;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenChecker  IOpenChecker\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\n\nabstract contract OpenChecker is IOpenChecker, OpenERC165 {\n    /// _ercInterfaceIds : ERC interfacesIds\n    /// 0xffffffff :  O Invalid\n    /// 0x01ffc9a7 :  1 ERC165\n    /// 0x80ac58cd :  2 ERC721\n    /// 0x5b5e139f :  3 ERC721Metadata\n    /// 0x780e9d63 :  4 ERC721Enumerable\n    /// 0x150b7a02 :  5 ERC721TokenReceiver\n    /// 0xd9b67a26 :  6 ERC1155\n    /// 0x0e89341c :  7 ERC1155MetadataURI\n    /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n    /// 0x7f5828d0 :  9 ERC173\n    /// 0x2a55205a : 10 ERC2981\n    bytes4[] private _ercInterfaceIds = [\n        bytes4(0xffffffff),\n        bytes4(0x01ffc9a7),\n        bytes4(0x80ac58cd),\n        bytes4(0x5b5e139f),\n        bytes4(0x780e9d63),\n        bytes4(0x150b7a02),\n        bytes4(0xd9b67a26),\n        bytes4(0x0e89341c),\n        bytes4(0x4e2312e0),\n        bytes4(0x7f5828d0),\n        bytes4(0x2a55205a)\n    ];\n\n    modifier onlyContract(address account) {\n        require(account.code.length > 0, \"Not smartcontract\");\n        _;\n    }\n\n    function isCollections(address[] memory smartcontracts)\n        public\n        view\n        override (IOpenChecker)\n        returns (bool[] memory checks)\n    {\n        checks = new bool[](smartcontracts.length);\n\n        for (uint256 i = 0; i < smartcontracts.length; i++) {\n            checks[i] = isCollection(smartcontracts[i]);\n        }\n    }\n\n    // TODO check only 4 interfaces\n    function isCollection(address smartcontract)\n        public\n        view\n        override (IOpenChecker)\n        onlyContract(smartcontract)\n        returns (bool)\n    {\n        bool[] memory checks = checkErcInterfaces(smartcontract);\n\n        // ERC165 and (ERC721 or ERC1155)\n        return !checks[0] && checks[1] && (checks[2] || checks[6]);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenChecker).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function checkErcInterfaces(address smartcontract)\n        public\n        view\n        override (IOpenChecker)\n        returns (bool[] memory)\n    {\n        return checkSupportedInterfaces(smartcontract, true, new bytes4[](0));\n    }\n\n    function checkSupportedInterfaces(address smartcontract, bool erc, bytes4[] memory interfaceIds)\n        public\n        view\n        override (IOpenChecker)\n        onlyContract(smartcontract)\n        returns (bool[] memory interfaceIdsChecks)\n    {\n        uint256 i;\n        uint256 len = (erc ? _ercInterfaceIds.length : 0) + interfaceIds.length;\n\n        interfaceIdsChecks = new bool[](len);\n\n        if (erc) {\n            for (uint256 j = 0; j < _ercInterfaceIds.length; j++) {\n                interfaceIdsChecks[i++] =\n                    IERC165(smartcontract).supportsInterface(_ercInterfaceIds[j]);\n            }\n        }\n        for (uint256 k = 0; k < interfaceIds.length; k++) {\n            interfaceIdsChecks[i++] = IERC165(smartcontract).supportsInterface(interfaceIds[k]);\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenPauseable  IOpenPauseable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseable is IOpenPauseable, OpenERC173 {\n    bool private _paused;\n\n    modifier onlyWhenNotPaused() {\n        require(!_paused, \"Paused!\");\n        _;\n    }\n\n    function togglePause() external override (IOpenPauseable) onlyOwner {\n        _setPaused(!_paused);\n    }\n\n    function paused() external view override (IOpenPauseable) returns (bool) {\n        return _paused;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC173)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenPauseable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _setPaused(bool paused_) private {\n        _paused = paused_;\n        emit SetPaused(_paused, msg.sender);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721Enumerable {\n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-165: Standard Interface Detection\n// https://eips.ethereum.org/EIPS/eip-165\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/utils/introspection/ERC165.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165  IERC165\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract OpenERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7; //  type(IERC165).interfaceId\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenCloneable {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bytes memory params\n    ) external;\n\n    function initialized() external view returns (bool);\n\n    function template() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function parent() external view returns (address);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenChecker {\n    function checkErcInterfaces(address smartcontract)\n        external\n        view\n        returns (bool[] memory interfaceIdsChecks);\n\n    function checkSupportedInterfaces(address smartcontract, bool erc, bytes4[] memory interfaceIds)\n        external\n        view\n        returns (bool[] memory interfaceIdsChecks);\n\n    function isCollection(address collection) external view returns (bool check);\n\n    function isCollections(address[] memory collection)\n        external\n        view\n        returns (bool[] memory checks);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenPauseable {\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function paused() external returns (bool);\n\n    function togglePause() external;\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-173: Contract Ownership Standard\n// https://eips.ethereum.org/EIPS/eip-173\n//\n// Derived from OpenZeppelin Contracts (access/Ownable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/access/Ownable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC173  IERC173\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenERC173 is IERC173, OpenERC165 {\n    bool private _openERC173Initialized;\n    address private _owner;\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Not owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external override (IERC173) onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function owner() public view override (IERC173) returns (address) {\n        return _owner;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x7f5828d0 || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(address owner_) internal {\n        require(_openERC173Initialized == false, \"Already initialized\");\n        _openERC173Initialized = true;\n\n        _transferOwnership(owner_);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/tests/OpenBound/OpenBoundTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenBound.sol\";\n\nimport \"./OpenBoundSupportsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721NonTransferableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol\";\n\ncontract OpenBoundTest is\n    OpenNFTsTest,\n    ERC173Test,\n    ERC721NonTransferableTest,\n    OpenPauseableTest,\n    OpenBoundSupportsTest\n{\n    uint256 private _cid = 777;\n\n    function constructorTest(address owner)\n        public\n        override(OpenNFTsTest, ERC173Test, ERC721NonTransferableTest, OpenPauseableTest, OpenBoundSupportsTest)\n        returns (address)\n    {\n        changePrank(owner);\n        uint256 maxSupply = 10;\n\n        OpenBound collection = new OpenBound();\n        collection.initialize(\"OpenBound\", \"BOUND\", owner, abi.encode(abi.encode(maxSupply), address(0), 0));\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(OpenNFTsTest, OpenPauseableTest, ERC721NonTransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        uint256 tokenID = OpenBound(payable(collection)).mint(_cid++);\n        string memory tokenURI = OpenBound(payable(collection)).tokenURI(tokenID);\n        return (tokenID, tokenURI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(OpenNFTsTest, ERC721NonTransferableTest) {\n        changePrank(OpenBound(payable(collection)).ownerOf(tokenID));\n        OpenBound(payable(collection)).burn(tokenID);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpPausable();\n        setUpOpenNFTs(\"OpenBound\", \"BOUND\");\n        setUpERC721NonTransferable();\n        setUpOpenBoundSupports();\n    }\n}\n"
    },
    "contracts/tests/OpenBound/OpenBoundSupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"../../interfaces/IOpenBound.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenBoundSupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenBoundSupports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, _owner);\n    }\n\n    function testOpenBoundCheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenBoundCheckSupportedInterfaces() public {\n        bytes4[5] memory ids = [\n            type(IOpenChecker).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenCloneable).interfaceId,\n            type(IOpenBound).interfaceId,\n            type(IOpenMarketable).interfaceId\n        ];\n        bool[5] memory expected = [true, true, true, true, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](5);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "forge-std/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEqUint(uint256 a, uint256 b) internal {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              JSON PARSING\n    //////////////////////////////////////////////////////////////*/\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n   struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy{\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy{\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList{\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        returns(EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs)\n        internal pure\n        returns (Tx1559[] memory)\n    {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx)\n        internal pure\n        returns (Tx1559 memory)\n    {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash= rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode= rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal pure\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = bytesToUint(rawDetail.nonce);\n        txDetail.txType = bytesToUint(rawDetail.txType);\n        txDetail.value = bytesToUint(rawDetail.value);\n        txDetail.gas = bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n\n    }\n\n    function readTx1559s(string memory path)\n        internal\n        returns (Tx1559[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n\n    function readTx1559(string memory path, uint256 index)\n        internal\n        returns (Tx1559 memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path)\n        internal\n        returns (Receipt[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint index)\n        internal\n        returns (Receipt memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts)\n        internal pure\n        returns(Receipt[] memory)\n    {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt)\n        internal pure\n        returns(Receipt memory)\n    {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed= bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = bytesToUint(rawReceipt.gasUsed);\n        receipt.status = bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal pure\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n\n    }\n\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\n            uint256 number;\n            for (uint i=0; i < b.length; i++) {\n                number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n            }\n        return number;\n    }\n\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n\n\n}\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nabstract contract OpenNFTsTest is ERC721FullTest {\n    function constructorTest(address owner_)\n        public\n        virtual\n        override (ERC721FullTest)\n        returns (address);\n\n    function mintTest(address collection, address minter_)\n        public\n        virtual\n        override (ERC721FullTest)\n        returns (uint256, string memory);\n\n    function burnTest(address collection, uint256 tokenID)\n        public\n        virtual\n        override (ERC721FullTest);\n\n    function setUpOpenNFTs(string memory name_, string memory symbol_) public {\n        setUpERC721Full(name_, symbol_);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721NonTransferableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nabstract contract ERC721NonTransferableTest is Test, IERC721Events {\n    address private _collection;\n    bool private _transferable;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpERC721NonTransferable() public {\n        _transferable = false;\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testFailERC721SafeTransferFrom() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721SafeTransferFromWithData() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n    }\n\n    function testFailERC721SafeTransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n        IERC721(_collection).safeTransferFrom(from, to, tokenID);\n    }\n\n    function testFailERC721SafeTransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(_collection), _tokenID0);\n    }\n\n    function testFailERC721TransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, address(_collection), _tokenID0);\n    }\n\n    function testFailERC721TransferFrom() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721TransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n        IERC721(_collection).transferFrom(from, to, tokenID);\n    }\n\n    function testFailERC721Approve() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n\n    function testFailERC721SetApprovalForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC173Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC173Test is Test {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpERC173() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testERC173Owner() public {\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testERC173TransferOwnership() public {\n        changePrank(_owner);\n        IERC173(_collection).transferOwnership(_tester);\n        assertEq(IERC173(_collection).owner(), _tester);\n    }\n\n    function testFailERC173NotTransferOwnership() public {\n        changePrank(_tester);\n        IERC173(_collection).transferOwnership(_minter);\n    }\n\n    function testERC173EmitTransferOwnership() public {\n        changePrank(_owner);\n        vm.expectEmit(true, true, false, false);\n        emit OwnershipTransferred(_owner, _tester);\n        IERC173(_collection).transferOwnership(_tester);\n    }\n\n    function testERC173SupportsInterface() public {\n        assertTrue(IERC165(address(_collection)).supportsInterface(type(IERC173).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseableTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _tester = address(0x4);\n\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpPausable() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testPausable() public {\n        assertEq(IOpenPauseable(_collection).paused(), false);\n    }\n\n    function testPausableTogglePause() public {\n        changePrank(_owner);\n\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), true);\n\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), false);\n    }\n\n    function testFailPausableTogglePauseNotOwner() public {\n        changePrank(_tester);\n        IOpenPauseable(_collection).togglePause();\n    }\n\n    function testFailPausableOnlyWhenNotPaused() public {\n        changePrank(_owner);\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), true);\n\n        mintTest(_collection, _owner);\n    }\n\n    function testPausableEmitSetPause() public {\n        changePrank(_owner);\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(true, _owner);\n        IOpenPauseable(_collection).togglePause();\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(false, _owner);\n        IOpenPauseable(_collection).togglePause();\n    }\n\n    function testPausableSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IOpenPauseable).interfaceId));\n    }\n}\n"
    },
    "contracts/next/OpenNFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//    OpenERC165\n//        |\n//  OpenResolver\n//        |\n//  OpenNFTsResolver  IOpenNFTsResolver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenResolver.sol\";\nimport \"../interfaces/IOpenNFTsResolver.sol\";\nimport \"../interfaces/IAll.sol\";\n\ncontract OpenNFTsResolver is IOpenNFTsResolver, OpenResolver {\n    bytes4[] private _interfaceIds = new bytes4[](12);\n\n    uint8 private constant _IERC_2981 = 10;\n    uint8 private constant _IERC_LENGTH = 11;\n\n    uint8 private constant _IOPEN_NFTS = _IERC_LENGTH + 0;\n    uint8 private constant _IOPEN_CHECKER = _IERC_LENGTH + 1;\n    uint8 private constant _IOPEN_CLONEABLE = _IERC_LENGTH + 2;\n    uint8 private constant _IOPEN_MARKETABLE = _IERC_LENGTH + 3;\n    uint8 private constant _IOPEN_PAUSEABLE = _IERC_LENGTH + 4;\n\n    uint8 private constant _IOPEN_NFTS_V0 = _IERC_LENGTH + 5;\n    uint8 private constant _IOPEN_NFTS_V1 = _IERC_LENGTH + 6;\n    uint8 private constant _IOPEN_NFTS_V2 = _IERC_LENGTH + 7;\n    uint8 private constant _IOPEN_NFTS_V3 = _IERC_LENGTH + 8;\n    uint8 private constant _IOPEN_NFTS_V4 = _IERC_LENGTH + 9;\n    uint8 private constant _IOPEN_AUTOMARKET = _IERC_LENGTH + 10;\n    uint8 private constant _IOPEN_BOUND = _IERC_LENGTH + 11;\n\n    constructor(address owner_, address registerer_) {\n        OpenERC173._initialize(owner_);\n        OpenRegistry._setRegisterer(registerer_);\n\n        /// 0xffffffff :  O Invalid\n        /// 0x01ffc9a7 :  1 ERC165\n        /// 0x80ac58cd :  2 ERC721\n        /// 0x5b5e139f :  3 ERC721Metadata\n        /// 0x780e9d63 :  4 ERC721Enumerable\n        /// 0x150b7a02 :  5 ERC721TokenReceiver\n        /// 0xd9b67a26 :  6 ERC1155\n        /// 0x0e89341c :  7 ERC1155MetadataURI\n        /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n        /// 0x7f5828d0 :  9 ERC173\n        /// 0x2a55205a : 10 ERC2981\n\n        _interfaceIds[_IOPEN_NFTS - _IERC_LENGTH] = type(IOpenNFTs).interfaceId;\n        _interfaceIds[_IOPEN_CHECKER - _IERC_LENGTH] = type(IOpenChecker).interfaceId;\n        _interfaceIds[_IOPEN_CLONEABLE - _IERC_LENGTH] = type(IOpenCloneable).interfaceId;\n        _interfaceIds[_IOPEN_MARKETABLE - _IERC_LENGTH] = type(IOpenMarketable).interfaceId;\n        _interfaceIds[_IOPEN_PAUSEABLE - _IERC_LENGTH] = type(IOpenPauseable).interfaceId;\n\n        _interfaceIds[_IOPEN_NFTS_V0 - _IERC_LENGTH] = type(IOpenNFTsV0).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V1 - _IERC_LENGTH] = type(IOpenNFTsV1).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V2 - _IERC_LENGTH] = type(IOpenNFTsV2).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V3 - _IERC_LENGTH] = type(IOpenNFTsV3).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V4 - _IERC_LENGTH] = type(IOpenNFTsV4).interfaceId;\n        _interfaceIds[_IOPEN_AUTOMARKET - _IERC_LENGTH] = type(IOpenAutoMarket).interfaceId;\n        _interfaceIds[_IOPEN_BOUND - _IERC_LENGTH] = type(IOpenBound).interfaceId;\n    }\n\n    function getOpenNFTsNftsInfos(\n        address collection,\n        address account,\n        uint256 limit,\n        uint256 offset\n    )\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        (nftInfos, count, total) = OpenGetter.getNftsInfos(collection, account, limit, offset);\n\n        openNTFsNftInfos = new OpenNFTsNftInfos[](nftInfos.length);\n        for (uint256 i = 0; i < nftInfos.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, nftInfos[i].tokenID, collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftsInfos(\n        address collection,\n        uint256[] memory tokenIDs,\n        address account\n    )\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, address(0), _interfaceIds);\n\n        nftInfos = OpenGetter.getNftsInfos(collection, tokenIDs, account);\n        openNTFsNftInfos = new OpenNFTsNftInfos[](tokenIDs.length);\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, tokenIDs[i], collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftInfos(\n        address collection,\n        uint256 tokenID,\n        address account\n    )\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        nftInfos = OpenGetter.getNftInfos(collection, tokenID, account);\n        openNTFsNftInfos = _getOpenNFTsNftInfos(collection, tokenID, collectionInfos.supported);\n    }\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        CollectionInfos[] memory collectionsInfosAll = getCollectionsInfos(getAddresses(), account, _interfaceIds);\n        total = collectionsInfosAll.length;\n\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                count++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](count);\n        openNFTsCollectionsInfos = new OpenNFTsCollectionInfos[](count);\n\n        uint256 j;\n        for (uint256 i = 0; i < total; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j] = collectionsInfosAll[i];\n                openNFTsCollectionsInfos[j] = _getOpenNFTsCollectionInfos(\n                    collectionsInfosAll[i].collection,\n                    collectionsInfosAll[i].supported\n                );\n                j++;\n            }\n        }\n    }\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos)\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n        openNTFscollectionInfos = _getOpenNFTsCollectionInfos(collection, collectionInfos.supported);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(OpenResolver) returns (bool) {\n        return interfaceId == type(IOpenNFTsResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _getOpenNFTsNftInfos(\n        address collection,\n        uint256 tokenID,\n        bool[] memory supported\n    ) internal view returns (OpenNFTsNftInfos memory nftInfos) {\n        if (supported[_IOPEN_MARKETABLE]) {\n            nftInfos.receiver = IOpenMarketable(payable(collection)).getTokenRoyalty(tokenID);\n            nftInfos.price = IOpenMarketable(payable(collection)).getTokenPrice(tokenID);\n        } else if (supported[_IERC_2981]) {\n            (nftInfos.receiver.account, ) = IERC2981(payable(collection)).royaltyInfo(tokenID, 1);\n        }\n    }\n\n    function _getOpenNFTsCollectionInfos(address collection, bool[] memory supported)\n        internal\n        view\n        returns (OpenNFTsCollectionInfos memory collInfos)\n    {\n        if (supported[_IOPEN_CLONEABLE]) {\n            collInfos.version = IOpenCloneable(collection).version(); // 4\n            collInfos.template = IOpenCloneable(collection).template(); // OpenNFTsV4 or OpenBound\n            collInfos.open = IOpenNFTsV4(collection).open();\n        } else if (supported[_IOPEN_NFTS_V3]) {\n            collInfos.version = 3;\n            collInfos.template = \"OpenNFTsV3\";\n            collInfos.open = IOpenNFTsV3(collection).open();\n        } else if (supported[_IOPEN_NFTS_V2]) {\n            collInfos.version = 2;\n        } else if (supported[_IOPEN_NFTS_V1]) {\n            collInfos.version = 1;\n        }\n\n        if (supported[_IOPEN_MARKETABLE]) {\n            collInfos.receiver = IOpenMarketable(payable(collection)).getDefaultRoyalty();\n            collInfos.price = IOpenMarketable(payable(collection)).getMintPrice();\n            collInfos.minimal = IOpenMarketable(payable(collection)).minimal();\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC4973.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\n"
    },
    "contracts/interfaces/IOpenNFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IOpenNFTsInfos.sol\";\n\ninterface IOpenNFTsResolver is IOpenNFTsInfos {\n    function getOpenNFTsNftsInfos(\n        address collection,\n        address account,\n        uint256 limit,\n        uint256 offset\n    )\n        external\n        view\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        );\n\n    function getOpenNFTsNftsInfos(\n        address collection,\n        uint256[] memory tokenIDs,\n        address account\n    )\n        external\n        view\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos\n        );\n\n    function getOpenNFTsNftInfos(\n        address collection,\n        uint256 tokenID,\n        address account\n    )\n        external\n        view\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos\n        );\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        );\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos);\n}\n"
    },
    "contracts/interfaces/IAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport \"./ICloneFactoryV2.sol\";\nimport \"./INFTsFactoryV2.sol\";\nimport \"./IOpenNFTsFactoryV3.sol\";\nimport \"./IOpenNFTsV0.sol\";\nimport \"./IOpenNFTsV1.sol\";\nimport \"./IOpenNFTsV2.sol\";\nimport \"./IOpenNFTsV3.sol\";\nimport \"./IOpenNFTsV4.sol\";\nimport \"./IOpenAutoMarket.sol\";\nimport \"./IOpenBound.sol\";\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//        \n//        |              |\n//   OpenChecker     OpenERC173\n//        |              |\n//    OpenGetter    OpenRegistry\n//        |              |\n//        \n//        |\n//  OpenResolver  IOpenResolver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenRegistry.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenResolver.sol\";\n\nabstract contract OpenResolver is IOpenResolver, OpenRegistry, OpenGetter {\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address addr) override (OpenRegistry) {\n        require(isCollection(addr), \"Not Collection\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenRegistry, OpenGetter)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenResolver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    ) public view override (IOpenResolver) returns (CollectionInfos[] memory collectionsInfos) {\n        collectionsInfos = new CollectionInfos[](collections.length);\n        for (uint256 i = 0; i < collections.length; i++) {\n            collectionsInfos[i] = _getCollectionInfos(collections[i], account, interfaceIds);\n        }\n    }\n\n    function _getCollectionsInfos(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        CollectionInfos[] memory collectionsInfosAll =\n            getCollectionsInfos(getAddresses(), account, interfaceIds);\n\n        uint256 len;\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                len++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](len);\n\n        uint256 j;\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j++] = collectionsInfosAll[i];\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTsInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\ninterface IOpenNFTsInfos is IERCNftInfos, IOpenReceiverInfos {\n    struct OpenNFTsCollectionInfos {\n        uint256 version;\n        string template;\n        bool open;\n        bool minimal;\n        uint256 price;\n        ReceiverInfos receiver;\n    }\n\n    struct OpenNFTsNftInfos {\n        uint256 price;\n        ReceiverInfos receiver;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERCNftInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n// Infos of either ERC721 or ERC1155 NFT\ninterface IERCNftInfos {\n    enum NftType {\n        ERC721,\n        ERC1155\n    }\n\n    struct CollectionInfos {\n        address collection;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n        uint256 balanceOf;\n        bool approvedForAll;\n        bool[] supported;\n        NftType erc;\n    }\n\n    struct NftInfos {\n        uint256 tokenID;\n        string tokenURI;\n        address owner;\n        address approved;\n        uint256 balanceOf;\n        NftType erc;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenReceiverInfos {\n    struct ReceiverInfos {\n        address account;\n        uint96 fee;\n        uint256 minimum;\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTsFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsFactoryV3 {\n    event Clone(string indexed templateName, address indexed clone, string indexed name, string symbol);\n\n    event SetResolver(address indexed resolver);\n\n    event SetTemplate(string indexed templateName, address indexed template, uint256 index);\n\n    function setResolver(address resolver) external;\n\n    function setTreasury(address treasury, uint96 treasuryFee) external;\n\n    function setTemplate(string memory templateName, address template) external;\n\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bytes memory params\n    ) external returns (address);\n\n    function template(string memory templateName) external view returns (address);\n\n    function templates(uint256 num) external view returns (address);\n\n    function countTemplates() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV0 {\n    function addUser(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV1 {\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV3 {\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTsV4 {\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenAutoMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenAutoMarket {\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(\n        address minter,\n        string memory tokenURI,\n        uint256 price,\n        address receiver,\n        uint96 fee\n    ) external payable returns (uint256 tokenID);\n\n    function gift(address to, uint256 tokenID) external payable;\n\n    function buy(uint256 tokenID) external payable;\n\n    function open() external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155TokenReceiver.sol)\n\npragma solidity 0.8.9;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external returns (bytes4);\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity 0.8.9;\n\ninterface IERC1155 {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC2981 {\n    function royaltyInfo(uint256 tokenID, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721Events {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTs {\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155METADATAURI.sol)\n\npragma solidity 0.8.9;\n\ninterface IERC1155MetadataURI {\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\ninterface IOpenMarketable is IOpenReceiverInfos {\n    enum Approve {\n        None,\n        One,\n        All\n    }\n\n    event SetDefaultRoyalty(address receiver, uint96 fee);\n\n    event SetTokenRoyalty(uint256 tokenID, address receiver, uint96 fee);\n\n    event SetMintPrice(uint256 price);\n\n    event SetTokenPrice(uint256 tokenID, uint256 price);\n\n    event Pay(\n        uint256 tokenID,\n        uint256 price,\n        address seller,\n        uint256 paid,\n        address receiver,\n        uint256 royalties,\n        uint256 fee,\n        address buyer,\n        uint256 unspent\n    );\n\n    receive() external payable;\n\n    function withdraw() external;\n\n    function setMintPrice(uint256 price) external;\n\n    function setDefaultRoyalty(address receiver, uint96 fee) external;\n\n    function setTokenPrice(uint256 tokenID, uint256 price) external;\n\n    function setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee) external;\n\n    function minimal() external view returns (bool);\n\n    function getMintPrice() external view returns (uint256 price);\n\n    function getDefaultRoyalty() external view returns (ReceiverInfos memory receiver);\n\n    function getTokenPrice(uint256 tokenID) external view returns (uint256 price);\n\n    function getTokenRoyalty(uint256 tokenID)\n        external\n        view\n        returns (ReceiverInfos memory receiver);\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenChecker\n//        |\n//  OpenGetter  IOpenGetter\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenGetter is IOpenGetter, OpenChecker {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenChecker)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenGetter).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionInfos(address collection, address account)\n        public\n        view\n        override (IOpenGetter)\n        returns (\n            // override(IOpenGetter)\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = _getCollectionInfos(collection, account, new bytes4[](0));\n    }\n\n    function getNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        public\n        view\n        override (IOpenGetter)\n        returns (NftInfos[] memory nftsInfos)\n    {\n        nftsInfos = new NftInfos[](tokenIDs.length);\n        for (uint256 i; i < tokenIDs.length; i++) {\n            nftsInfos[i] = _getNftInfos(collection, tokenIDs[i], account);\n        }\n    }\n\n    function getNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        public\n        view\n        override (IOpenGetter)\n        returns (NftInfos[] memory nftsInfos, uint256 count, uint256 total)\n    {\n        bool[] memory supported = checkErcInterfaces(collection);\n\n        // IF ERC721 & ERC721Enumerable supported\n        if (supported[2] && supported[4]) {\n            if (account == address(0)) {\n                total = IERC721Enumerable(collection).totalSupply();\n\n                require(offset <= total, \"Invalid offset\");\n                count = (offset + limit <= total) ? limit : total - offset;\n\n                nftsInfos = new NftInfos[](count);\n                for (uint256 i; i < count; i++) {\n                    nftsInfos[i] = _getNftInfos(\n                        collection, IERC721Enumerable(collection).tokenByIndex(offset + i), account\n                    );\n                }\n            } else {\n                total = IERC721(collection).balanceOf(account);\n\n                require(offset <= total, \"Invalid offset\");\n                count = (offset + limit <= total) ? limit : total - offset;\n\n                nftsInfos = new NftInfos[](count);\n                for (uint256 i; i < count; i++) {\n                    nftsInfos[i] = _getNftInfos(\n                        collection,\n                        IERC721Enumerable(collection).tokenOfOwnerByIndex(account, offset + i),\n                        account\n                    );\n                }\n            }\n        }\n    }\n\n    function getNftInfos(address collection, uint256 tokenID, address account)\n        public\n        view\n        override (IOpenGetter)\n        returns (NftInfos memory nftInfos)\n    {\n        return _getNftInfos(collection, tokenID, account);\n    }\n\n    function _getNftInfos(address collection, uint256 tokenID, address account)\n        internal\n        view\n        onlyContract(collection)\n        returns (NftInfos memory nftInfos)\n    {\n        nftInfos.tokenID = tokenID;\n        nftInfos.approved = IERC721(collection).getApproved(tokenID);\n        nftInfos.owner = IERC721(collection).ownerOf(tokenID);\n\n        if (IERC165(collection).supportsInterface(0x5b5e139f)) {\n            // ERC721Metadata\n            nftInfos.tokenURI = IERC721Metadata(collection).tokenURI(tokenID);\n        } else if (IERC165(collection).supportsInterface(0x0e89341c)) {\n            // ERC1155MetadataURI\n            nftInfos.tokenURI = IERC1155MetadataURI(collection).uri(tokenID);\n            nftInfos.balanceOf = IERC1155(collection).balanceOf(account, tokenID);\n        }\n    }\n\n    function _getCollectionInfos(address collection, address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        onlyContract(collection)\n        returns (CollectionInfos memory collectionInfos)\n    {\n        bool[] memory supported = checkSupportedInterfaces(collection, true, interfaceIds);\n        collectionInfos.supported = supported;\n\n        // ERC165 must be supported\n        require(!supported[0] && supported[1], \"Not ERC165\");\n\n        // ERC721 or ERC1155 must be supported\n        require(supported[2] || supported[6], \"Not NFT smartcontract\");\n\n        collectionInfos.collection = collection;\n\n        // try ERC173 owner\n        try IERC173(collection).owner() returns (address owner) {\n            collectionInfos.owner = owner;\n        } catch {}\n\n        // try ERC721Metadata name\n        try IERC721Metadata(collection).name() returns (string memory name) {\n            collectionInfos.name = name;\n        } catch {}\n\n        // try ERC721Metadata symbol\n        try IERC721Metadata(collection).symbol() returns (string memory symbol) {\n            collectionInfos.symbol = symbol;\n        } catch {}\n\n        // try ERC721Enumerable totalSupply\n        try IERC721Enumerable(collection).totalSupply() returns (uint256 totalSupply) {\n            collectionInfos.totalSupply = totalSupply;\n        } catch {}\n\n        if (account != address(0)) {\n            try IERC721(collection).balanceOf(account) returns (uint256 balanceOf) {\n                collectionInfos.balanceOf = balanceOf;\n            } catch {}\n\n            try IERC721(collection).isApprovedForAll(account, collection) returns (\n                bool approvedForAll\n            ) {\n                collectionInfos.approvedForAll = approvedForAll;\n            } catch {}\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenRegistry  IOpenRegistry\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\n\nabstract contract OpenRegistry is IOpenRegistry, OpenERC173 {\n    mapping(address => uint256) private _numAddress;\n    address[] private _addresses;\n    address public registerer;\n\n    /// @notice onlyRegisterer, by default owner is registerer and can add addresses, can be overriden\n    modifier onlyRegisterer() virtual {\n        require(msg.sender == owner() || msg.sender == registerer, \"Not registerer nor owner\");\n        _;\n    }\n\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address) virtual {\n        _;\n    }\n\n    function setRegisterer(address registerer_) external override (IOpenRegistry) onlyOwner {\n        _setRegisterer(registerer_);\n    }\n\n    function addAddresses(address[] memory addrs) external override (IOpenRegistry) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            _addAddress(addrs[i]);\n        }\n    }\n\n    function addAddress(address addr) external override (IOpenRegistry) {\n        _addAddress(addr);\n    }\n\n    function removeAddress(address addr) external override (IOpenRegistry) {\n        _removeAddress(addr);\n    }\n\n    function countAddresses() external view override (IOpenRegistry) returns (uint256) {\n        return _addresses.length;\n    }\n\n    function isRegistered(address addr) public view returns (bool) {\n        return _numAddress[addr] >= 1;\n    }\n\n    function getAddresses() public view override (IOpenRegistry) returns (address[] memory) {\n        return _addresses;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC173)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenRegistry).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _setRegisterer(address registerer_) internal {\n        registerer = registerer_;\n    }\n\n    function _addAddress(address addr) private onlyRegisterer onlyValid(addr) {\n        if (!isRegistered(addr)) {\n            _addresses.push(addr);\n            _numAddress[addr] = _addresses.length;\n        }\n    }\n\n    function _removeAddress(address addr) private onlyRegisterer {\n        require(isRegistered(addr), \"Not registered\");\n\n        uint256 num = _numAddress[addr];\n        if (num != _addresses.length) {\n            address addrLast = _addresses[_addresses.length - 1];\n            _addresses[num - 1] = addrLast;\n            _numAddress[addrLast] = num;\n        }\n\n        delete (_numAddress[addr]);\n        _addresses.pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenResolver is IERCNftInfos {\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    ) external view returns (CollectionInfos[] memory collectionsInfos);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenGetter is IERCNftInfos {\n    function getCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos);\n\n    function getNftInfos(address collection, uint256 tokenID, address account)\n        external\n        view\n        returns (NftInfos memory nftInfos);\n\n    function getNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        external\n        view\n        returns (NftInfos[] memory nftsInfos, uint256 count, uint256 total);\n\n    function getNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        external\n        view\n        returns (NftInfos[] memory nftsInfos);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenRegistry {\n    function setRegisterer(address registerer) external;\n\n    function removeAddress(address addr) external;\n\n    function addAddress(address addr) external;\n\n    function addAddresses(address[] memory addrs) external;\n\n    function getAddresses() external view returns (address[] memory);\n\n    function registerer() external view returns (address);\n\n    function countAddresses() external view returns (uint256);\n\n    function isRegistered(address addr) external view returns (bool registered);\n}\n"
    },
    "forge-std/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./console.sol\";\nimport \"./console2.sol\";\nimport \"./StdJson.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapated from Solmate implementation (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))));\n    }\n\n    function addressFromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index) internal returns (address who, uint256 privateKey) {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n}\n"
    },
    "ds-test/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Vm.sol\";\n\n// Helpers for parsing keys into types.\nlibrary stdJson {\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key)\n        internal\n        returns (bytes memory)\n    {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key)\n        internal\n        returns (uint256)\n    {\n        return abi.decode(vm.parseJson(json, key), (uint256));\n    }\n\n    function readUintArray(string memory json, string memory key)\n        internal\n        returns (uint256[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (uint256[]));\n    }\n\n    function readInt(string memory json, string memory key)\n        internal\n        returns (int256)\n    {\n        return abi.decode(vm.parseJson(json, key), (int256));\n    }\n\n    function readIntArray(string memory json, string memory key)\n        internal\n        returns (int256[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (int256[]));\n    }\n\n    function readBytes32(string memory json, string memory key)\n        internal\n        returns (bytes32)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes32));\n    }\n\n    function readBytes32Array(string memory json, string memory key)\n        internal\n        returns (bytes32[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes32[]));\n    }\n\n    function readString(string memory json, string memory key)\n        internal\n        returns (string memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (string));\n    }\n\n    function readStringArray(string memory json, string memory key)\n        internal\n        returns (string[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (string[]));\n    }\n\n    function readAddress(string memory json, string memory key)\n        internal\n        returns (address)\n    {\n        return abi.decode(vm.parseJson(json, key), (address));\n    }\n\n    function readAddressArray(string memory json, string memory key)\n        internal\n        returns (address[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (address[]));\n    }\n\n    function readBool(string memory json, string memory key)\n        internal\n        returns (bool)\n    {\n        return abi.decode(vm.parseJson(json, key), (bool));\n    }\n\n    function readBoolArray(string memory json, string memory key)\n        internal\n        returns (bool[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bool[]));\n    }\n\n    function readBytes(string memory json, string memory key)\n        internal\n        returns (bytes memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes));\n    }\n\n    function readBytesArray(string memory json, string memory key)\n        internal\n        returns (bytes[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes[]));\n    }\n\n\n}\n"
    },
    "forge-std/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.difficulty (newDifficulty)\n    function difficulty(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads the entire content of file as binary. Path is relative to the project root. (path) => (data)\n    function readFileBinary(string calldata) external returns (bytes memory);\n    // Get the path of the current project root\n    function projectRoot() external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root. (path, data) => ()\n    function writeFileBinary(string calldata, bytes calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n\n    // Convert values from a string, (string) => (parsed value)\n    function parseBytes(string calldata) external returns (bytes memory);\n    function parseAddress(string calldata) external returns (address);\n    function parseUint(string calldata) external returns (uint256);\n    function parseInt(string calldata) external returns (int256);\n    function parseBytes32(string calldata) external returns (bytes32);\n    function parseBool(string calldata) external returns (bool);\n\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns(uint256);\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns(bool);\n\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata,uint256) external returns(uint256);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns(uint256);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, and replays all transaction mined in the block before the transaction\n    function createFork(string calldata, bytes32) external returns (uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, and replays all transaction mined in the block before the transaction\n    function createSelectFork(string calldata, bytes32) external returns (uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns(uint256);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns(uint256);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 transaction) external;\n\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address) external;\n    function makePersistent(address, address) external;\n    function makePersistent(address, address, address) external;\n    function makePersistent(address[] calldata) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address) external;\n    function revokePersistent(address[] calldata) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address) external returns (bool);\n\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address) external;\n\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata) external returns(string memory);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns(string[2][] memory);\n\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256) external returns (address);\n\n    // parseJson\n\n    // Given a string of JSON, return the ABI-encoded value of provided key\n    // (stringified json, key) => (ABI-encoded data)\n    // Read the note below!\n    function parseJson(string calldata, string calldata) external returns(bytes memory);\n\n    // Given a string of JSON, return it as ABI-encoded, (stringified json, key) => (ABI-encoded data)\n    // Read the note below!\n    function parseJson(string calldata) external returns(bytes memory);\n\n    // Note:\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL ordser. That means that in order to succesfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC4973 {\n    event Attest(address indexed to, uint256 indexed tokenID);\n\n    // event Revoke(address indexed to, uint256 indexed tokenID);\n\n    function ownerOf(uint256 tokenID) external view returns (address);\n\n    // function burn(uint256 tokenID) external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/ITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface ITest {\n    function setUp() external;\n}\n"
    },
    "OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/units/ERC165Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721MetadataTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721EnumerableTest.t.sol\";\n\nabstract contract ERC721FullTest is\n    ERC165Test,\n    ERC721Test,\n    ERC721MetadataTest,\n    ERC721EnumerableTest\n{\n    string internal constant _TOKEN_URI =\n        \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n    bool private _transferable = true;\n\n    function constructorTest(address owner_)\n        public\n        virtual\n        override (ERC165Test, ERC721Test, ERC721MetadataTest, ERC721EnumerableTest)\n        returns (address);\n\n    function mintTest(address collection, address minter_)\n        public\n        virtual\n        override (ERC721Test, ERC721MetadataTest, ERC721EnumerableTest)\n        returns (uint256, string memory);\n\n    function burnTest(address collection, uint256 tokenID) public virtual override (ERC721Test);\n\n    function setUpERC721Full(string memory name_, string memory symbol_) public {\n        // setUpERC165();\n        setUpERC165();\n        setUpERC721();\n        setUpERC721Metadata(name_, symbol_);\n        setUpERC721Enumerable();\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nabstract contract ERC721Test is Test, IERC721Events {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpERC721() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721BalanceOf() public {\n        assertEq(IERC721(_collection).balanceOf(_minter), 1);\n        assertEq(IERC721(_collection).balanceOf(_tester), 0);\n    }\n\n    function testERC721BalanceOfBis() public {\n        mintTest(_collection, _tester);\n        assertEq(IERC721(_collection).balanceOf(_tester), 1);\n    }\n\n    function testERC721OwnerOf() public {\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721OwnerOfBis() public {\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        assertEq(IERC721(_collection).ownerOf(tokenID), _tester);\n    }\n\n    function testFailERC721NotOnlyTokenOwner() public {\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721ApproveChange() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n        IERC721(_collection).approve(address(0), _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n\n    function testERC721GetApproved() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        assertEq(IERC721(_collection).getApproved(_tokenID0), _tester);\n    }\n\n    function testFailERC721GetApproved() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n        IERC721(_collection).approve(_buyer, _tokenID0);\n\n        assertEq(IERC721(_collection).getApproved(_tokenID0), _tester);\n    }\n\n    function testERC721IsApprovedForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n        assertTrue(IERC721(_collection).isApprovedForAll(_minter, _tester));\n    }\n\n    function testERC721IsNotApprovedForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n        IERC721(_collection).setApprovalForAll(_tester, false);\n\n        assertFalse(IERC721(_collection).isApprovedForAll(_minter, _tester));\n    }\n\n    function testERC721SupportsInterface() public {\n        assertTrue(IERC165(address(_collection)).supportsInterface(type(IERC721).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721EnumerableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC721EnumerableTest is Test {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x2);\n    address private _minter = address(0x22);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpERC721Enumerable() public {\n        _collection = constructorTest(_owner);\n        (_tokenID0,) = mintTest(_collection, _minter);\n    }\n\n    function testERC721EnumerableTotalSupply() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n    }\n\n    function testERC721EnumerableTotalSupplyIncrement() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        mintTest(_collection, _tester);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 2);\n    }\n\n    function testERC721EnumerableTokenByIndex() public {\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n    }\n\n    function testFailERC721EnumerableTokenByIndex() public view {\n        IERC721Enumerable(_collection).tokenByIndex(1);\n    }\n\n    function testERC721EnumerableTokenByIndexSecond() public {\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(1), tokenID);\n    }\n\n    function testERC721EnumerableTokenOfOwnerByIndex() public {\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n    }\n\n    function testFailERC721EnumerableTokenOfOwnerByIndex() public view {\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 1);\n    }\n\n    function testERC721EnumerableTokenOfOwnerByIndexOther() public {\n        console.log(\"_tokenID0\", _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        console.log(\"tokenID\", tokenID);\n\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0), tokenID);\n    }\n\n    function testERC721EnumerableSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC721Enumerable).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721MetadataTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC721MetadataTest is Test {\n    address private _collection;\n    string private _name;\n    string private _symbol;\n    string private _tokenURI0;\n    uint256 private _tokenID0;\n    address private _minter = address(0x23);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpERC721Metadata(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _collection = constructorTest(_minter);\n        (_tokenID0, _tokenURI0) = mintTest(_collection, _minter);\n    }\n\n    function testERC721MetadataName() public {\n        assertEq(IERC721Metadata(_collection).name(), _name);\n    }\n\n    function testERC721MetadataSymbol() public {\n        assertEq(IERC721Metadata(_collection).symbol(), _symbol);\n    }\n\n    function testERC721MetadataURI() public {\n        assertEq(IERC721Metadata(_collection).tokenURI(_tokenID0), _tokenURI0);\n    }\n\n    function testERC721MetadataSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC721Metadata).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC165Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC165Test is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpERC165() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testERC165SupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC165).interfaceId));\n        assertFalse(IERC165(_collection).supportsInterface(0xffffffff));\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsResolver/OpenNFTsResolverTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next//OpenNFTsResolver.sol\";\nimport \"./OpenNFTsResolverSupportsTest.t.sol\";\nimport \"./OpenNFTsResolverGetterTest.t.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenResolverTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenCheckerTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenGetterTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenRegistryTest.t.sol\";\n\ncontract OpenNFTsResolverTest is\n    ITest,\n    OpenResolverTest,\n    OpenCheckerTest,\n    OpenGetterTest,\n    OpenRegistryTest,\n    OpenNFTsResolverSupportsTest,\n    OpenNFTsResolverGetterTest\n{\n    function constructorTest(address owner)\n        public\n        override (\n            OpenResolverTest,\n            OpenGetterTest,\n            OpenCheckerTest,\n            OpenRegistryTest,\n            OpenNFTsResolverSupportsTest,\n            OpenNFTsResolverGetterTest\n        )\n        returns (address)\n    {\n        changePrank(owner);\n\n        OpenNFTsResolver smartcontract = new OpenNFTsResolver(owner, owner);\n\n        return address(smartcontract);\n    }\n\n    function setUp() public override {\n        setUpOpenResolver();\n        setUpOpenRegistry();\n        setUpOpenChecker();\n        setUpOpenGetter();\n        setUpOpenNFTsResolverSupports();\n        setUpOpenNFTsResolverGetter();\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsResolver/OpenNFTsResolverSupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsResolver.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenNFTsResolverSupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsResolverSupports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, address(this));\n    }\n\n    function testOpenNFTsResolverCheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, false, false, false, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenNFTsResolverCheckSupportedInterfaces() public {\n        bytes4[8] memory ids = [\n            type(IOpenCloneable).interfaceId,\n            type(IOpenMarketable).interfaceId,\n            type(IOpenNFTs).interfaceId,\n            type(IOpenNFTsResolver).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenChecker).interfaceId,\n            type(IERC721TokenReceiver).interfaceId,\n            0xffffffff\n        ];\n        bool[8] memory expected = [false, false, false, true, false, true, false, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](8);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            console.log(\"testOpenNFTsResolverCheckErcInterfaces ~ i\", i);\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsResolver/OpenNFTsResolverGetterTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsResolver.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenNFTsResolverGetterTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsResolverGetter() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, address(this));\n    }\n\n    function testOpenNFTsResolverGetter(address account) public view {\n        _resolver.getOpenNFTsCollectionsInfos(account);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenCheckerTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/examples/OpenNFTsEx.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\n\nabstract contract OpenCheckerTest is Test {\n    address private _resolver;\n    address private _owner = address(0x1);\n    address[3] private _addrs;\n\n    bytes4 private _idNull = 0xffffffff;\n    bytes4 private _idIERC165 = type(IERC165).interfaceId;\n    bytes4 private _idChecker = type(IOpenChecker).interfaceId;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenChecker() public {\n        _resolver = constructorTest(_owner);\n\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n\n        OpenNFTsEx openNFTsEx = new OpenNFTsEx();\n        openNFTsEx.initialize(\"OpenNFTsEx\", \"NFT\", _owner, payable(address(0x7)), 0, options);\n        _addrs[0] = address(openNFTsEx);\n\n        OpenNFTsEx openNFTsEx2 = new OpenNFTsEx();\n        openNFTsEx2.initialize(\"OpenNFTsEx2\", \"NFT2\", _owner, payable(address(0x7)), 0, options);\n        _addrs[1] = address(openNFTsEx2);\n\n        _addrs[2] = _resolver;\n    }\n\n    function testOpenCheckerIsCollection() public {\n        assertTrue(IOpenChecker(_resolver).isCollection(_addrs[0]));\n        assertTrue(IOpenChecker(_resolver).isCollection(_addrs[1]));\n        assertFalse(IOpenChecker(_resolver).isCollection(_addrs[2]));\n    }\n\n    function testOpenCheckerIsCollections() public {\n        address[] memory addrs = new address[](3);\n        addrs[0] = _addrs[0];\n        addrs[1] = _addrs[1];\n        addrs[2] = _addrs[2];\n\n        bool[3] memory expected = [true, true, false];\n        bool[] memory checks = IOpenChecker(_resolver).isCollections(addrs);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenCheckerSupportsInterface() public {\n        assertFalse(IERC165(_resolver).supportsInterface(_idNull));\n        assertTrue(IERC165(_resolver).supportsInterface(_idIERC165));\n        assertTrue(IERC165(_resolver).supportsInterface(_idChecker));\n    }\n\n    function testOpenCheckerErcSupportedInterfaces() public {\n        bool[11] memory expected =\n            [false, true, false, false, false, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_resolver);\n\n        for (uint256 i = 0; i < checks.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenCheckerCheckSupportedInterfaces() public {\n        bytes4[2] memory ids = [_idIERC165, _idNull];\n        bool[2] memory expected = [true, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks =\n            IOpenChecker(_resolver).checkSupportedInterfaces(_resolver, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenRegistryTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/examples/OpenNFTsEx.sol\";\n\nabstract contract OpenRegistryTest is Test {\n    address private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n\n    bytes4 private _idNull = 0xffffffff;\n    bytes4 private _idIERC165 = type(IERC165).interfaceId;\n    bytes4 private _idRegistry = type(IOpenRegistry).interfaceId;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenRegistry() public {\n        _resolver = constructorTest(_owner);\n\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n        _collection = address(new OpenNFTsEx());\n        IOpenNFTsEx(_collection).initialize(\n            \"ERC721\", \"NFT\", _owner, payable(address(0x7)), 0, options\n        );\n    }\n\n    function testOpenRegistryAddAddress() public {\n        changePrank(_owner);\n\n        address[] memory addrs = new address[](1);\n        addrs[0] = _collection;\n\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 0);\n        IOpenRegistry(_resolver).addAddresses(addrs);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 1);\n    }\n\n    function testOpenRegistryBurnAddress() public {\n        changePrank(_owner);\n\n        address[] memory addrs = new address[](3);\n        addrs[0] = address(new OpenNFTsEx());\n        addrs[1] = address(new OpenNFTsEx());\n        addrs[2] = address(new OpenNFTsEx());\n        address addr = address(new OpenNFTsEx());\n\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 0);\n        IOpenRegistry(_resolver).addAddresses(addrs);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 3);\n        IOpenRegistry(_resolver).addAddress(addr);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 4);\n\n        IOpenRegistry(_resolver).removeAddress(addrs[2]);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 3);\n        IOpenRegistry(_resolver).removeAddress(addr);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 2);\n        IOpenRegistry(_resolver).removeAddress(addrs[0]);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 1);\n        IOpenRegistry(_resolver).removeAddress(addrs[1]);\n        assertEq(IOpenRegistry(_resolver).countAddresses(), 0);\n    }\n\n    function testOpenRegistrySupportsInterface() public {\n        assertFalse(IERC165(_resolver).supportsInterface(_idNull));\n        assertTrue(IERC165(_resolver).supportsInterface(_idIERC165));\n        assertTrue(IERC165(_resolver).supportsInterface(_idRegistry));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenResolverTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/examples/OpenNFTsEx.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenResolver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\n\nabstract contract OpenResolverTest is Test {\n    address private _collection;\n    address private _owner = address(0x5);\n\n    bytes4 public idIERC165 = type(IERC165).interfaceId;\n    bytes4 public idIERC173 = type(IERC173).interfaceId;\n    bytes4 public idOpenResolver = type(IOpenResolver).interfaceId;\n    bytes4 public idOpenRegistry = type(IOpenRegistry).interfaceId;\n    bytes4 public idOpenGetter = type(IOpenGetter).interfaceId;\n    bytes4 public idOpenChecker = type(IOpenChecker).interfaceId;\n    bytes4 public idNull = 0xffffffff;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenResolver() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testOpenResolverSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(idIERC165));\n        assertTrue(IERC165(_collection).supportsInterface(idIERC173));\n        assertTrue(IERC165(_collection).supportsInterface(idOpenResolver));\n        assertTrue(IERC165(_collection).supportsInterface(idOpenRegistry));\n        assertTrue(IERC165(_collection).supportsInterface(idOpenGetter));\n        assertTrue(IERC165(_collection).supportsInterface(idOpenChecker));\n        assertFalse(IERC165(_collection).supportsInterface(idNull));\n    }\n\n    function testOpenResolver() public {\n        address[] memory addrs = new address[](2);\n\n        bytes4[] memory ids = new bytes4[](1);\n        ids[0] = bytes4(0x80ac58cd);\n\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n\n        changePrank(_owner);\n\n        OpenNFTsEx openNFTsEx = new OpenNFTsEx();\n        openNFTsEx.initialize(\"OpenNFTsEx\", \"NFT\", _owner, payable(address(0x7)), 0, options);\n        addrs[0] = address(openNFTsEx);\n\n        OpenNFTsEx openNFTsEx2 = new OpenNFTsEx();\n        openNFTsEx2.initialize(\"OpenNFTsEx2\", \"NFT2\", _owner, payable(address(0x7)), 0, options);\n        addrs[1] = address(openNFTsEx2);\n\n        console.log(\"msg.sender\", msg.sender);\n        console.log(\"_owner\", _owner);\n        changePrank(_owner);\n        IOpenRegistry(_collection).addAddresses(addrs);\n\n        assertEq(IOpenRegistry(_collection).countAddresses(), 2);\n        assertEq(IOpenRegistry(_collection).getAddresses(), addrs);\n\n        IOpenResolver(_collection).getCollectionsInfos(addrs, _owner, ids);\n        IOpenResolver(_collection).getCollectionsInfos(addrs, address(0), ids);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenGetterTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/examples/OpenNFTsEx.sol\";\n\nabstract contract OpenGetterTest is Test, IERCNftInfos {\n    address private _resolver;\n    address private _collection;\n    address private _owner = makeAddr(\"owner\");\n    address private _tester = makeAddr(\"tester\");\n    address private _random = makeAddr(\"random\");\n\n    uint256 private _tokenID0;\n    uint256 private _tokenID1;\n    uint256 private _tokenID2;\n    string private constant _TOKEN_URI =\n        \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n\n    bytes4 private _idNull = 0xffffffff;\n    bytes4 private _idIERC165 = type(IERC165).interfaceId;\n    bytes4 private _idIERC173 = type(IERC173).interfaceId;\n    bytes4 private _idGetter = type(IOpenGetter).interfaceId;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenGetter() public {\n        _resolver = constructorTest(_owner);\n\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n        _collection = address(new OpenNFTsEx());\n        IOpenNFTsEx(_collection).initialize(\n            \"ERC721\", \"NFT\", _owner, payable(address(0x7)), 0, options\n        );\n\n        _tokenID0 = IOpenNFTsEx(_collection).mint(_TOKEN_URI);\n        _tokenID1 = IOpenNFTsEx(_collection).mint(_TOKEN_URI);\n        _tokenID2 = IOpenNFTsEx(_collection).mint(_TOKEN_URI);\n    }\n\n    function testOpenGetterGetNftInfos() public {\n        NftInfos memory nftInfos =\n            IOpenGetter(_resolver).getNftInfos(address(_collection), _tokenID0, _random);\n        assertEq(nftInfos.tokenID, _tokenID0);\n        assertEq(nftInfos.tokenURI, _TOKEN_URI);\n        assertEq(nftInfos.owner, _owner);\n        assertEq(nftInfos.approved, address(0));\n    }\n\n    function testOpenGetterGetNftsInfos1() public {\n        (NftInfos[] memory nftsInfos, uint256 count, uint256 total) =\n            IOpenGetter(_resolver).getNftsInfos(address(_collection), _owner, 0, 0);\n        assertEq(nftsInfos.length, 0);\n        assertEq(count, 0);\n        assertEq(total, 3);\n    }\n\n    function testOpenGetterGetNftsInfos2() public {\n        (NftInfos[] memory nftsInfos, uint256 count, uint256 total) =\n            IOpenGetter(_resolver).getNftsInfos(address(_collection), _owner, 5, 0);\n        assertEq(nftsInfos.length, 3);\n        assertEq(nftsInfos[0].tokenID, _tokenID0);\n        assertEq(nftsInfos[1].tokenID, _tokenID1);\n        assertEq(nftsInfos[2].tokenID, _tokenID2);\n        assertEq(count, 3);\n        assertEq(total, 3);\n    }\n\n    function testOpenGetterGetNftsInfos3() public {\n        (NftInfos[] memory nftsInfos, uint256 count, uint256 total) =\n            IOpenGetter(_resolver).getNftsInfos(address(_collection), address(0), 0, 0);\n\n        assertEq(nftsInfos.length, 0);\n        assertEq(count, 0);\n        assertEq(total, 3);\n    }\n\n    function testOpenGetterGetNftsInfos4() public {\n        (NftInfos[] memory nftsInfos, uint256 count, uint256 total) =\n            IOpenGetter(_resolver).getNftsInfos(address(_collection), address(0), 3, 1);\n\n        assertEq(nftsInfos.length, 2);\n        assertEq(count, 2);\n        assertEq(total, 3);\n    }\n\n    function testOpenGetterGetNftsInfos5() public {\n        (NftInfos[] memory nftsInfos, uint256 count, uint256 total) =\n            IOpenGetter(_resolver).getNftsInfos(address(_collection), _random, 10, 0);\n\n        assertEq(nftsInfos.length, 0);\n        assertEq(count, 0);\n        assertEq(total, 0);\n    }\n\n    function testOpenGetterGetCollectionInfosApprovedForAll1() public {\n        CollectionInfos memory collectionInfos =\n            IOpenGetter(_resolver).getCollectionInfos(address(_collection), _random);\n        assertEq(collectionInfos.approvedForAll, false);\n    }\n\n    function testOpenGetterGetCollectionInfosApprovedForAll2() public {\n        changePrank(_tester);\n        IERC721(_collection).setApprovalForAll(_collection, true);\n\n        CollectionInfos memory collectionInfos =\n            IOpenGetter(_resolver).getCollectionInfos(address(_collection), _tester);\n        assertEq(collectionInfos.approvedForAll, true);\n    }\n\n    function testOpenGetterGetCollectionInfos() public {\n        assertEq(IERC173(_collection).owner(), _owner);\n\n        CollectionInfos memory collectionInfos =\n            IOpenGetter(_resolver).getCollectionInfos(address(_collection), _random);\n        assertEq(collectionInfos.collection, _collection);\n        assertEq(collectionInfos.owner, _owner);\n        assertEq(collectionInfos.name, \"ERC721\");\n        assertEq(collectionInfos.symbol, \"NFT\");\n    }\n\n    function testOpenGetterERC173NotButOwner() public {\n        ERC173NotButOwner smartcontract = new ERC173NotButOwner(_owner);\n        assertEq(IERC173(address(smartcontract)).owner(), _owner);\n        assertFalse(IERC165(smartcontract).supportsInterface(_idIERC173));\n\n        CollectionInfos memory collectionInfos =\n            IOpenGetter(_resolver).getCollectionInfos(address(smartcontract), _random);\n        assertEq(collectionInfos.owner, _owner);\n    }\n\n    function testOpenGetterERC173Not() public {\n        ERC173Not smartcontract = new ERC173Not();\n\n        CollectionInfos memory collectionInfos =\n            IOpenGetter(_resolver).getCollectionInfos(address(smartcontract), _random);\n        assertEq(collectionInfos.owner, address(0));\n    }\n\n    function testFailOpenGetterGetNftsInfos1() public view {\n        IOpenGetter(_resolver).getNftsInfos(address(_collection), _owner, 1, 4);\n    }\n\n    function testFailOpenGetterGetNftsInfos2() public view {\n        IOpenGetter(_resolver).getNftsInfos(address(0), _owner, 0, 3);\n    }\n\n    function testOpenGetterSupportsInterface() public {\n        assertFalse(IERC165(_resolver).supportsInterface(_idNull));\n        assertTrue(IERC165(_resolver).supportsInterface(_idIERC165));\n        assertTrue(IERC165(_resolver).supportsInterface(_idGetter));\n    }\n}\n\ncontract ERC173Not is OpenERC721 {}\n\ncontract ERC173NotButOwner is OpenERC721 {\n    address private _owner;\n\n    constructor(address owner_) {\n        _owner = owner_;\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n}\n"
    },
    "OpenNFTs/contracts/examples/OpenNFTsEx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       \n//       |                                     |             |             |\n//   OpenERC721                           OpenERC173  OpenChecker  OpenCloneable\n//     (NFT)                               (ownable)         |             |\n//       |                                     |             |             |\n//                     |             |\n//       |           |              |      |        |        |             |\n//   OpenERC721  OpenERC721   OpenERC2981  |        |        |             |\n//    Metadata   Enumerable  (RoyaltyInfo) |        |        |             |\n//       |           |              |      |        |        |             |\n//       |           |                      |        |             |\n//       |           |              |               |        |             |\n//       |           |        OpenMarketable  OpenPauseable  |             |\n//       |           |              |               |        |             |\n//       \n//       |\n//    OpenNFTs\n//       |\n//   OpenNFTsEx  IOpenNFTsEx\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol\";\nimport \"OpenNFTs/contracts/examples/IOpenNFTsEx.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsEx is IOpenNFTsEx, OpenNFTs {\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice override onlyMinter:\n    /// @notice either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() override (OpenNFTs) {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function buy(uint256 tokenID) external payable override (IOpenNFTsEx) {\n        this.safeTransferFrom{value: msg.value}(ownerOf(tokenID), msg.sender, tokenID);\n    }\n\n    function mint(string memory tokenURI)\n        external\n        override (IOpenNFTsEx)\n        onlyMinter\n        onlyWhenNotPaused\n        returns (uint256)\n    {\n        return OpenNFTs.mint(msg.sender, tokenURI);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        address treasury_,\n        uint96 treasuryFee_,\n        bool[] memory options_\n    ) public override (IOpenNFTsEx) {\n        open = options_[0];\n        OpenNFTs._initialize(\n            name_, symbol_, owner_, 0, address(0), 0, treasury_, treasuryFee_, options_[1]\n        );\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public override (OpenCloneable) {\n        (address payable treasury_, uint96 treasuryFee_, bool[] memory options_) =\n            abi.decode(params_, (address, uint96, bool[]));\n        initialize(name_, symbol_, owner_, treasury_, treasuryFee_, options_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override (OpenNFTs) returns (bool) {\n        return interfaceId == type(IOpenNFTsEx).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       \n//       |                                       |             |              |\n//   OpenERC721                            OpenERC2981    OpenERC173    OpenCloneable\n//     (NFT)                              (RoyaltyInfo)    (ownable)          |\n//       |                                        |            |              |\n//          |                   |\n//       |                        |           |   |     |      |              |\n//  OpenERC721Metadata  OpenERC721Enumerable  |         |              |\n//       |                        |           |   |            |              |\n//       |                        |      OpenMarketable   OpenPauseable       |\n//       |                        |             |              |              |\n//       \n//       |\n//    OpenNFTs  IOpenNFTs\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\n\n/// @title OpenNFTs smartcontract\nabstract contract OpenNFTs is\n    IOpenNFTs,\n    OpenERC721Metadata,\n    OpenERC721Enumerable,\n    OpenMarketable,\n    OpenPauseable,\n    OpenCloneable\n{\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice onlyMinter, by default only owner can mint, can be overriden\n    modifier onlyMinter() virtual {\n        require(msg.sender == owner(), \"Not minter\");\n        _;\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID)\n        external\n        override (IOpenNFTs)\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _burn(tokenID);\n    }\n\n    function mint(address minter, string memory tokenURI)\n        public\n        override (IOpenNFTs)\n        onlyMinter\n        returns (uint256 tokenID)\n    {\n        tokenID = tokenIdNext++;\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (\n            OpenMarketable, OpenERC721Metadata, OpenERC721Enumerable, OpenCloneable, OpenPauseable\n        )\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTs).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice _initialize\n    /// @param name_ name of the NFT Collection\n    /// @param symbol_ symbol of the NFT Collection\n    /// @param owner_ owner of the NFT Collection\n    // solhint-disable-next-line comprehensive-interface\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        uint256 mintPrice_,\n        address receiver_,\n        uint96 fee_,\n        address treasury_,\n        uint96 treasuryFee_,\n        bool minimal_\n    ) internal {\n        tokenIdNext = 1;\n\n        OpenCloneable._initialize(\"OpenNFTs\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n        OpenMarketable._initialize(mintPrice_, receiver_, fee_, treasury_, treasuryFee_, minimal_);\n    }\n\n    /// @notice _mint\n    /// @param minter minter address\n    /// @param tokenURI token metdata URI\n    /// @param tokenID token ID\n    function _mint(address minter, string memory tokenURI, uint256 tokenID)\n        internal\n        override (OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable)\n    {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID)\n        internal\n        override (OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable)\n    {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        override (OpenERC721, OpenMarketable, OpenERC721Enumerable)\n    {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/examples/IOpenNFTsEx.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTsEx {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        address treasury,\n        uint96 treasuryFee,\n        bool[] memory options\n    ) external;\n\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function buy(uint256 tokenID) external payable;\n\n    function open() external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/extensions/ERC721Enumerable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/...\n// ...contracts/token/ERC721/extensions/ERC721Enumerable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721Enumerable  IERC721Enumerable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenERC721Enumerable is IERC721Enumerable, OpenERC721 {\n    // Array of all tokens ID\n    uint256[] private _allTokens;\n\n    // Mapping from owner to list of token IDs owned\n    // mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to owned index\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Mapping from token ID to all index\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override (IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < OpenERC721.balanceOf(owner), \"Invalid index!\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() external view override (IERC721Enumerable) returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index)\n        external\n        view\n        override (IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < _allTokens.length, \"Invalid index!\");\n        return _allTokens[index];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC721)\n        returns (bool)\n    {\n        return interfaceId == 0x780e9d63 || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, string memory tokenURI, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _addOwnedToken(to, tokenID);\n\n        _allTokensIndex[tokenID] = _allTokens.length;\n        _allTokens.push(tokenID);\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override (OpenERC721) {\n        address from = ownerOf(tokenID);\n\n        _removeOwnedToken(from, tokenID);\n\n        uint256 allBurnIndex = _allTokensIndex[tokenID];\n        uint256 allLastIndex = _allTokens.length - 1;\n        uint256 allLastTokenId = _allTokens[allLastIndex];\n\n        _allTokensIndex[allLastTokenId] = allBurnIndex;\n        delete _allTokensIndex[tokenID];\n\n        _allTokens[allBurnIndex] = allLastTokenId;\n        _allTokens.pop();\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _removeOwnedToken(from, tokenID);\n        _addOwnedToken(to, tokenID);\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _addOwnedToken(address owner, uint256 tokenID) private {\n        _ownedTokensIndex[tokenID] = _ownedTokens[owner].length;\n        _ownedTokens[owner].push(tokenID);\n    }\n\n    function _removeOwnedToken(address owner, uint256 tokenID) private {\n        uint256 burnIndex = _ownedTokensIndex[tokenID];\n        uint256 lastIndex = OpenERC721.balanceOf(owner) - 1;\n\n        if (burnIndex != lastIndex) {\n            uint256 lastTokenId = _ownedTokens[owner][lastIndex];\n            _ownedTokens[owner][burnIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = burnIndex;\n        }\n\n        delete _ownedTokensIndex[tokenID];\n        _ownedTokens[owner].pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//     OpenERC165\n//          |\n//     OpenERC721\n//          |\n//  OpenERC721Metadata  IERC721Metadata\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\n\nabstract contract OpenERC721Metadata is IERC721Metadata, OpenERC721 {\n    bool private _openERC721MetadataInitialized;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => string) private _tokenURIs;\n\n    function name() external view virtual override (IERC721Metadata) returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view virtual override (IERC721Metadata) returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenID)\n        external\n        view\n        virtual\n        override (IERC721Metadata)\n        existsToken(tokenID)\n        returns (string memory)\n    {\n        return _tokenURIs[tokenID];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC721)\n        returns (bool)\n    {\n        return interfaceId == 0x5b5e139f || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory name_, string memory symbol_) internal {\n        require(_openERC721MetadataInitialized == false, \"Already initialized\");\n        _openERC721MetadataInitialized = true;\n\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function _mint(address to, string memory newTokenURI, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _tokenURIs[tokenID] = newTokenURI;\n\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override (OpenERC721) {\n        delete _tokenURIs[tokenID];\n\n        super._burn(tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//        |\n//        \n//        |            |             |\n//   OpenERC721    OpenERC173   OpenERC2981\n//      (NFT)      (Ownable)   (RoyaltyInfo)\n//        |            |             |\n//        \n//        |\n//  OpenMarketable  IOpenMarketable - OpenGuard\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC2981.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenGuard.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenMarketable is\n    IOpenMarketable,\n    OpenERC721,\n    OpenERC173,\n    OpenERC2981,\n    OpenGuard\n{\n    mapping(uint256 => uint256) internal _tokenPrice;\n\n    bool public minimal;\n\n    ReceiverInfos internal _treasury;\n\n    receive() external payable override (IOpenMarketable) {}\n\n    /// @notice withdraw eth\n    function withdraw() external override (IOpenMarketable) onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /// @notice SET default mint price\n    /// @param price : default price in wei\n    function setMintPrice(uint256 price) public override (IOpenMarketable) onlyOwner {\n        _setMintPrice(price);\n    }\n\n    /// @notice SET default royalty info\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10000\n    function setDefaultRoyalty(address receiver, uint96 fee)\n        public\n        override (IOpenMarketable)\n        onlyOwner\n    {\n        _setDefaultRoyalty(receiver, fee);\n    }\n\n    /// @notice SET token price\n    /// @param tokenID : token ID\n    /// @param price : token price in wei\n    function setTokenPrice(uint256 tokenID, uint256 price)\n        public\n        override (IOpenMarketable)\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _setTokenPrice(tokenID, price, address(this), Approve.All);\n    }\n\n    /// @notice SET token royalty info\n    /// @param tokenID : token ID\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10_000\n    function setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee)\n        public\n        override (IOpenMarketable)\n        existsToken(tokenID)\n        onlyOwner\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function getMintPrice() public view override (IOpenMarketable) returns (uint256) {\n        return _mintPrice;\n    }\n\n    function getTokenPrice(uint256 tokenID)\n        public\n        view\n        override (IOpenMarketable)\n        returns (uint256)\n    {\n        return _tokenPrice[tokenID];\n    }\n\n    /// @notice GET default royalty info\n    /// @return receiver : default royalty receiver infos\n    function getDefaultRoyalty()\n        public\n        view\n        override (IOpenMarketable)\n        returns (ReceiverInfos memory receiver)\n    {\n        receiver = _defaultRoyalty;\n    }\n\n    /// @notice GET token royalty info\n    /// @param tokenID : token ID\n    /// @return receiver :  token royalty receiver infos\n    function getTokenRoyalty(uint256 tokenID)\n        public\n        view\n        override (IOpenMarketable)\n        returns (ReceiverInfos memory receiver)\n    {\n        receiver = _tokenRoyalty[tokenID];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC721, OpenERC173, OpenERC2981)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenMarketable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(\n        uint256 mintPrice_,\n        address receiver_,\n        uint96 fee_,\n        address treasury_,\n        uint96 treasuryFee_,\n        bool minimal_\n    ) internal {\n        minimal = minimal_;\n        _mintPrice = mintPrice_;\n        _defaultRoyalty = _createReceiverInfos(receiver_, fee_);\n        _treasury = _createReceiverInfos(treasury_, treasuryFee_);\n    }\n\n    function _mint(address to, string memory tokenURI, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        _setTokenRoyalty(tokenID, _defaultRoyalty.account, _defaultRoyalty.fee);\n\n        if (to != owner()) _pay(tokenID, _mintPrice, to, owner());\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override (OpenERC721) {\n        delete _tokenRoyalty[tokenID];\n        delete _tokenPrice[tokenID];\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        virtual\n        override (OpenERC721)\n    {\n        /// Transfer: pay token price (including royalties) to previous token owner (and royalty receiver)\n        _pay(tokenID, _tokenPrice[tokenID], to, ownerOf(tokenID));\n\n        delete _tokenPrice[tokenID];\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _setDefaultRoyalty(address receiver, uint96 fee) internal lessThanMaxFee(fee) {\n        _defaultRoyalty = _createReceiverInfos(receiver, fee);\n\n        emit SetDefaultRoyalty(receiver, fee);\n    }\n\n    function _setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee)\n        internal\n        lessThanMaxFee(fee)\n    {\n        _tokenRoyalty[tokenID] = _createReceiverInfos(receiver, fee);\n\n        emit SetTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    /// @notice SET token price\n    /// @param tokenID : token ID\n    /// @param price : token price in wei\n    function _setTokenPrice(uint256 tokenID, uint256 price, address approved, Approve approveType)\n        internal\n        onlyTokenOwnerOrApproved(tokenID)\n        notTooExpensive(price)\n    {\n        _tokenPrice[tokenID] = price;\n\n        emit SetTokenPrice(tokenID, price);\n\n        if (approveType == Approve.All) {\n            setApprovalForAll(approved, true);\n        } else if (approveType == Approve.One) {\n            approve(approved, tokenID);\n        }\n    }\n\n    function _setMintPrice(uint256 price) internal notTooExpensive(price) {\n        _mintPrice = price;\n        _setDefaultRoyalty(_defaultRoyalty.account, _defaultRoyalty.fee);\n\n        emit SetMintPrice(price);\n    }\n\n    function _createReceiverInfos(address receiver, uint96 fee)\n        internal\n        view\n        returns (ReceiverInfos memory)\n    {\n        return ReceiverInfos(receiver, fee, minimal ? _calculateAmount(_mintPrice, fee) : 0);\n    }\n\n    function _transferValue(address to, uint256 value) private returns (uint256) {\n        bool success;\n        if (value > 0) {\n            (success,) = to.call{value: value, gas: 2300}(\"\");\n        }\n        return success ? value : 0;\n    }\n\n    function _pay(uint256 tokenID, uint256 price, address buyer, address seller)\n        private\n        reEntryGuard\n    {\n        require(msg.value >= price, \"Not enough funds\");\n        require(buyer != address(0), \"Invalid buyer\");\n        require(seller != address(0), \"Invalid seller\");\n\n        address receiver;\n        uint256 royalties;\n        uint256 fee;\n        uint256 paid;\n        uint256 unspent;\n\n        (receiver, royalties) = royaltyInfo(tokenID, price);\n        if (receiver == address(0)) royalties = 0;\n\n        if (price > 0 || royalties > 0) {\n            fee = _calculateAmount(price, _treasury.fee);\n            require(msg.value >= royalties + fee, \"Not enough funds\");\n\n            /// Transfer amount to be paid to seller\n            if (price > royalties + fee) {\n                paid = _transferValue(seller, price - (royalties + fee));\n            }\n\n            /// Transfer royalties to receiver\n            royalties = _transferValue(receiver, royalties);\n\n            /// Transfer fee to protocol treasury\n            fee = _transferValue(_treasury.account, fee);\n        }\n        unspent = msg.value - (paid + royalties + fee);\n\n        /// Transfer back unspent funds to buyer\n        unspent = _transferValue(buyer, unspent);\n\n        emit Pay(tokenID, price, seller, paid, receiver, royalties, fee, buyer, unspent);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-2981: NFT Royalty Standard\n// https://eips.ethereum.org/EIPS/eip-2981\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/common/ERC2981.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC2981  IERC2981  IOpenReceiverInfos\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\nabstract contract OpenERC2981 is IERC2981, IOpenReceiverInfos, OpenERC165 {\n    uint256 internal _mintPrice;\n    ReceiverInfos internal _defaultRoyalty;\n    mapping(uint256 => ReceiverInfos) internal _tokenRoyalty;\n\n    uint96 internal constant _MAX_FEE = 10_000;\n\n    modifier notTooExpensive(uint256 price) {\n        /// otherwise may overflow\n        require(price < 2 ** 128, \"Too expensive\");\n        _;\n    }\n\n    modifier lessThanMaxFee(uint256 fee) {\n        require(fee <= _MAX_FEE, \"Royalty fee exceed price\");\n        _;\n    }\n\n    function royaltyInfo(uint256 tokenID, uint256 price)\n        public\n        view\n        override (IERC2981)\n        notTooExpensive(price)\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        ReceiverInfos memory royalty = _tokenRoyalty[tokenID];\n\n        if (royalty.account == address(0)) {\n            royalty = _defaultRoyalty;\n        }\n\n        royaltyAmount = _calculateAmount(price, royalty.fee);\n\n        /// MINIMAL royaltyAmount\n        if (royalty.minimum > 0) {\n            /// with zero price, token owner can bypass royalties...\n            /// SO set a minimumRoyaltyAmount calculated on mintPrice (than can only be modified by collection owner)\n            /// BUT collection owner can higher too much mintPrice making fees too high\n            /// SO moreover store a minimumRoyaltyAmount per token defined during mint, or last transfer\n\n            /// MIN(royalty.minimum, defaultRoyaltyAmount)\n            uint256 defaultRoyaltyAmount = _calculateAmount(_mintPrice, royalty.fee);\n            uint256 minimumRoyaltyAmount =\n                royalty.minimum < defaultRoyaltyAmount ? royalty.minimum : defaultRoyaltyAmount;\n\n            /// MAX(normalRoyaltyAmount, minimumRoyaltyAmount)\n            royaltyAmount =\n                royaltyAmount < minimumRoyaltyAmount ? minimumRoyaltyAmount : royaltyAmount;\n        }\n\n        return (royalty.account, royaltyAmount);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\n    }\n\n    function _calculateAmount(uint256 price, uint96 fee) internal pure returns (uint256) {\n        return (price * fee) / _MAX_FEE;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenGuard\n//\npragma solidity 0.8.9;\n\nabstract contract OpenGuard {\n    bool private _locked;\n\n    modifier reEntryGuard() {\n        require(!_locked, \"No re-entry!\");\n\n        _locked = true;\n\n        _;\n\n        _locked = false;\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenMarketableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\nabstract contract OpenMarketableTest is Test, IOpenReceiverInfos {\n    address private _collection;\n    address private _owner = makeAddr(\"owner\");\n    address private _minter = makeAddr(\"minter\");\n    address private _tester = makeAddr(\"tester\");\n    uint256 private _tokenID0;\n    uint256 private _notTokenID = 42;\n\n    uint96 private _maxFee = 10_000;\n\n    // uint256 private maxPrice = uint256(((2**256) - 1)) / _maxFee;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setRoyaltyTest(address collection_, address receiver_, uint96 fee_)\n        public\n        virtual\n        returns (uint256 tokenID_);\n\n    function setUpMarketable() public {\n        _collection = constructorTest(_owner);\n\n        _tokenID0 = setRoyaltyTest(_collection, _owner, 420);\n    }\n\n    function testSetDefaultRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price < 2 ** 128);\n        vm.assume(fee < 10_000);\n\n        (uint256 tokenID,) = mintTest(_collection, _owner);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, price);\n        assertEq(receiver, _minter);\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testSetTokenRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price != 0);\n        vm.assume(price < 2 ** 128);\n        vm.assume(fee < 10_000);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _owner);\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(_tokenID0, price);\n        assertEq(receiver, _tester);\n        console.log(\"testSetTokenRoyalty ~ _maxFee\", _maxFee);\n        console.log(\"testSetTokenRoyalty ~ fee\", fee);\n        console.log(\"testSetTokenRoyalty ~ price\", price);\n        console.log(\"testSetTokenRoyalty ~ royalties\", royalties);\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testFailSetTokenRoyaltyNoToken() public {\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_notTokenID, _tester, 100);\n    }\n\n    function testSetTokenPrice(uint256 price) public {\n        vm.assume(price < 2 ** 128);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, price);\n        assertEq(IOpenMarketable(payable(_collection)).getTokenPrice(_tokenID0), price);\n    }\n\n    function testSetTokenPriceFromDefault(uint256 price) public {\n        vm.assume(price < 2 ** 128);\n\n        changePrank(_owner);\n        assertEq(IOpenMarketable(payable(_collection)).getTokenPrice(_tokenID0), 0);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n        assertEq(IOpenMarketable(payable(_collection)).getTokenPrice(_tokenID0), 1 ether);\n    }\n\n    function testFailSetMintPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2 ** 128);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setMintPrice(price);\n    }\n\n    function testFailSetTokenPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2 ** 128);\n\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, price);\n    }\n\n    function testFailSetTokenPriceNoToken() public {\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_notTokenID, 1 ether);\n    }\n\n    function testRoyaltyInfoCalculation(uint256 price, uint96 fee) public {\n        vm.assume(price < 2 ** 128);\n        vm.assume(fee < _maxFee);\n\n        (uint256 tokenID,) = mintTest(_collection, _owner);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, price);\n        assertEq(receiver, _minter);\n\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testRoyaltyInfoMinimal() public {\n        uint256 price = 1 ether;\n        uint96 fee = 100;\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setMintPrice(price);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (uint256 tokenID,) = mintTest(_collection, _owner);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, 0);\n        assertEq(receiver, _minter);\n\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testRoyaltyInfoMinimal(uint256 mintPrice, uint256 tokenPrice, uint96 fee) public {\n        vm.assume(mintPrice < 2 ** 128);\n        vm.assume(tokenPrice < 2 ** 128);\n        vm.assume(fee < _maxFee);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setMintPrice(mintPrice);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (uint256 tokenID,) = mintTest(_collection, _owner);\n\n        (address receiver, uint256 royalties) =\n            IERC2981(_collection).royaltyInfo(tokenID, tokenPrice);\n        assertEq(receiver, _minter);\n\n        uint256 maxPrice = mintPrice > tokenPrice ? mintPrice : tokenPrice;\n        assertEq(royalties, (maxPrice * fee) / _maxFee);\n    }\n\n    function testTokenOwner() public {\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n    }\n\n    function testFailTokenOwner() public {\n        /// must be collection owner\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n    }\n\n    function testFailSetTokenRoyaltyNotOwner() public {\n        changePrank(_tester);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n    }\n\n    function testFailSetTokenPriceNotOwner() public {\n        changePrank(_tester);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IOpenMarketable).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenNFTsSetupTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenNFTsSetupTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    string private _tokenURI0;\n    bool[] private _options = new bool[](2);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpOpenNFTsSetup() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, _tokenURI0) = mintTest(_collection, _minter);\n    }\n\n    function testContract() public {\n        assertEq(IERC721Metadata(_collection).name(), \"OpenERC721Test\");\n        assertEq(IERC721Metadata(_collection).symbol(), \"OPTEST\");\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testCount() public {\n        assertEq(IERC721(_collection).balanceOf(_minter), 1);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n    }\n\n    function testToken() public {\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n        assertEq(IERC721Metadata(_collection).tokenURI(_tokenID0), _tokenURI0);\n    }\n\n    function testPrice() public {\n        assertEq(IOpenMarketable(payable(_collection)).getTokenPrice(1), 0);\n    }\n\n    function testRoyalties() public {\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(1, 1);\n        assertEq(receiver, address(0));\n        assertEq(royalties, 0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenCloner/OpenCloner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-1167: Minimal Proxy Contract\n// https://eips.ethereum.org/EIPS/eip-1167\n//\n// Derived from OpenZeppelin Contracts (proxy/Clones.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/Clones.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//        |\n//   OpenCloner  IOpenCloner\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloner.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloner is IOpenCloner, OpenERC165 {\n    /// @notice Clone template (via EIP-1167)\n    /// @param  template_ : template address\n    /// @return clone_ : clone address\n    function clone(address template_) public virtual returns (address clone_) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, template_))\n            mstore(\n                add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            clone_ := create(0, ptr, 0x37)\n        }\n        assert(clone_ != address(0));\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenCloner).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenCloner {\n    function clone(address template) external returns (address);\n}\n"
    },
    "contracts/next/OpenNFTsFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       \n//       |        |            |\n//       |   OpenERC173    OpenCloner\n//       |    (ownable)        |\n//       |        |            |\n//       \n//       |\n// OpenNFTsFactoryV3  IOpenNFTsFactoryV3\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloner.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\nimport \"../interfaces/IOpenNFTsFactoryV3.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\nimport \"../interfaces/IOpenAutoMarket.sol\";\n\n/// @title OpenNFTsFactoryV3 smartcontract\n/// @notice Factory for NFTs contracts: ERC721 or ERC1155\n/// @notice Create new NFTs Collections smartcontracts by cloning templates\ncontract OpenNFTsFactoryV3 is IOpenNFTsFactoryV3, OpenERC173, OpenCloner {\n    /// @notice Named Templates\n\n    mapping(string => uint256) private _numTemplates;\n    address[] public templates;\n\n    address public nftsResolver;\n\n    address private _treasury;\n    uint96 private _treasuryFee;\n\n    constructor(\n        address initialOwner_,\n        address treasury_,\n        uint96 treasuryFee_\n    ) {\n        OpenERC173._transferOwnership(initialOwner_);\n        setTreasury(treasury_, treasuryFee_);\n    }\n\n    /// @notice clone template\n    /// @param name name of Clone collection\n    /// @param symbol symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bytes memory params\n    ) external override(IOpenNFTsFactoryV3) returns (address clone_) {\n        clone_ = clone(template(templateName));\n\n        IOpenCloneable(clone_).initialize(name, symbol, msg.sender, abi.encode(params, _treasury, _treasuryFee));\n\n        IOpenRegistry(nftsResolver).addAddress(clone_);\n\n        emit Clone(templateName, clone_, name, symbol);\n    }\n\n    function countTemplates() external view override(IOpenNFTsFactoryV3) returns (uint256 count) {\n        count = templates.length;\n    }\n\n    function setTreasury(address treasury_, uint96 treasuryFee_) public override(IOpenNFTsFactoryV3) onlyOwner {\n        _treasury = treasury_;\n        _treasuryFee = treasuryFee_;\n    }\n\n    function setResolver(address resolver_) public override(IOpenNFTsFactoryV3) onlyOwner {\n        nftsResolver = resolver_;\n\n        emit SetResolver(nftsResolver);\n    }\n\n    /// @notice Set Template by Name\n    /// @param templateName_ Name of the template\n    /// @param template_ Address of the template\n    function setTemplate(string memory templateName_, address template_) public override(IOpenNFTsFactoryV3) onlyOwner {\n        require(IERC165(template_).supportsInterface(type(IOpenCloneable).interfaceId), \"Not OpenCloneable\");\n        require(IOpenCloneable(template_).initialized(), \"Not initialized\");\n        require(template_.code.length != 45, \"Clone not valid template\");\n\n        uint256 num = _numTemplates[templateName_];\n        if (num >= 1) {\n            templates[num - 1] = template_;\n        } else {\n            templates.push(template_);\n            num = templates.length;\n\n            _numTemplates[templateName_] = num;\n        }\n\n        IOpenRegistry(nftsResolver).addAddress(template_);\n\n        emit SetTemplate(templateName_, template_, num);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC173, OpenCloner) returns (bool) {\n        return interfaceId == type(IOpenNFTsFactoryV3).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get Template\n    /// @param  templateName : template name\n    /// @return template_ : template address\n    function template(string memory templateName) public view override(IOpenNFTsFactoryV3) returns (address template_) {\n        uint256 num = _numTemplates[templateName];\n        require(num >= 1, \"Invalid Template\");\n\n        template_ = templates[num - 1];\n        require(template_ != address(0), \"No Template\");\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsFactoryV3/OpenNFTsFactoryV3Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenNFTsFactoryV3.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\nimport \"../../next/OpenNFTsV4.sol\";\nimport \"../../next/OpenAutoMarket.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"./OpenNFTsFactoryV3CloneTest.t.sol\";\n\ncontract OpenNFTsFactoryV3Test is ERC173Test, OpenNFTsFactoryV3CloneTest {\n    function constructorTest(address owner) public override(ERC173Test, OpenNFTsFactoryV3CloneTest) returns (address) {\n        changePrank(owner);\n\n        // FACTORY\n        OpenNFTsFactoryV3 factory = new OpenNFTsFactoryV3(owner, makeAddr(\"treasury\"), 90);\n\n        // RESOLVER\n        OpenNFTsResolver resolver = new OpenNFTsResolver(owner, address(factory));\n        factory.setResolver(address(resolver));\n\n        // OPEN_NFTS\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n        options[1] = false;\n\n        // TEMPLATE OpenNFTsV4\n        OpenNFTsV4 _openNFTsV4 = new OpenNFTsV4();\n        _openNFTsV4.initialize(\n            \"OpenNFTsV4 for OpenNFTsFactoryV3Test\",\n            \"OPTEST\",\n            owner,\n            abi.encode(abi.encode(0, address(0), 0, options), address(0), 0)\n        );\n        factory.setTemplate(\"OpenNFTsV4\", address(_openNFTsV4));\n\n        // TEMPLATE OpenAutoMarket\n        OpenAutoMarket _openAutoMarket = new OpenAutoMarket();\n        IOpenCloneable(_openAutoMarket).initialize(\n            \"OpenNFTsFactoryV3Test\",\n            \"OPTESTOPTEST\",\n            owner,\n            abi.encode(abi.encode(0, address(0), 0, options), address(0), 0)\n        );\n        factory.setTemplate(\"OpenAutoMarket\", address(_openAutoMarket));\n\n        return address(factory);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpOpenNFTsFactoryV3Clone();\n    }\n}\n"
    },
    "contracts/next/OpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       \n//       |                                    |            |\n//   OpenERC721                          OpenERC173  OpenCloneable\n//     (NFT)                              (ownable)        |\n//       |                                    |            |\n//                  |            |\n//       |                        |           |            |\n//  OpenERC721Metadata  OpenERC721Enumerable  |            |\n//       |                        |           |            |\n//       \n//       |\n//   OpenNFTsV4  IOpenNFTsV4\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsV4 is IOpenNFTsV4, OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable {\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function mint(string memory tokenURI_) external override(IOpenNFTsV4) returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, tokenURI_);\n    }\n\n    function mint(address minter, string memory tokenURI_)\n        external\n        override(IOpenNFTsV4)\n        onlyOwner\n        returns (uint256 tokenID)\n    {\n        tokenID = _mint(minter, tokenURI_);\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID) external override(IOpenNFTsV4) onlyTokenOwnerOrApproved(tokenID) {\n        _burn(tokenID);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public override(OpenCloneable) {\n        (bytes memory subparams_, , ) = abi.decode(params_, (bytes, address, uint96));\n\n        (, , , bool[] memory options_) = abi.decode(subparams_, (uint256, address, uint96, bool[]));\n        open = options_[0];\n\n        tokenIdNext = 1;\n\n        OpenCloneable._initialize(\"OpenNFTsV4\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTsV4).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address minter, string memory tokenURI) internal returns (uint256 tokenID) {\n        tokenID = tokenIdNext++;\n\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    function _mint(\n        address minter,\n        string memory tokenURI,\n        uint256 tokenID\n    ) internal override(OpenERC721Enumerable, OpenERC721Metadata) {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721Enumerable, OpenERC721Metadata) {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal override(OpenERC721, OpenERC721Enumerable) {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "contracts/next/OpenAutoMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       \n//       |                                                         |               |\n//   OpenERC721                                               OpenERC173     OpenCloneable\n//     (NFT)                                                   (ownable)           |\n//       |                                                         |               |\n//                            |\n//       |                        |                  |      |      |               |\n//  OpenERC721Metadata  OpenERC721Enumerable   OpenERC2981  |      |               |\n//       |                        |           (RoyaltyInfo) |      |               |\n//       |                        |                  |      |      |               |\n//       |                        |                        |               |\n//       |                        |                  |             |               |\n//       |                        |            OpenMarketable OpenPauseable        |\n//       |                        |                  |             |               |\n//       \n//       |\n//    OpenNFTs\n//       |\n//   OpenAutoMarket  IOpenAutoMarket\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol\";\nimport \"../interfaces/IOpenAutoMarket.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenAutoMarket is IOpenAutoMarket, OpenNFTs {\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() override(OpenNFTs) {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function gift(address to, uint256 tokenID) external payable override(IOpenAutoMarket) existsToken(tokenID) {\n        setTokenPrice(tokenID, 0);\n\n        safeTransferFrom(msg.sender, to, tokenID);\n    }\n\n    function buy(uint256 tokenID) external payable override(IOpenAutoMarket) existsToken(tokenID) {\n        /// Get token price\n        uint256 price = _tokenPrice[tokenID];\n\n        /// Require price defined\n        require(price > 0, \"Not to sell\");\n\n        /// Require enough value sent\n        require(msg.value >= price, \"Not enough funds\");\n\n        /// Get previous token owner\n        address from = ownerOf(tokenID);\n        assert(from != address(0));\n        require(from != msg.sender, \"Already token owner!\");\n\n        /// This AutoMarket approves msg.sender (requires AutoMarket isAprovedForAll)\n        this.approve(msg.sender, tokenID);\n\n        /// Transfer token\n        safeTransferFrom(from, msg.sender, tokenID);\n\n        /// Reset token price (to be eventualy defined by new owner)\n        delete _tokenPrice[tokenID];\n    }\n\n    function mint(string memory tokenURI) external override(IOpenAutoMarket) returns (uint256 tokenID) {\n        tokenID = mint(msg.sender, tokenURI, 0, address(0), 0);\n    }\n\n    function mint(\n        address minter_,\n        string memory tokenURI_,\n        uint256 tokenPrice_,\n        address receiver_,\n        uint96 receiverFee_\n    ) public payable override(IOpenAutoMarket) onlyMinter onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = OpenNFTs.mint(minter_, tokenURI_);\n\n        if (tokenPrice_ > 0) OpenMarketable._setTokenPrice(tokenID, tokenPrice_, address(this), Approve.All);\n        if (receiverFee_ > 0) OpenMarketable._setTokenRoyalty(tokenID, receiver_, receiverFee_);\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        bytes memory params_\n    ) public virtual override(OpenCloneable) {\n        (bytes memory subparams_, address treasury_, uint96 treasuryFee_) = abi.decode(\n            params_,\n            (bytes, address, uint96)\n        );\n\n        (uint256 mintPrice_, address receiver_, uint96 receiverFee_, bool[] memory options_) = abi.decode(\n            subparams_,\n            (uint256, address, uint96, bool[])\n        );\n        open = options_[0];\n\n        OpenNFTs._initialize(\n            name_,\n            symbol_,\n            owner_,\n            mintPrice_,\n            receiver_,\n            receiverFee_,\n            treasury_,\n            treasuryFee_,\n            options_[1]\n        );\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenNFTs) returns (bool) {\n        return interfaceId == type(IOpenAutoMarket).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsFactoryV3/OpenNFTsFactoryV3CloneTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenNFTsFactoryV3.sol\";\nimport \"../../next/OpenNFTsV4.sol\";\nimport \"../../next/OpenAutoMarket.sol\";\n\nabstract contract OpenNFTsFactoryV3CloneTest is Test, IOpenReceiverInfos {\n    address internal _factory;\n    address internal _template;\n    address internal _clone;\n    address internal _owner = address(0x1);\n    address internal _minter = address(0x12);\n    address internal _buyer = address(0x13);\n    address internal _tester = address(0x4);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsFactoryV3Clone() public {\n        _factory = constructorTest(_owner);\n    }\n\n    function testOpenNFTsFactoryV3CloneOpenNFTsV4() public {\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        _clone = OpenNFTsFactoryV3(_factory).clone(\n            \"NFT test\",\n            \"NFT\",\n            \"OpenNFTsV4\",\n            abi.encode(0, address(0), 0, options)\n        );\n\n        assertTrue(OpenNFTsV4(_clone).initialized());\n        assertEq(OpenNFTsV4(_clone).name(), \"NFT test\");\n    }\n\n    function testOpenNFTsFactoryV3CloneOpenAutoMarket() public {\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n        options[1] = false;\n\n        _clone = OpenNFTsFactoryV3(_factory).clone(\n            \"NFT test\",\n            \"NFT\",\n            \"OpenAutoMarket\",\n            abi.encode(42000000000, _tester, 420, options)\n        );\n        assertEq(OpenAutoMarket(payable(_clone)).name(), \"NFT test\");\n        assertEq(OpenAutoMarket(payable(_clone)).symbol(), \"NFT\");\n\n        assertEq(OpenAutoMarket(payable(_clone)).getMintPrice(), 42000000000);\n\n        ReceiverInfos memory receiver = OpenAutoMarket(payable(_clone)).getDefaultRoyalty();\n        assertEq(receiver.account, _tester);\n        assertEq(receiver.fee, 420);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4SupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenNFTsV4SupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Supports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, address(this));\n    }\n\n    function testOpenNFTsV4CheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenNFTsV4CheckSupportedInterfaces() public {\n        bytes4[9] memory ids = [\n            type(IOpenCloneable).interfaceId,\n            type(IOpenMarketable).interfaceId,\n            type(IOpenAutoMarket).interfaceId,\n            type(IOpenNFTs).interfaceId,\n            type(IOpenNFTsV4).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenChecker).interfaceId,\n            type(IERC721TokenReceiver).interfaceId,\n            0xffffffff\n        ];\n        bool[9] memory expected = [true, false, false, false, true, false, false, false, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](9);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            console.log(\"testOpenNFTsV4CheckSupportedInterfaces\", i);\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenNFTsV4.sol\";\n\nimport \"./OpenNFTsV4InitializeTest.t.sol\";\nimport \"./OpenNFTsV4SupportsTest.t.sol\";\nimport \"./OpenNFTsV4MintTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\n\ncontract OpenNFTsV4Test is\n    ERC721FullTest,\n    ERC173Test,\n    OpenNFTsV4InitializeTest,\n    OpenNFTsV4MintTest,\n    OpenNFTsV4SupportsTest\n{\n    function constructorTest(address owner)\n        public\n        override(ERC721FullTest, ERC173Test, OpenNFTsV4SupportsTest, OpenNFTsV4MintTest)\n        returns (address)\n    {\n        return constructorTest(owner, true);\n    }\n\n    function constructorTest(address owner, bool init) public override(OpenNFTsV4InitializeTest) returns (address) {\n        changePrank(owner);\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        OpenNFTsV4 collection = new OpenNFTsV4();\n        if (init) {\n            collection.initialize(\n                \"OpenNFTsV4Test\",\n                \"OPTEST\",\n                owner,\n                abi.encode(abi.encode(0, address(0), 0, options), address(0), 0)\n            );\n        }\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(ERC721FullTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV4(collection).mint(_TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(ERC721FullTest) {\n        console.log(\"burnTest ~ tokenID\", tokenID);\n        changePrank(OpenNFTsV4(collection).ownerOf(tokenID));\n        OpenNFTsV4(collection).burn(tokenID);\n    }\n\n    function setUp() public {\n        setUpERC721Full(\"OpenNFTsV4Test\", \"OPTEST\");\n        setUpERC173();\n        setUpOpenNFTsV4Initialize();\n        setUpOpenNFTsV4Mint();\n        setUpOpenNFTsV4Supports();\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4InitializeTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\n\nabstract contract OpenNFTsV4InitializeTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n    bytes private _optionsEncoded;\n\n    function constructorTest(address owner_, bool init_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Initialize() public {\n        _collection = constructorTest(_owner, false);\n\n        _options[0] = true;\n        _optionsEncoded = abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0);\n    }\n\n    function testInitializeName() public {\n        IOpenCloneable(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _optionsEncoded);\n        // assertEq(IERC721Metadata(_collection).name(), \"OpenNFTsV4InitializeTest\");\n    }\n\n    function testInitializeSymbol() public {\n        IOpenCloneable(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _optionsEncoded);\n        assertEq(IERC721Metadata(_collection).symbol(), \"TEST\");\n    }\n\n    function testInitializeOwner() public {\n        IOpenCloneable(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _optionsEncoded);\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testInitializeOpen() public {\n        IOpenCloneable(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _optionsEncoded);\n        assertEq(IOpenNFTsV4(_collection).open(), true);\n    }\n\n    function testInitializeNotOpen() public {\n        _options[0] = false;\n        IOpenCloneable(_collection).initialize(\n            \"OpenNFTsV4InitializeTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        assertEq(IOpenNFTsV4(_collection).open(), false);\n    }\n\n    function testFailInitializeTwice() public {\n        IOpenCloneable(_collection).initialize(\"OpenNFTsV4InitializeTest\", \"TEST\", _owner, _optionsEncoded);\n        IOpenCloneable(_collection).initialize(\"OpenNFTsOldTestTwice\", \"OPTEST2\", _tester, _optionsEncoded);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4MintTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\n\nabstract contract OpenNFTsV4MintTest is Test {\n    string private constant _TOKEN_URI = \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Mint() public {\n        _collection = constructorTest(_owner);\n        changePrank(_minter);\n    }\n\n    function testOpenNFTsV4Mint1() public {\n        IOpenNFTsV4(_collection).mint(_TOKEN_URI);\n    }\n\n    function testOpenNFTsV4Mint5() public {\n        IOpenNFTsV4(_collection).mint(_minter, _TOKEN_URI);\n    }\n\n    function testOpenNFTsV4Mint2() public {\n        IOpenNFTs(_collection).mint(_minter, _TOKEN_URI);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721TokenReceiver.sol\";\n\nabstract contract ERC721TransferableTest is Test, IERC721Events {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setUpERC721Transferable() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721SafeTransferFrom() public {\n        changePrank(_minter);\n\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721SafeTransferFromWithData() public {\n        changePrank(_minter);\n\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721SafeTransferFromEmit() public {\n        changePrank(_minter);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(_minter, _tester, _tokenID0);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testERC721SafeTransferFromWithDataEmit() public {\n        changePrank(_minter);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(_minter, _tester, _tokenID0);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n    }\n\n    function testERC721SafeTransferFromEOAFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, tokenID);\n        IERC721(_collection).safeTransferFrom(from, to, tokenID);\n        assertEq(IERC721(_collection).ownerOf(tokenID), to);\n    }\n\n    function testERC721TransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n\n        IERC721(_collection).transferFrom(_minter, address(_collection), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(_collection));\n    }\n\n    function testERC721TransferFrom() public {\n        changePrank(_minter);\n\n        IERC721(_collection).transferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721TransferFromEOAFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID,) = mintTest(_collection, from);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, tokenID);\n        IERC721(_collection).transferFrom(from, to, tokenID);\n        assertEq(IERC721(_collection).ownerOf(tokenID), to);\n    }\n\n    function testERC721transferFromToContract() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, address(this), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(this));\n    }\n\n    function testFailERC721SafeTransferFromToNotReceiverContract() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(this), _tokenID0);\n    }\n\n    function testERC721SafeTransferFromToReceiverContract() public {\n        OpenERC721TokenReceiver receiverContract = new OpenERC721TokenReceiver();\n\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(receiverContract), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(receiverContract));\n    }\n\n    function testERC721Approve() public {\n        changePrank(_minter);\n        vm.expectEmit(true, true, true, false);\n        emit Approval(_minter, _tester, _tokenID0);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n    }\n\n    function testERC721SetApprovalForAll() public {\n        changePrank(_minter);\n        vm.expectEmit(true, true, true, false);\n        emit ApprovalForAll(_minter, _tester, true);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n    }\n\n    function testFailERC721TransferFromToZeroAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(0), _tokenID0);\n    }\n\n    function testFailERC721TransferFromFromZeroAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(address(0), _tester, _tokenID0);\n    }\n\n    function testERC721TransferFromToSameAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721TokenReceiver  IERC721TokenReceiver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\ncontract OpenERC721TokenReceiver is IERC721TokenReceiver, OpenERC721 {\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        virtual\n        override (IERC721TokenReceiver)\n        returns (bytes4)\n    {\n        return OpenERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenAutoMarket.sol\";\n\nimport \"./OpenAutoMarketInitializeTest.t.sol\";\nimport \"./OpenAutoMarketSupportsTest.t.sol\";\nimport \"./OpenAutoMarketBuyTest.t.sol\";\nimport \"./OpenAutoMarketMintTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC2981Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsSetupTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenMarketableTest.t.sol\";\n\ncontract OpenAutoMarketTest is\n    ERC721TransferableTest,\n    ERC173Test,\n    ERC2981Test,\n    OpenAutoMarketInitializeTest,\n    OpenAutoMarketSupportsTest,\n    OpenAutoMarketBuyTest,\n    OpenAutoMarketMintTest,\n    OpenNFTsTest,\n    OpenNFTsBurnTest,\n    OpenNFTsSetupTest,\n    OpenPauseableTest,\n    OpenMarketableTest\n{\n    uint256 internal nn = 42;\n\n    function constructorTest(address owner)\n        public\n        override(\n            ERC721TransferableTest,\n            ERC173Test,\n            ERC2981Test,\n            OpenNFTsTest,\n            OpenAutoMarketSupportsTest,\n            OpenAutoMarketBuyTest,\n            OpenAutoMarketMintTest,\n            OpenNFTsBurnTest,\n            OpenNFTsSetupTest,\n            OpenPauseableTest,\n            OpenMarketableTest\n        )\n        returns (address)\n    {\n        return constructorTest(owner, true);\n    }\n\n    function constructorTest(address owner, bool init) public override(OpenAutoMarketInitializeTest) returns (address) {\n        changePrank(owner);\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n        options[1] = true;\n\n        OpenAutoMarket collection = new OpenAutoMarket();\n        if (init) {\n            IOpenCloneable(collection).initialize(\n                \"OpenERC721Test\",\n                \"OPTEST\",\n                owner,\n                abi.encode(abi.encode(0, address(0), 0, options), makeAddr(\"treasury\"), 90)\n            );\n        }\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(\n            OpenAutoMarketBuyTest,\n            OpenNFTsTest,\n            OpenNFTsBurnTest,\n            OpenNFTsSetupTest,\n            ERC2981Test,\n            OpenPauseableTest,\n            OpenMarketableTest,\n            ERC721TransferableTest\n        )\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenAutoMarket(payable(collection)).mint(_TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(OpenNFTsTest, OpenNFTsBurnTest) {\n        changePrank(OpenAutoMarket(payable(collection)).ownerOf(tokenID));\n        OpenAutoMarket(payable(collection)).burn(tokenID);\n    }\n\n    function setPriceTest(\n        address collection,\n        uint256 tokenID,\n        uint256 price\n    ) public {\n        // changePrank(OpenAutoMarket(payable(collection)).ownerOf(tokenID));\n        OpenAutoMarket(payable(collection)).setTokenPrice(tokenID, price);\n    }\n\n    function setRoyaltyTest(\n        address collection,\n        address receiver,\n        uint96 fee\n    ) public override(ERC2981Test, OpenMarketableTest) returns (uint256 tokenID) {\n        changePrank(OpenAutoMarket(payable(collection)).owner());\n        (tokenID, ) = (OpenAutoMarket(payable(collection)).mint(_TOKEN_URI), _TOKEN_URI);\n        OpenAutoMarket(payable(collection)).setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpERC2981();\n        setUpPausable();\n        setUpMarketable();\n        setUpOpenNFTs(\"OpenERC721Test\", \"OPTEST\");\n        setUpERC721Transferable();\n        setUpOpenNFTsBurn();\n        setUpOpenNFTsBuy();\n        setUpOpenNFTsMint();\n        setUpOpenNFTsSetup();\n        setUpOpenAutoMarketInitialize();\n        setUpOpenAutoMarketSupports();\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketInitializeTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\n\nabstract contract OpenAutoMarketInitializeTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](2);\n\n    function constructorTest(address owner_, bool init_) public virtual returns (address);\n\n    function setUpOpenAutoMarketInitialize() public {\n        _collection = constructorTest(_owner, false);\n\n        _options[0] = true;\n        _options[1] = false;\n    }\n\n    function testInitializeName() public {\n        IOpenCloneable(_collection).initialize(\n            \"OpenAutoMarketTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        assertEq(IERC721Metadata(_collection).name(), \"OpenAutoMarketTest\");\n    }\n\n    function testInitializeSymbol() public {\n        IOpenCloneable(_collection).initialize(\n            \"OpenAutoMarketTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        assertEq(IERC721Metadata(_collection).symbol(), \"TEST\");\n    }\n\n    function testInitializeOwner() public {\n        IOpenCloneable(_collection).initialize(\n            \"OpenAutoMarketTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testInitializeOpen() public {\n        IOpenCloneable(_collection).initialize(\n            \"OpenAutoMarketTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        assertEq(IOpenAutoMarket(_collection).open(), true);\n    }\n\n    function testInitializeNotOpen() public {\n        _options[0] = false;\n        IOpenCloneable(_collection).initialize(\n            \"OpenAutoMarketTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        assertEq(IOpenAutoMarket(_collection).open(), false);\n    }\n\n    function testFailInitializeTwice() public {\n        IOpenCloneable(_collection).initialize(\n            \"OpenAutoMarketTest\",\n            \"TEST\",\n            _owner,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n        IOpenCloneable(_collection).initialize(\n            \"OpenNFTsOldTestTwice\",\n            \"OPTEST2\",\n            _tester,\n            abi.encode(abi.encode(0, address(0), 0, _options), address(0), 0)\n        );\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketSupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\nimport \"../../next/OpenNFTsResolver.sol\";\n\nabstract contract OpenAutoMarketSupportsTest is Test {\n    OpenNFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenAutoMarketSupports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenNFTsResolver(_owner, address(this));\n    }\n\n    function testOpenAutoMarketCheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, true];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenAutoMarketCheckSupportedInterfaces() public {\n        bytes4[9] memory ids = [\n            type(IOpenCloneable).interfaceId,\n            type(IOpenMarketable).interfaceId,\n            type(IOpenAutoMarket).interfaceId,\n            type(IOpenNFTs).interfaceId,\n            type(IOpenAutoMarket).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenChecker).interfaceId,\n            type(IERC721TokenReceiver).interfaceId,\n            0xffffffff\n        ];\n        bool[9] memory expected = [true, true, true, true, true, true, false, false, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](9);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            console.log(\"testOpenAutoMarketCheckErcInterfaces ~ i\", i);\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketBuyTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\n\nabstract contract OpenAutoMarketBuyTest is Test {\n    address payable private _collection;\n    address private _owner = makeAddr(\"owner\");\n    address private _buyer = makeAddr(\"buyer\");\n    address private _tester = makeAddr(\"tester\");\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpOpenNFTsBuy() public {\n        _collection = payable(constructorTest(_owner));\n\n        (_tokenID0, ) = mintTest(_collection, _owner);\n    }\n\n    function testBuyOk() public {\n\n        changePrank(_owner);\n        IERC721(_collection).setApprovalForAll(_collection, true);\n\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _owner);\n        IOpenAutoMarket(_collection).buy{value: 1.5 ether}(_tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n\n        assertEq(_buyer.balance, 9 ether);\n        assertEq(_collection.balance, 0 ether);\n        assertEq(_tester.balance, 0.01 ether);\n        assertEq(_owner.balance,  0.981 ether);\n        assertEq(makeAddr(\"treasury\").balance,  0.009 ether);\n    }\n\n    function testFailBuyTwice() public {\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        IOpenAutoMarket(_collection).buy{value: 1 ether}(_tokenID0);\n        IOpenAutoMarket(_collection).buy{value: 1 ether}(_tokenID0);\n    }\n\n    function testFailBuyNotEnoughFunds() public {\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        IOpenAutoMarket(_collection).buy{value: 0.5 ether}(_tokenID0);\n    }\n\n    function testFailBuyNotToSell() public {\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 0);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _owner);\n        IOpenAutoMarket(_collection).buy{value: 1 ether}(_tokenID0);\n    }\n}\n"
    },
    "contracts/tests/OpenAutoMarket/OpenAutoMarketMintTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenAutoMarket.sol\";\n\nabstract contract OpenAutoMarketMintTest is Test {\n    string private constant _TOKEN_URI = \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n\n    address payable private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsMint() public {\n        _collection = payable(constructorTest(_owner));\n        changePrank(_minter);\n    }\n\n    function testOpenAutoMarketMint1() public {\n        IOpenAutoMarket(_collection).mint(_TOKEN_URI);\n    }\n\n    function testOpenAutoMarketMint5() public {\n        changePrank(_minter);\n        IOpenAutoMarket(_collection).mint(_minter, _TOKEN_URI, 10000, address(_minter), 100);\n    }\n\n    function testOpenAutoMarketMint2() public {\n        IOpenNFTs(_collection).mint(_minter, _TOKEN_URI);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenNFTsBurnTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    uint256 randNonce;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpOpenNFTsBurn() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0,) = mintTest(_collection, _minter);\n    }\n\n    function testBurn() public {\n        burnTest(_collection, _tokenID0);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 0);\n    }\n\n    function testBurnWithEnumerable() public {}\n\n    function testBurnWithMetadata() public {}\n\n    function testFailBurnTokenByIndex() public {\n        burnTest(_collection, _tokenID0);\n        IERC721Enumerable(_collection).tokenByIndex(0);\n    }\n\n    function testFailBurnTokenOfOwnerByIndex() public {\n        burnTest(_collection, _tokenID0);\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0);\n    }\n\n    function testBurnSecondOne() public {\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 2);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(1), tokenID);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0), tokenID);\n\n        burnTest(_collection, tokenID);\n\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n    }\n\n    function testFailBurnSecondOneTokenByIndex() public {\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        burnTest(_collection, tokenID);\n        IERC721Enumerable(_collection).tokenByIndex(1);\n    }\n\n    function testFailBurnSecondOneTokennOfOwnerByIndex() public {\n        changePrank(_tester);\n        (uint256 tokenID,) = mintTest(_collection, _tester);\n        burnTest(_collection, tokenID);\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0);\n    }\n\n    function testBurnEnumerable() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        burnTest(_collection, _tokenID0);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 0);\n    }\n\n    function testBurnERC721EnumerableShuffleUp(uint160 rnd) public {\n        burnTest(_collection, _tokenID0);\n\n        uint160 first = 2 ** 100;\n        uint160 total = 20;\n        uint256 totalSupply;\n\n        for (uint160 index = 1; index <= total; index++) {\n            address address1 = address(first + (random(rnd) % index));\n            address address2 = address(first + (random(rnd) % index));\n            uint256 rand3 = (random(rnd) % index);\n\n            mintTest(_collection, address1);\n            mintTest(_collection, address2);\n\n            uint256 randomTokenID1 = IERC721Enumerable(_collection).tokenByIndex(rand3);\n            address owner1 = IERC721(_collection).ownerOf(randomTokenID1);\n            changePrank(owner1);\n            IERC721(_collection).transferFrom(owner1, address2, randomTokenID1);\n\n            uint256 randomTokenID2 = IERC721Enumerable(_collection).tokenByIndex(uint256(rand3));\n            burnTest(_collection, randomTokenID2);\n\n            assertEq(IERC721Enumerable(_collection).totalSupply(), index);\n        }\n        assertEq(IERC721Enumerable(_collection).totalSupply(), total);\n\n        for (uint160 index = 1; index <= total; index++) {\n            totalSupply += IERC721(_collection).balanceOf(address(first + index - 1));\n        }\n        assertEq(totalSupply, total);\n    }\n\n    function random(uint160 rnd) public returns (uint160) {\n        randNonce++;\n        return uint160(uint256(keccak256(abi.encodePacked(msg.sender, randNonce, rnd))));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC2981Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract ERC2981Test is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address contract_);\n\n    function mintTest(address collection_, address minter_)\n        public\n        virtual\n        returns (uint256, string memory);\n\n    function setRoyaltyTest(address collection_, address receiver_, uint96 fee_)\n        public\n        virtual\n        returns (uint256 tokenID_);\n\n    function setUpERC2981() public {\n        _collection = constructorTest(_owner);\n\n        _tokenID0 = setRoyaltyTest(_collection, _minter, 420);\n    }\n\n    function testERC2981RoyaltyInfo(uint256 price) public {\n        vm.assume(price < 2 ** 128);\n        (address receiver, uint256 royalty) = IERC2981(_collection).royaltyInfo(_tokenID0, price);\n\n        assertEq(receiver, _minter);\n        assertEq(royalty, (price * 420) / 10_000);\n    }\n\n    function testFailERC2981RoyaltyInfoTooExpensive(uint256 price) public {\n        vm.assume(price >= 2 ** 128);\n        IERC2981(_collection).royaltyInfo(_tokenID0, price);\n    }\n\n    function testERC2981SupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC2981).interfaceId));\n    }\n}\n"
    },
    "contracts/dev/InterfacesIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport \"../interfaces/IOpenNFTsV0.sol\";\nimport \"../interfaces/IOpenNFTsV1.sol\";\nimport \"../interfaces/IOpenNFTsV2.sol\";\nimport \"../interfaces/IOpenNFTsV3.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\nimport \"../interfaces/IOpenAutoMarket.sol\";\nimport \"../interfaces/IOpenBound.sol\";\n\nimport \"../interfaces/ICloneFactoryV2.sol\";\nimport \"../interfaces/INFTsFactoryV2.sol\";\nimport \"../interfaces/IOpenNFTsFactoryV3.sol\";\n\nimport \"../interfaces/IOpenNFTsResolver.sol\";\n\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\nimport \"../interfaces/IOpenNFTsV3Plus.sol\";\n\nimport \"../interfaces/IInterfacesIds.sol\";\n\n/// @title InterfaceIds calculation\n/// @author zapaz.eth\n/// @notice Calculates various ERC165, ERC721 and ERC1155 interface Ids\n///  @notice and Kredeum OpenNFTs interface Ids\ncontract InterfacesIds is IInterfacesIds {\n    /// @notice Main and only function to calculate Interface Ids\n    /// @notice No params\n    /// @return interfacesIds : Array of all interfaceIds\n    function ids() external pure override(IInterfacesIds) returns (bytes4[] memory interfacesIds) {\n        uint256 i;\n        uint256 imax = 28;\n\n        interfacesIds = new bytes4[](imax);\n\n        interfacesIds[i++] = bytes4(0x01ffc9a7); // IERC165\n\n        interfacesIds[i++] = bytes4(0x80ac58cd); // IERC721\n        interfacesIds[i++] = bytes4(0x780e9d63); // IERC721Enumerable\n        interfacesIds[i++] = bytes4(0x5b5e139f); // IERC721Metadata\n        interfacesIds[i++] = bytes4(0x150b7a02); // IERC721TokenReceiver\n\n        interfacesIds[i++] = bytes4(0xd9b67a26); // IERC1155\n        interfacesIds[i++] = bytes4(0x0e89341c); // IERC1155MetadataURI\n        interfacesIds[i++] = bytes4(0x4e2312e0); // IERC1155TokenReceiver\n\n        interfacesIds[i++] = bytes4(0x7f5828d0); // IERC173\n        interfacesIds[i++] = bytes4(0x2a55205a); // IERC2981\n\n        interfacesIds[i++] = type(IOpenNFTs).interfaceId;\n        interfacesIds[i++] = type(IOpenChecker).interfaceId;\n        interfacesIds[i++] = type(IOpenCloneable).interfaceId;\n        interfacesIds[i++] = type(IOpenMarketable).interfaceId;\n        interfacesIds[i++] = type(IOpenPauseable).interfaceId;\n\n        interfacesIds[i++] = bytes4(0x4b68d431); // IOpenNFTsV0\n        interfacesIds[i++] = bytes4(0xeacabe14); // IOpenNFTsV1\n        interfacesIds[i++] = bytes4(0xd94a1db2); // IOpenNFTsV2\n        interfacesIds[i++] = bytes4(0x5c838d8b); // IOpenNFTsV3\n        interfacesIds[i++] = type(IOpenNFTsV4).interfaceId;\n        interfacesIds[i++] = type(IOpenAutoMarket).interfaceId;\n        interfacesIds[i++] = type(IOpenBound).interfaceId;\n\n        interfacesIds[i++] = bytes4(0xcfc6c434); // ICloneFactoryV2\n        interfacesIds[i++] = bytes4(0x78f5e5c2); // INFTsFactoryV2\n        interfacesIds[i++] = type(IOpenNFTsFactoryV3).interfaceId; // IOpenNFTsFactoryV3\n\n        interfacesIds[i++] = bytes4(0x03dc8d64); // IOpenNFTsOld\n        interfacesIds[i++] = bytes4(0x5f5f00ef); // IOpenNFTsV3Plus\n\n        interfacesIds[i++] = type(IInterfacesIds).interfaceId;\n\n        assert(i == imax);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV3Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV3Plus {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IInterfacesIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IInterfacesIds {\n    function ids() external pure returns (bytes4[] memory interfacesIds);\n}\n"
    },
    "contracts/dev/OpenERC721EnumerableOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/extensions/ERC721Enumerable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/...\n// ...contracts/token/ERC721/extensions/ERC721Enumerable.sol\n\n//\n//                OpenERC165\n//                     |\n//                OpenERC721\n//                     |\n//            OpenERC721EnumerableOz\n//\n\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenERC721EnumerableOz is IERC721Enumerable, OpenERC721 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC721) returns (bool) {\n        return interfaceId == 0x780e9d63 || super.supportsInterface(interfaceId);\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < OpenERC721.balanceOf(owner), \"Invalid index!\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view override(IERC721Enumerable) returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view override(IERC721Enumerable) returns (uint256) {\n        require(index < OpenERC721EnumerableOz.totalSupply(), \"Invalid index!\");\n        return _allTokens[index];\n    }\n\n    function _mintEnumerable(address to, uint256 tokenID) internal {\n        uint256 length = OpenERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenID;\n        _ownedTokensIndex[tokenID] = length;\n\n        _allTokensIndex[tokenID] = _allTokens.length;\n        _allTokens.push(tokenID);\n    }\n\n    function _burnEnumerable(uint256 tokenID) internal {\n        _removeTokenFromOwnerEnumeration(ownerOf(tokenID), tokenID);\n        _removeTokenFromAllTokensEnumeration(tokenID);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenID) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = OpenERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenID];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenID];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenID) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenID];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenID];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/dev/OpenProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC4973.sol\";\nimport \"../interfaces/IOpenProof.sol\";\n\n/// @title OpenProof smartcontract\ncontract OpenProof is\n    IOpenProof,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    OwnableUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    event Attest(address indexed to, uint256 indexed tokenId);\n\n    /// @notice onlyMinter, only collection owner can mint\n    modifier onlyMinter() {\n        require((owner() == _msgSender()), \"Not minter\");\n        _;\n    }\n\n    /// @notice initialize\n    /// @param name name of the NFT Collection\n    /// @param symbol symbol of the NFT Collection\n    /// @param owner owner of the NFT Collection\n    // solhint-disable-next-line comprehensive-interface\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner\n    ) external initializer {\n        __Ownable_init();\n        __ERC721_init(name, symbol);\n        transferOwnership(owner);\n    }\n\n    /// @notice mint\n    /// @param to address that will own the NFT minted\n    /// @param jsonURI json URI of NFT metadata\n    function mintOpenProof(address to, string memory jsonURI)\n        external\n        override(IOpenProof)\n        onlyMinter\n        returns (uint256 tokenId)\n    {\n        _tokenIds.increment();\n\n        tokenId = _tokenIds.current();\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, jsonURI);\n    }\n\n    /// @notice Get tokenURI\n    /// @param tokenId tokenId of NFT\n    /// @param tokenURI_ token URI of NFT\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory tokenURI_)\n    {\n        tokenURI_ = super.tokenURI(tokenId);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC4973).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _afterTokenTransfer(\n        address, // from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721Upgradeable) {\n        emit Attest(to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address, // to,\n        uint256 // tokenId\n    ) internal pure override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        require(from == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "contracts/interfaces/IOpenProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenProof {\n    function mintOpenProof(address minter, string memory jsonURI) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/dev/OpenBound4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/IOpenBound4973.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC4973.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\n\n/// @title OpenBound smartcontract\ncontract OpenBound4973 is IOpenBound4973, IERC4973, IERC173, IERC721Enumerable, IERC721Metadata {\n    address public owner;\n\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping(uint256 => address) internal _owners;\n    mapping(address => uint256[]) internal _tokensOfOwner;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    modifier onlyOwner() {\n        require((owner == msg.sender), \"Not owner\");\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external override(IERC173) {\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function ownerOf(uint256 tokenID) external view override(IERC4973) returns (address nftOwner) {\n        nftOwner = _owners[tokenID];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256 tokenID) {\n        require(index < _tokens.length, \"Invalid index\");\n        tokenID = _tokens[index];\n        // require(_exists(tokenID), \"NFT doesn't exists\");\n    }\n\n    function tokenOfOwnerByIndex(address addr, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256 tokenID)\n    {\n        require(index < _tokens.length, \"Invalid index\");\n        tokenID = _tokensOfOwner[addr][index];\n        // require(_exists(tokenID), \"NFT doesn't exists\");\n    }\n\n    function mint(uint256 tokenID) public override(IOpenBound4973) {\n        _mint(msg.sender, tokenID);\n    }\n\n    function mint(address addr, uint256 tokenID) public override(IOpenBound4973) onlyOwner {\n        _mint(addr, tokenID);\n    }\n\n    // function burn(uint256 tokenID) public override(IERC4973) {\n    //     require(_exists(tokenID), \"NFT does not exists\");\n    //     totalSupply -= 1;\n    //     _owners[tokenID] = address(0);\n    //     emit Revoke(address(0), tokenID);\n    // }\n\n    function tokenURI(uint256 tokenId) public view override(IERC721Metadata) returns (string memory) {\n        require(_exists(tokenId), \"NFT doesn't exists\");\n\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(tokenId)));\n    }\n\n    function _mint(address addr, uint256 tokenID) internal {\n        require(!_exists(tokenID), \"NFT already exists\");\n        totalSupply += 1;\n        _owners[tokenID] = addr;\n        _tokens.push(tokenID);\n        _tokensOfOwner[addr].push(tokenID);\n        emit Attest(addr, tokenID);\n    }\n\n    function _exists(uint256 tokenID) internal view returns (bool) {\n        return _owners[tokenID] != address(0);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenBound4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenBound4973 {\n    function mint(uint256 tokenID) external;\n\n    function mint(address addr, uint256 tokenID) external;\n}\n"
    },
    "contracts/dev/OpenBoundOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\nimport \"../interfaces/IOpenBoundOz.sol\";\n\n/// @title OpenBound smartcontract\n// contract OpenBound is ERC721, IOpenBoundOz, IERC173, IERC721Enumerable, IERC721Metadata {\ncontract OpenBoundOz is ERC721, IOpenBoundOz, IERC721Enumerable, IOpenPauseable, Ownable {\n    uint256 public maxSupply;\n\n    bool public paused;\n\n    mapping(address => uint256) internal _tokenOfOwner;\n    mapping(address => uint256) internal _tokenIndexOfOwner;\n    mapping(uint256 => uint256) internal _cidOfToken;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    modifier whenNotPaused() {\n        require(!paused, \"Paused !\");\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 maxSupply_\n    ) ERC721(name, symbol) {\n        maxSupply = maxSupply_;\n    }\n\n    function togglePause() external override(IOpenPauseable) onlyOwner {\n        paused = !paused;\n        emit SetPaused(paused, msg.sender);\n    }\n\n    function burn(uint256 tokenID) external override(IOpenBoundOz) {\n        address owner = ownerOf(tokenID);\n        require(owner == msg.sender, \"Not owner\");\n\n        uint256 index = _tokenIndexOfOwner[owner];\n        uint256 lastIndex = _tokens.length - 1;\n\n        _burn(tokenID);\n\n        if (index != lastIndex) {\n            _tokens[index] = _tokens[lastIndex];\n            _tokenIndexOfOwner[ownerOf(_tokens[lastIndex])] = index;\n        }\n        _tokens.pop();\n\n        delete _cidOfToken[tokenID];\n        delete _tokenIndexOfOwner[owner];\n        delete _tokenOfOwner[owner];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256) {\n        require(index < _tokens.length, \"Invalid index\");\n\n        return _tokens[index];\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index == 0 && balanceOf(owner) == 1, \"Invalid index\");\n\n        return _tokenOfOwner[owner];\n    }\n\n    function mint(uint256 cid) public override(IOpenBoundOz) whenNotPaused returns (uint256) {\n        require((maxSupply == 0) || totalSupply() < maxSupply, \"Max supply reached\");\n        require(balanceOf(msg.sender) == 0, \"Already minted or claimed\");\n\n        uint256 tokenID = getMyTokenID(cid);\n\n        _tokens.push(tokenID);\n        _tokenOfOwner[msg.sender] = tokenID;\n        _tokenIndexOfOwner[msg.sender] = _tokens.length - 1;\n        _cidOfToken[tokenID] = cid;\n\n        _mint(msg.sender, tokenID);\n\n        return tokenID;\n    }\n\n    function claim(uint256 tokenID, uint256 cid) public override(IOpenBoundOz) whenNotPaused {\n        require(tokenID == getMyTokenID(cid), \"Not owner\");\n        mint(cid);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721) returns (bool) {\n        return\n            interfaceId == type(IOpenBoundOz).interfaceId ||\n            interfaceId == type(IOpenPauseable).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function getMyTokenID(uint256 cid) public view override(IOpenBoundOz) returns (uint256) {\n        return getTokenID(cid, msg.sender);\n    }\n\n    function getCID(uint256 tokenID) public view override(IOpenBoundOz) returns (uint256) {\n        return _cidOfToken[tokenID];\n    }\n\n    function totalSupply() public view override(IERC721Enumerable) returns (uint256) {\n        return _tokens.length;\n    }\n\n    function tokenURI(uint256 tokenID) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenID), \"NFT doesn't exists\");\n\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(getCID(tokenID))));\n    }\n\n    function getTokenID(uint256 cid, address addr) public pure override(IOpenBoundOz) returns (uint256) {\n        return _tokenID(cid, addr);\n    }\n\n    function _tokenID(uint256 cid, address addr) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(cid, addr)));\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 // tokenId\n    ) internal pure override(ERC721) {\n        require(from == address(0) || to == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "contracts/interfaces/IOpenBoundOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenBoundOz {\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n\n    function getTokenID(uint256 cid, address addr) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ITest {\n    function setUp() external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}