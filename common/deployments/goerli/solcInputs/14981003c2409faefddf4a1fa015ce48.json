{
  "language": "Solidity",
  "sources": {
    "contracts/CloneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/ICloneFactory.sol\";\nimport \"./interfaces/IContractProbe.sol\";\n\n/// @title Clone Factory\n/// @notice Generic Clone Factory to create multiple Clones from Templates\n/// @dev CloneFactory is ICloneFactory and Ownable\ncontract CloneFactory is ICloneFactory, Ownable {\n    /// @notice Current Template used for cloning\n    /// @return template address\n    address public template;\n\n    /// @notice External Probe smartcontract used for clone probing\n    /// @return contractProbe address\n    address public contractProbe;\n\n    /// @notice Get implementation\n    /// @return implementation address\n    address[] public implementations;\n\n    /// @notice Map each Implementation with \"parent\" Template\n    /// @return templates mapping\n    mapping(address => address) public templates;\n\n    /// @notice New Implemention Event\n    /// @dev if implementation equal template\n    /// @dev then implementation is Template else Clone\n    /// @param implementation implementation address\n    /// @param template template address\n    /// @param creator creator address\n    event NewImplementation(address indexed implementation, address indexed template, address indexed creator);\n\n    /// @notice New Template Event\n    /// @param template template address\n    /// @param creator creator address\n    event NewTemplate(address indexed template, address indexed creator);\n\n    /// @notice SET contractProbe Address\n    /// @param  addr : contractProbe smartcontract address\n    function setContractProbe(address addr) external override(ICloneFactory) onlyOwner {\n        contractProbe = addr;\n    }\n\n    /// @notice Add Implementation - restricted to onlyOwner\n    /// @param  addr : smartcontract address of candidate implementation\n    function addImplementation(address addr) public override(ICloneFactory) onlyOwner {\n        (bool isImplementation, address forwardTo) = _probe(addr);\n        require(!isImplementation, \"Implementation already exists\");\n\n        _addImplementation(addr, forwardTo);\n    }\n\n    /// @notice SET default Template to be cloned\n    /// @param addr : smartcontract address of candidate template\n    function setDefaultTemplate(address addr) public override(ICloneFactory) onlyOwner {\n        /// @notice probe addr\n        (bool isImplementation, address forwardTo) = _probe(addr);\n        require((forwardTo == addr), \"Template is a Clone\");\n\n        /// @notice addr not already registered as an implementation, so add it\n        if (!isImplementation) addImplementation(addr);\n\n        /// @notice set addr as default template\n        template = addr;\n\n        /// @notice emit event NewTemplate\n        emit NewTemplate(addr, _msgSender());\n    }\n\n    /// @notice Implementations count\n    /// @return count : number of implementations\n    function implementationsCount() public view override(ICloneFactory) returns (uint256) {\n        return implementations.length;\n    }\n\n    /// @notice ADD Implementation internal\n    /// @param  impl : implementation address\n    /// @param  tmpl : template address\n    function _addImplementation(address impl, address tmpl) internal {\n        /// @notice register implementation\n        implementations.push(impl);\n\n        /// @notice register template\n        templates[impl] = tmpl;\n\n        /// @notice emit event NewImplementation\n        emit NewImplementation(impl, tmpl, _msgSender());\n    }\n\n    /// @notice Clone Template\n    /// @param  addr : clone address\n    function _clone() internal returns (address addr) {\n        require(template != address(0), \"Template doesn't exist\");\n\n        /// @notice clone template and get clone address\n        addr = Clones.clone(template);\n\n        /// @notice register clone as new implementation\n        _addImplementation(addr, template);\n    }\n\n    /// @dev probe if address is contract and/or clone\n    /// @param addr : probe address\n    /// @notice revert if probe address is not contract\n    /// @notice throws if forwardTo not found\n    /// @return isImplementation : true if probe address is implemention\n    /// @return forwardTo : parent template address if clone, probe otherwise\n    function _probe(address addr) internal view returns (bool isImplementation, address forwardTo) {\n        bool isContract;\n        (isContract, forwardTo) = IContractProbe(contractProbe).probe(addr);\n        require(isContract, \"Not a Contract\");\n        assert(forwardTo != address(0));\n\n        isImplementation = (templates[addr] != address(0));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/interfaces/ICloneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICloneFactory {\n    function addImplementation(address implementation_) external;\n\n    function setDefaultTemplate(address defaultTemplate_) external;\n\n    function setContractProbe(address contractProbe_) external;\n\n    function template() external view returns (address template_);\n\n    function implementations(uint256 index) external view returns (address implementation_);\n\n    function implementationsCount() external view returns (uint256 implementationsCount_);\n}\n"
    },
    "contracts/interfaces/IContractProbe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IContractProbe {\n    function probe(address addr) external view returns (bool isContract, address forwardedTo);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/NFTsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./CloneFactory.sol\";\nimport \"./interfaces/INFTsFactory.sol\";\nimport \"./interfaces/IOpenNFTsV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title NFTsFactory smartcontract\n/// @dev is CloneFactory\ncontract NFTsFactory is CloneFactory, INFTsFactory {\n    using ERC165Checker for address;\n\n    uint8 public constant ERC721 = 0;\n    uint8 public constant ERC721_METADATA = 1;\n    uint8 public constant ERC721_ENUMERABLE = 2;\n    uint8 public constant OPEN_NFTS = 3;\n\n    bytes4 public constant ERC721_SIG = bytes4(0x80ac58cd);\n    bytes4 public constant ERC721_METADATA_SIG = bytes4(0x780e9d63);\n    bytes4 public constant ERC721_ENUMERABLE_SIG = bytes4(0x780e9d63);\n    bytes4 public constant OPEN_NFTS_SIG = type(IOpenNFTsV2).interfaceId;\n\n    /// @notice withdrawEther\n    function withdrawEther() external override(INFTsFactory) onlyOwner {\n        Address.sendValue(payable(_msgSender()), address(this).balance);\n    }\n\n    /// @notice balancesOf address\n    /// @param addr  address of account\n    /// @return nftData Array of nftData balances\n    function balancesOf(address addr) external view override(INFTsFactory) returns (NftData[] memory nftData) {\n        nftData = new NftData[](implementations.length);\n        for (uint256 i = 0; i < implementations.length; i += 1) {\n            nftData[i] = balanceOf(implementations[i], addr);\n        }\n    }\n\n    /// @notice clone template\n    /// @param name_ name of Clone collection\n    /// @param symbol_ symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(string memory name_, string memory symbol_) public override(INFTsFactory) returns (address clone_) {\n        clone_ = _clone();\n        require(clone_.supportsInterface(OPEN_NFTS_SIG), \"Clone is not Open NFTs contract\");\n\n        IOpenNFTsV2(clone_).initialize(name_, symbol_);\n    }\n\n    /// @notice balanceOf\n    /// @param nft nft address of NFT collection\n    /// @param owner address of account\n    /// @return nftData nftData balances\n    function balanceOf(address nft, address owner) public view override(INFTsFactory) returns (NftData memory nftData) {\n        bytes4[] memory iface = new bytes4[](4);\n        iface[ERC721] = ERC721_SIG;\n        iface[ERC721_METADATA] = ERC721_METADATA_SIG;\n        iface[ERC721_ENUMERABLE] = ERC721_ENUMERABLE_SIG;\n        iface[OPEN_NFTS] = OPEN_NFTS_SIG;\n        bool[] memory supportInterface = nft.getSupportedInterfaces(iface);\n\n        if (supportInterface[ERC721]) {\n            nftData.nft = nft;\n            nftData.balanceOf = IERC721(nft).balanceOf(owner);\n\n            if (supportInterface[ERC721_METADATA]) {\n                nftData.name = IERC721Metadata(nft).name();\n                nftData.symbol = IERC721Metadata(nft).symbol();\n            }\n\n            if (supportInterface[ERC721_ENUMERABLE]) {\n                nftData.totalSupply = IERC721Enumerable(nft).totalSupply();\n            }\n\n            if (supportInterface[OPEN_NFTS]) {\n                nftData.owner = OwnableUpgradeable(nft).owner();\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/INFTsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface INFTsFactory {\n    struct NftData {\n        address nft;\n        uint256 balanceOf;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function withdrawEther() external;\n\n    function clone(string memory name, string memory symbol) external returns (address clone_);\n\n    function balancesOf(address owner) external view returns (NftData[] memory nftDatas_);\n\n    function balanceOf(address nft, address owner) external view returns (NftData memory nftData_);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV2 {\n    function transferOwnership(address newOwner) external;\n\n    function initialize(string memory name, string memory symbol) external;\n\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID_);\n\n    function owner() external view returns (address owner_);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/OpenNFTsV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"./interfaces/IOpenNFTs.old.sol\";\nimport \"./interfaces/IOpenNFTsV3.old.sol\";\nimport \"./interfaces/IERC173.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsV3 is\n    IOpenNFTs,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    OwnableUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice Burn NFT allowed or not\n    bool public burnable;\n\n    /// @notice onlyMinter, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() {\n        require(open || (owner() == _msgSender()), \"Not minter\");\n        _;\n    }\n\n    /// @notice onlyBurner, only owner can burn if burnable\n    modifier onlyBurner() {\n        require(burnable, \"Not burnable\");\n        require(owner() == _msgSender(), \"Not owner\");\n        _;\n    }\n\n    /// @notice initialize\n    /// @param name name of the NFT Collection\n    /// @param symbol symbol of the NFT Collection\n    /// @param owner owner of the NFT Collection\n    /// @param options select minting open to everyone or only owner\n    // solhint-disable-next-line comprehensive-interface\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external initializer {\n        __Ownable_init();\n        __ERC721_init(name, symbol);\n        transferOwnership(owner);\n        open = options[0];\n        burnable = options[1];\n    }\n\n    /// @notice mint\n    /// @param minter address of minter\n    /// @param jsonURI json URI of NFT metadata\n    function mintOpenNFT(address minter, string memory jsonURI)\n        external\n        override(IOpenNFTs)\n        onlyMinter\n        returns (uint256)\n    {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(minter, newItemId);\n        _setTokenURI(newItemId, jsonURI);\n\n        return newItemId;\n    }\n\n    /// @notice burn NFT\n    /// @param tokenId tokenID of NFT to burn\n    function burnOpenNFT(uint256 tokenId) external override(IOpenNFTs) onlyBurner {\n        _burn(tokenId);\n    }\n\n    /// @notice Get tokenURI\n    /// @param tokenId tokenId of NFT\n    /// @param tokenURI_ token URI of NFT\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory tokenURI_)\n    {\n        tokenURI_ = super.tokenURI(tokenId);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenNFTs).interfaceId ||\n            interfaceId == type(IOpenNFTsV3).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTs.old.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTs {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV3.old.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV3 {\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function transferOwnership(address newOwner) external;\n\n    function owner() external view returns (address currentOwner);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/tests/OpenNFTsV3Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nimport \"../OpenNFTsV3.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\nimport {ERC721TransferableTest} from \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\n\ncontract OpenNFTsV3Test is ITest, ERC721FullTest, OpenNFTsBurnTest, ERC721TransferableTest {\n    function constructorTest(address owner)\n        public\n        override(ERC721FullTest, OpenNFTsBurnTest, ERC721TransferableTest)\n        returns (address)\n    {\n        changePrank(owner);\n        bool[] memory options = new bool[](2);\n        options[0] = true;\n        options[1] = true;\n\n        OpenNFTsV3 op = new OpenNFTsV3();\n        op.initialize(\"OpenNFTsV3Test\", \"OPTEST\", owner, options);\n\n        return address(op);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(ERC721FullTest, OpenNFTsBurnTest, ERC721TransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV3(collection).mintOpenNFT(minter, _TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(ERC721FullTest, OpenNFTsBurnTest) {\n        changePrank(OpenNFTsV3(collection).owner());\n        OpenNFTsV3(collection).burnOpenNFT(tokenID);\n    }\n\n    function setUp() public override {\n        setUpERC721Full(\"OpenNFTsV3Test\", \"OPTEST\");\n        setUpERC721Transferable();\n        setUpOpenNFTsBurn();\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/units/ERC165Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721MetadataTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721EnumerableTest.t.sol\";\n\nabstract contract ERC721FullTest is ERC165Test, ERC721Test, ERC721MetadataTest, ERC721EnumerableTest {\n    string internal constant _TOKEN_URI = \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n    bool private _transferable = true;\n\n    function constructorTest(address owner_)\n        public\n        virtual\n        override(ERC165Test, ERC721Test, ERC721MetadataTest, ERC721EnumerableTest)\n        returns (address);\n\n    function mintTest(address collection, address minter_)\n        public\n        virtual\n        override(ERC721Test, ERC721MetadataTest, ERC721EnumerableTest)\n        returns (uint256, string memory);\n\n    function burnTest(address collection, uint256 tokenID) public virtual override(ERC721Test);\n\n    function setUpERC721Full(string memory name_, string memory symbol_) public {\n        // setUpERC165();\n        setUpERC165();\n        setUpERC721();\n        setUpERC721Metadata(name_, symbol_);\n        setUpERC721Enumerable();\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nabstract contract ERC721Test is Test, IERC721Events {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpERC721() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, ) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721BalanceOf() public {\n        assertEq(IERC721(_collection).balanceOf(_minter), 1);\n        assertEq(IERC721(_collection).balanceOf(_tester), 0);\n    }\n\n    function testERC721BalanceOfBis() public {\n        mintTest(_collection, _tester);\n        assertEq(IERC721(_collection).balanceOf(_tester), 1);\n    }\n\n    function testERC721OwnerOf() public {\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721OwnerOfBis() public {\n        (uint256 tokenID, ) = mintTest(_collection, _tester);\n        assertEq(IERC721(_collection).ownerOf(tokenID), _tester);\n    }\n\n    function testFailERC721NotOnlyTokenOwner() public {\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721ApproveChange() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n        IERC721(_collection).approve(address(0), _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n\n    function testERC721GetApproved() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        assertEq(IERC721(_collection).getApproved(_tokenID0), _tester);\n    }\n\n    function testFailERC721GetApproved() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n        IERC721(_collection).approve(_buyer, _tokenID0);\n\n        assertEq(IERC721(_collection).getApproved(_tokenID0), _tester);\n    }\n\n    function testERC721IsApprovedForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n        assertTrue(IERC721(_collection).isApprovedForAll(_minter, _tester));\n    }\n\n    function testERC721IsNotApprovedForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n        IERC721(_collection).setApprovalForAll(_tester, false);\n\n        assertFalse(IERC721(_collection).isApprovedForAll(_minter, _tester));\n    }\n\n    function testERC721SupportsInterface() public {\n        assertTrue(IERC165(address(_collection)).supportsInterface(type(IERC721).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenNFTsBurnTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    uint256 randNonce;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpOpenNFTsBurn() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, ) = mintTest(_collection, _minter);\n    }\n\n    function testBurn() public {\n        burnTest(_collection, _tokenID0);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 0);\n    }\n\n    function testBurnWithEnumerable() public {}\n\n    function testBurnWithMetadata() public {}\n\n    function testFailBurnTokenByIndex() public {\n        burnTest(_collection, _tokenID0);\n        IERC721Enumerable(_collection).tokenByIndex(0);\n    }\n\n    function testFailBurnTokenOfOwnerByIndex() public {\n        burnTest(_collection, _tokenID0);\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0);\n    }\n\n    function testBurnSecondOne() public {\n        changePrank(_tester);\n        (uint256 tokenID, ) = mintTest(_collection, _tester);\n\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 2);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(1), tokenID);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0), tokenID);\n\n        burnTest(_collection, tokenID);\n\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n    }\n\n    function testFailBurnSecondOneTokenByIndex() public {\n        changePrank(_tester);\n        (uint256 tokenID, ) = mintTest(_collection, _tester);\n        burnTest(_collection, tokenID);\n        IERC721Enumerable(_collection).tokenByIndex(1);\n    }\n\n    function testFailBurnSecondOneTokennOfOwnerByIndex() public {\n        changePrank(_tester);\n        (uint256 tokenID, ) = mintTest(_collection, _tester);\n        burnTest(_collection, tokenID);\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0);\n    }\n\n    function testBurnEnumerable() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        burnTest(_collection, _tokenID0);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 0);\n    }\n\n    function testBurnERC721EnumerableShuffleUp(uint160 rnd) public {\n        burnTest(_collection, _tokenID0);\n\n        uint160 first = 2**100;\n        uint160 total = 20;\n        uint256 totalSupply;\n\n        for (uint160 index = 1; index <= total; index++) {\n            address address1 = address(first + (random(rnd) % index));\n            address address2 = address(first + (random(rnd) % index));\n            uint256 rand3 = (random(rnd) % index);\n\n            mintTest(_collection, address1);\n            mintTest(_collection, address2);\n\n            uint256 randomTokenID1 = IERC721Enumerable(_collection).tokenByIndex(rand3);\n            address owner1 = IERC721(_collection).ownerOf(randomTokenID1);\n            changePrank(owner1);\n            IERC721(_collection).transferFrom(owner1, address2, randomTokenID1);\n\n            uint256 randomTokenID2 = IERC721Enumerable(_collection).tokenByIndex(uint256(rand3));\n            burnTest(_collection, randomTokenID2);\n\n            assertEq(IERC721Enumerable(_collection).totalSupply(), index);\n        }\n        assertEq(IERC721Enumerable(_collection).totalSupply(), total);\n\n        for (uint160 index = 1; index <= total; index++) {\n            totalSupply += IERC721(_collection).balanceOf(address(first + index - 1));\n        }\n        assertEq(totalSupply, total);\n    }\n\n    function random(uint160 rnd) public returns (uint160) {\n        randNonce++;\n        return uint160(uint256(keccak256(abi.encodePacked(msg.sender, randNonce, rnd))));\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/ITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ITest {\n    function setUp() external;\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721TokenReceiver.sol\";\n\nabstract contract ERC721TransferableTest is Test, IERC721Events {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpERC721Transferable() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, ) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testERC721SafeTransferFrom() public {\n        changePrank(_minter);\n\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721SafeTransferFromWithData() public {\n        changePrank(_minter);\n\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721SafeTransferFromEmit() public {\n        changePrank(_minter);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(_minter, _tester, _tokenID0);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testERC721SafeTransferFromWithDataEmit() public {\n        changePrank(_minter);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(_minter, _tester, _tokenID0);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n    }\n\n    function testERC721SafeTransferFromEOAFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID, ) = mintTest(_collection, from);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, tokenID);\n        IERC721(_collection).safeTransferFrom(from, to, tokenID);\n        assertEq(IERC721(_collection).ownerOf(tokenID), to);\n    }\n\n    function testERC721TransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n\n        IERC721(_collection).transferFrom(_minter, address(_collection), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(_collection));\n    }\n\n    function testERC721TransferFrom() public {\n        changePrank(_minter);\n\n        IERC721(_collection).transferFrom(_minter, _tester, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _tester);\n    }\n\n    function testERC721TransferFromEOAFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID, ) = mintTest(_collection, from);\n\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, tokenID);\n        IERC721(_collection).transferFrom(from, to, tokenID);\n        assertEq(IERC721(_collection).ownerOf(tokenID), to);\n    }\n\n    function testERC721transferFromToContract() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, address(this), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(this));\n    }\n\n    function testFailERC721SafeTransferFromToNotReceiverContract() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(this), _tokenID0);\n    }\n\n    function testERC721SafeTransferFromToReceiverContract() public {\n        OpenERC721TokenReceiver receiverContract = new OpenERC721TokenReceiver();\n\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(receiverContract), _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), address(receiverContract));\n    }\n\n    function testERC721Approve() public {\n        changePrank(_minter);\n        vm.expectEmit(true, true, true, false);\n        emit Approval(_minter, _tester, _tokenID0);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n    }\n\n    function testERC721SetApprovalForAll() public {\n        changePrank(_minter);\n        vm.expectEmit(true, true, true, false);\n        emit ApprovalForAll(_minter, _tester, true);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n    }\n\n    function testFailERC721TransferFromToZeroAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(0), _tokenID0);\n    }\n\n    function testFailERC721TransferFromFromZeroAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(address(0), _tester, _tokenID0);\n    }\n\n    function testERC721TransferFromToSameAddress() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _minter, _tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC165Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC165Test is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpERC165() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testERC165SupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC165).interfaceId));\n        assertFalse(IERC165(_collection).supportsInterface(0xffffffff));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721MetadataTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC721MetadataTest is Test {\n    address private _collection;\n    string private _name;\n    string private _symbol;\n    string private _tokenURI0;\n    uint256 private _tokenID0;\n    address private _minter = address(0x23);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpERC721Metadata(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _collection = constructorTest(_minter);\n        (_tokenID0, _tokenURI0) = mintTest(_collection, _minter);\n    }\n\n    function testERC721MetadataName() public {\n        assertEq(IERC721Metadata(_collection).name(), _name);\n    }\n\n    function testERC721MetadataSymbol() public {\n        assertEq(IERC721Metadata(_collection).symbol(), _symbol);\n    }\n\n    function testERC721MetadataURI() public {\n        assertEq(IERC721Metadata(_collection).tokenURI(_tokenID0), _tokenURI0);\n    }\n\n    function testERC721MetadataSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC721Metadata).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721EnumerableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC721EnumerableTest is Test {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x2);\n    address private _minter = address(0x22);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpERC721Enumerable() public {\n        _collection = constructorTest(_owner);\n        (_tokenID0, ) = mintTest(_collection, _minter);\n    }\n\n    function testERC721EnumerableTotalSupply() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n    }\n\n    function testERC721EnumerableTotalSupplyIncrement() public {\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n        mintTest(_collection, _tester);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 2);\n    }\n\n    function testERC721EnumerableTokenByIndex() public {\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n    }\n\n    function testFailERC721EnumerableTokenByIndex() public view {\n        IERC721Enumerable(_collection).tokenByIndex(1);\n    }\n\n    function testERC721EnumerableTokenByIndexSecond() public {\n        (uint256 tokenID, ) = mintTest(_collection, _tester);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(1), tokenID);\n    }\n\n    function testERC721EnumerableTokenOfOwnerByIndex() public {\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n    }\n\n    function testFailERC721EnumerableTokenOfOwnerByIndex() public view {\n        IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 1);\n    }\n\n    function testERC721EnumerableTokenOfOwnerByIndexOther() public {\n        console.log(\"_tokenID0\", _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n\n        changePrank(_tester);\n        (uint256 tokenID, ) = mintTest(_collection, _tester);\n        console.log(\"tokenID\", tokenID);\n\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_tester, 0), tokenID);\n    }\n\n    function testERC721EnumerableSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC721Enumerable).interfaceId));\n    }\n}\n"
    },
    "forge-std/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "forge-std/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapated from Solmate implementation (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))));\n    }\n\n    function addressFromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n}\n"
    },
    "ds-test/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "forge-std/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns(uint256);\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns(bool);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata,uint256) external returns(uint256);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns(uint256);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns(uint256);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    /// Returns the RPC url for the given alias\n\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address) external;\n    function makePersistent(address, address) external;\n    function makePersistent(address, address, address) external;\n    function makePersistent(address[] calldata) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address) external;\n    function revokePersistent(address[] calldata) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address) external returns (bool);\n\n    function rpcUrl(string calldata) external returns(string memory);\n    /// Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns(string[2][] memory);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "OpenNFTs/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721Events {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721Enumerable {\n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721TokenReceiver —— IERC721TokenReceiver\n//\n\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\ncontract OpenERC721TokenReceiver is IERC721TokenReceiver, OpenERC721 {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual override(IERC721TokenReceiver) returns (bytes4) {\n        return OpenERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC721 —— IERC721\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\nabstract contract OpenERC721 is IERC721, OpenERC165 {\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    modifier onlyTokenOwnerOrApproved(uint256 tokenID) {\n        require(_isOwnerOrApproved(msg.sender, tokenID), \"Not token owner nor approved\");\n        _;\n    }\n\n    function approve(address spender, uint256 tokenID) external override(IERC721) {\n        require(_isOwnerOrOperator(msg.sender, tokenID), \"Not token owner nor operator\");\n\n        _tokenApprovals[tokenID] = spender;\n        emit Approval(ownerOf(tokenID), spender, tokenID);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external override(IERC721) {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenID\n    ) external payable override(IERC721) {\n        _transferFrom(from, to, tokenID);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory data\n    ) external payable override(IERC721) {\n        _transferFrom(from, to, tokenID);\n        require(_isERC721Receiver(from, to, tokenID, data), \"Not ERC721Received\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenID\n    ) public payable override(IERC721) {\n        _safeTransferFrom(from, to, tokenID, \"\");\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC165) returns (bool) {\n        return\n            interfaceId == 0x80ac58cd || // = type(IERC721).interfaceId\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view override(IERC721) returns (uint256) {\n        require(owner != address(0), \"Invalid zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenID) public view override(IERC721) returns (address owner) {\n        require((owner = _owners[tokenID]) != address(0), \"Invalid token ID\");\n    }\n\n    function getApproved(uint256 tokenID) public view override(IERC721) returns (address) {\n        require(_exists(tokenID), \"Invalid token ID\");\n\n        return _tokenApprovals[tokenID];\n    }\n\n    function isApprovedForAll(address owner, address operator) public view override(IERC721) returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function _mint(\n        address to,\n        string memory,\n        uint256 tokenID\n    ) internal virtual {\n        require(to != address(0), \"Mint to zero address\");\n        require(!_exists(tokenID), \"Token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenID] = to;\n\n        emit Transfer(address(0), to, tokenID);\n        require(_isERC721Receiver(address(0), to, tokenID, \"\"), \"Not ERC721Received\");\n    }\n\n    function _burn(uint256 tokenID) internal virtual {\n        address owner = ownerOf(tokenID);\n        assert(_balances[owner] > 0);\n\n        _balances[owner] -= 1;\n        delete _tokenApprovals[tokenID];\n        delete _owners[tokenID];\n\n        emit Transfer(owner, address(0), tokenID);\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal virtual {}\n\n    function _exists(uint256 tokenID) internal view returns (bool exists) {\n        exists = _owners[tokenID] != address(0);\n    }\n\n    function _isOwnerOrOperator(address spender, uint256 tokenID) internal view virtual returns (bool ownerOrOperator) {\n        address tokenOwner = ownerOf(tokenID);\n        ownerOrOperator = (tokenOwner == spender || isApprovedForAll(tokenOwner, spender));\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory data\n    ) private {\n        _transferFrom(from, to, tokenID);\n\n        require(_isERC721Receiver(from, to, tokenID, data), \"Not ERC721Receiver\");\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenID\n    ) private onlyTokenOwnerOrApproved(tokenID) {\n        require(from == ownerOf(tokenID), \"From not owner\");\n        require(from != address(0), \"Transfer from zero address\");\n        require(to != address(0), \"Transfer to zero address\");\n\n        _transferFromBefore(from, to, tokenID);\n\n        delete _tokenApprovals[tokenID];\n\n        if (from != to) {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n            _owners[tokenID] = to;\n        }\n\n        emit Transfer(from, to, tokenID);\n    }\n\n    function _isERC721Receiver(\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory data\n    ) private returns (bool) {\n        return\n            to.code.length == 0 ||\n            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenID, data) ==\n            IERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    function _isOwnerOrApproved(address spender, uint256 tokenID) private view returns (bool ownerOrApproved) {\n        ownerOrApproved = (_isOwnerOrOperator(spender, tokenID) || (getApproved(tokenID) == spender));\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-165: Standard Interface Detection\n// https://eips.ethereum.org/EIPS/eip-165\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/utils/introspection/ERC165.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165 —— IERC165\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract OpenERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7; //  type(IERC165).interfaceId\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenNFTsV4.sol\";\n\nimport \"./OpenNFTsV4InitializeTest.t.sol\";\nimport \"./OpenNFTsV4SupportsTest.t.sol\";\nimport \"./OpenNFTsV4BuyTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC2981Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsBurnTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenNFTsSetupTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenMarketableTest.t.sol\";\n\ncontract OpenNFTsV4Test is\n    ERC721TransferableTest,\n    ERC173Test,\n    ERC2981Test,\n    OpenNFTsV4InitializeTest,\n    OpenNFTsV4SupportsTest,\n    OpenNFTsV4BuyTest,\n    OpenNFTsTest,\n    OpenNFTsBurnTest,\n    OpenNFTsSetupTest,\n    OpenPauseableTest,\n    OpenMarketableTest\n{\n    function constructorTest(address owner)\n        public\n        override(\n            ERC721TransferableTest,\n            ERC173Test,\n            ERC2981Test,\n            OpenNFTsTest,\n            OpenNFTsV4SupportsTest,\n            OpenNFTsV4BuyTest,\n            OpenNFTsBurnTest,\n            OpenNFTsSetupTest,\n            OpenPauseableTest,\n            OpenMarketableTest\n        )\n        returns (address)\n    {\n        return constructorTest(owner, true);\n    }\n\n    function constructorTest(address owner, bool init) public override(OpenNFTsV4InitializeTest) returns (address) {\n        changePrank(owner);\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        OpenNFTsV4 collection = new OpenNFTsV4();\n        if (init) collection.initialize(\"OpenERC721Test\", \"OPTEST\", owner, 0, address(0), 0, options);\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(\n            OpenNFTsV4BuyTest,\n            OpenNFTsTest,\n            OpenNFTsBurnTest,\n            OpenNFTsSetupTest,\n            ERC2981Test,\n            OpenPauseableTest,\n            OpenMarketableTest,\n            ERC721TransferableTest\n        )\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV4(payable(collection)).mint(_TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(OpenNFTsTest, OpenNFTsBurnTest) {\n        changePrank(OpenNFTsV4(payable(collection)).ownerOf(tokenID));\n        OpenNFTsV4(payable(collection)).burn(tokenID);\n    }\n\n    function setPriceTest(\n        address collection,\n        uint256 tokenID,\n        uint256 price\n    ) public {\n        OpenNFTsV4(payable(collection)).setTokenPrice(tokenID, price);\n    }\n\n    function setRoyaltyTest(\n        address collection,\n        address receiver,\n        uint96 fee\n    ) public override(ERC2981Test, OpenMarketableTest) returns (uint256 tokenID) {\n        (tokenID, ) = mintTest(collection, receiver);\n        OpenNFTsV4(payable(collection)).setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpERC2981();\n        setUpPausable();\n        setUpMarketable();\n        setUpOpenNFTs(\"OpenERC721Test\", \"OPTEST\");\n        setUpERC721Transferable();\n        setUpOpenNFTsBurn();\n        setUpOpenNFTsBuy();\n        setUpOpenNFTsSetup();\n        setUpOpenNFTsV4Initialize();\n        setUpOpenNFTsV4Supports();\n    }\n}\n"
    },
    "contracts/next/OpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————————————————————————————————————————————————————————\n//       |                                                         |               |\n//   OpenERC721                                               OpenERC173     OpenCloneable\n//     (NFT)                                                   (ownable)           |\n//       |                                                         |               |\n//       —————————————————————————————————————————————      ————————               |\n//       |                        |                  |      |      |               |\n//  OpenERC721Metadata  OpenERC721Enumerable   OpenERC2981  |      |               |\n//       |                        |           (RoyaltyInfo) |      |               |\n//       |                        |                  |      |      |               |\n//       |                        |                  ————————      |               |\n//       |                        |                  |             |               |\n//       |                        |            OpenMarketable OpenPauseable        |\n//       |                        |                  |             |               |\n//       ———————————————————————————————————————————————————————————————————————————\n//       |\n//    OpenNFTs\n//       |\n//   OpenNFTsV4 —— IOpenNFTsV4\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsV4 is IOpenNFTsV4, OpenNFTs {\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() override(OpenNFTs) {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function buy(uint256 tokenID) external payable override(IOpenNFTsV4) {\n        require(_exists(tokenID), \"NFT doesn't exists\");\n\n        /// Get token price\n        uint256 price = tokenPrice[tokenID];\n\n        /// Require price defined\n        require(price > 0, \"Not to sell\");\n\n        /// Require enough value sent\n        require(msg.value >= price, \"Not enough funds\");\n\n        /// Get previous token owner\n        address from = ownerOf(tokenID);\n        assert(from != address(0));\n        require(from != msg.sender, \"Already token owner!\");\n\n        /// Transfer token\n        this.safeTransferFrom{value: msg.value}(from, msg.sender, tokenID, \"\");\n\n        /// Reset token price (to be eventualy defined by new owner)\n        delete tokenPrice[tokenID];\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        uint256 defaultPrice_,\n        address receiver_,\n        uint96 fee_,\n        bool[] memory options\n    ) external override(IOpenNFTsV4) {\n        OpenNFTs._initialize(name_, symbol_, owner_);\n        open = options[0];\n        setDefaultPrice(defaultPrice_);\n        setDefaultRoyalty(receiver_, fee_);\n    }\n\n    function mint(string memory tokenURI) external override(IOpenNFTsV4) returns (uint256 tokenID) {\n        tokenID = mint(msg.sender, tokenURI, 0, address(0), 0);\n    }\n\n    function parent() external view override(IOpenNFTsV4) returns (address parent_) {\n        // eip1167 deployed code = 45 bytes = 10 bytes + 20 bytes address + 15 bytes\n        // extract bytes 10 to 30: shift 2 bytes (16 bits) then truncate to address 20 bytes (uint160)\n        return\n            (address(this).code.length == 45)\n                ? address(uint160(uint256(bytes32(address(this).code)) >> 16))\n                : address(0);\n    }\n\n    function mint(\n        address minter,\n        string memory tokenURI,\n        uint256 price,\n        address receiver,\n        uint96 fee\n    ) public payable override(IOpenNFTsV4) onlyMinter onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = mint(minter, tokenURI);\n        if (price > 0) setTokenPrice(tokenID, price);\n        if (receiver != address(0) && fee > 0) setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenNFTs) returns (bool) {\n        return\n            interfaceId == type(IOpenNFTsV4).interfaceId ||\n            interfaceId == type(IOpenNFTsOld).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4InitializeTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\n\nabstract contract OpenNFTsV4InitializeTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_, bool init_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Initialize() public {\n        _collection = constructorTest(_owner, false);\n\n        _options[0] = true;\n    }\n\n    function testInitializeName() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenERC721Test\", \"TEST\", _owner, 0, address(0), 0, _options);\n        // assertEq(IERC721Metadata(_collection).name(), \"OpenERC721Test\");\n    }\n\n    function testInitializeSymbol() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenERC721Test\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IERC721Metadata(_collection).symbol(), \"TEST\");\n    }\n\n    function testInitializeOwner() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenERC721Test\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testInitializeOpen() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenERC721Test\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IOpenNFTsV4(_collection).open(), true);\n    }\n\n    function testInitializeNotOpen() public {\n        _options[0] = false;\n        IOpenNFTsV4(_collection).initialize(\"OpenERC721Test\", \"TEST\", _owner, 0, address(0), 0, _options);\n        assertEq(IOpenNFTsV4(_collection).open(), false);\n    }\n\n    function testFailInitializeTwice() public {\n        IOpenNFTsV4(_collection).initialize(\"OpenERC721Test\", \"TEST\", _owner, 0, address(0), 0, _options);\n        IOpenNFTsV4(_collection).initialize(\"OpenNFTsOldTestTwice\", \"OPTEST2\", _tester, 0, address(0), 0, _options);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4SupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\nimport \"../../next/NFTsResolver.sol\";\n\nabstract contract OpenNFTsV4SupportsTest is Test {\n    NFTsResolver private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenNFTsV4Supports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new NFTsResolver();\n    }\n\n    function testOpenNFTsV4CheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, true];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenNFTsV4CheckSupportedInterfaces() public {\n        bytes4[8] memory ids = [\n            type(IOpenCloneable).interfaceId,\n            type(IOpenMarketable).interfaceId,\n            type(IOpenNFTs).interfaceId,\n            type(IOpenNFTsV4).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenChecker).interfaceId,\n            type(IERC721TokenReceiver).interfaceId,\n            0xffffffff\n        ];\n        bool[8] memory expected = [true, true, true, true, true, false, false, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](8);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            console.log(\"testOpenNFTsV4CheckErcInterfaces ~ i\", i);\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV4/OpenNFTsV4BuyTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"../../interfaces/IOpenNFTsV4.sol\";\n\nabstract contract OpenNFTsV4BuyTest is Test {\n    address payable private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpOpenNFTsBuy() public {\n        _collection = payable(constructorTest(_owner));\n\n        (_tokenID0, ) = mintTest(_collection, _minter);\n    }\n\n    function testBuyOk() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_collection, true);\n\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n        uint256 balMinter = _minter.balance;\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n        IOpenNFTsV4(_collection).buy{value: 1.5 ether}(_tokenID0);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _buyer);\n\n        assertEq(_buyer.balance, 9 ether);\n        assertEq(_collection.balance, 0 ether);\n        assertEq(_tester.balance, 0.01 ether);\n        assertEq(_minter.balance, balMinter + 0.99 ether);\n    }\n\n    function testFailBuyTwice() public {\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        IOpenNFTsV4(_collection).buy{value: 1 ether}(_tokenID0);\n        IOpenNFTsV4(_collection).buy{value: 1 ether}(_tokenID0);\n    }\n\n    function testFailBuyNotEnoughFunds() public {\n        IOpenMarketable(_collection).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 1 ether);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        IOpenNFTsV4(_collection).buy{value: 0.5 ether}(_tokenID0);\n    }\n\n    function testFailBuyNotToSell() public {\n        IOpenMarketable(_collection).setTokenPrice(_tokenID0, 0);\n\n        changePrank(_buyer);\n        deal(_buyer, 10 ether);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n        IOpenNFTsV4(_collection).buy{value: 1 ether}(_tokenID0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nabstract contract OpenNFTsTest is ERC721FullTest {\n    function constructorTest(address owner_) public virtual override(ERC721FullTest) returns (address);\n\n    function mintTest(address collection, address minter_)\n        public\n        virtual\n        override(ERC721FullTest)\n        returns (uint256, string memory);\n\n    function burnTest(address collection, uint256 tokenID) public virtual override(ERC721FullTest);\n\n    function setUpOpenNFTs(string memory name_, string memory symbol_) public {\n        setUpERC721Full(name_, symbol_);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC173Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract ERC173Test is Test {\n    address private _collection;\n    string private _tokenURI;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpERC173() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testERC173Owner() public {\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testERC173OnlyOwner() public {\n        changePrank(_owner);\n        IERC173(_collection).transferOwnership(_tester);\n    }\n\n    function testFailERC173NotOnlyOwner() public {\n        changePrank(_tester);\n        IERC173(_collection).transferOwnership(_minter);\n    }\n\n    function testERC173TransferOwnership() public {\n        changePrank(_owner);\n        IERC173(_collection).transferOwnership(_tester);\n        assertEq(IERC173(_collection).owner(), _tester);\n    }\n\n    function testERC173EmitTransferOwnership() public {\n        changePrank(_owner);\n        vm.expectEmit(true, true, false, false);\n        emit OwnershipTransferred(_owner, _tester);\n        IERC173(_collection).transferOwnership(_tester);\n    }\n\n    function testFailERC173NotTransferOwnership() public {\n        changePrank(_tester);\n        IERC173(_collection).transferOwnership(_minter);\n    }\n\n    function testERC173SupportsInterface() public {\n        assertTrue(IERC165(address(_collection)).supportsInterface(type(IERC173).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC2981Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract ERC2981Test is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address contract_);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setRoyaltyTest(\n        address collection_,\n        address receiver_,\n        uint96 fee_\n    ) public virtual returns (uint256 tokenID_);\n\n    function setUpERC2981() public {\n        _collection = constructorTest(_owner);\n\n        _tokenID0 = setRoyaltyTest(_collection, _minter, 420);\n    }\n\n    function testERC2981RoyaltyInfo(uint256 price) public {\n        vm.assume(price < 2**128);\n        IERC2981(_collection).royaltyInfo(_tokenID0, price);\n    }\n\n    function testFailERC2981RoyaltyInfoTooExpensive(uint256 price) public {\n        vm.assume(price >= 2**128);\n        IERC2981(_collection).royaltyInfo(_tokenID0, price);\n    }\n\n    function testERC2981SupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IERC2981).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenNFTsSetupTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenNFTsSetupTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    string private _tokenURI0;\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpOpenNFTsSetup() public {\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, _tokenURI0) = mintTest(_collection, _minter);\n    }\n\n    function testContract() public {\n        assertEq(IERC721Metadata(_collection).name(), \"OpenERC721Test\");\n        assertEq(IERC721Metadata(_collection).symbol(), \"OPTEST\");\n        assertEq(IERC173(_collection).owner(), _owner);\n    }\n\n    function testCount() public {\n        assertEq(IERC721(_collection).balanceOf(_minter), 1);\n        assertEq(IERC721Enumerable(_collection).totalSupply(), 1);\n    }\n\n    function testToken() public {\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n        assertEq(IERC721Enumerable(_collection).tokenByIndex(0), _tokenID0);\n        assertEq(IERC721Enumerable(_collection).tokenOfOwnerByIndex(_minter, 0), _tokenID0);\n        assertEq(IERC721Metadata(_collection).tokenURI(_tokenID0), _tokenURI0);\n    }\n\n    function testPrice() public {\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(1), 0);\n    }\n\n    function testRoyalties() public {\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(1, 1);\n        assertEq(receiver, address(0));\n        assertEq(royalties, 0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseableTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _tester = address(0x4);\n\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setUpPausable() public {\n        _collection = constructorTest(_owner);\n    }\n\n    function testPausable() public {\n        assertEq(IOpenPauseable(_collection).paused(), false);\n    }\n\n    function testPausableTogglePause() public {\n        changePrank(_owner);\n\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), true);\n\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), false);\n    }\n\n    function testFailPausableTogglePauseNotOwner() public {\n        changePrank(_tester);\n        IOpenPauseable(_collection).togglePause();\n    }\n\n    function testFailPausableOnlyWhenNotPaused() public {\n        changePrank(_owner);\n        IOpenPauseable(_collection).togglePause();\n        assertEq(IOpenPauseable(_collection).paused(), true);\n\n        mintTest(_collection, _owner);\n    }\n\n    function testPausableEmitSetPause() public {\n        changePrank(_owner);\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(true, _owner);\n        IOpenPauseable(_collection).togglePause();\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(false, _owner);\n        IOpenPauseable(_collection).togglePause();\n    }\n\n    function testPausableSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IOpenPauseable).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/OpenMarketableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenMarketableTest is Test {\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x2);\n    address private _tester = address(0x4);\n    uint256 private _tokenID0;\n    uint256 private _notTokenID = 42;\n\n    uint96 private _maxFee = 10000;\n\n    // uint256 private maxPrice = uint256(((2**256) - 1)) / _maxFee;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function setRoyaltyTest(\n        address collection_,\n        address receiver_,\n        uint96 fee_\n    ) public virtual returns (uint256 tokenID_);\n\n    function setUpMarketable() public {\n        _collection = constructorTest(_owner);\n\n        _tokenID0 = setRoyaltyTest(_collection, _minter, 420);\n    }\n\n    function testSetDefaultRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price < 2**128);\n        vm.assume(fee < 10000);\n\n        (uint256 tokenID, ) = mintTest(_collection, _owner);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, price);\n        assertEq(receiver, _minter);\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testSetTokenRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price != 0);\n        vm.assume(price < 2**128);\n        vm.assume(fee < 10000);\n\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(_tokenID0, price);\n        assertEq(receiver, _tester);\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testFailSetTokenRoyaltyNoToken() public {\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_notTokenID, _tester, 100);\n    }\n\n    function testSetTokenPrice(uint256 price) public {\n        vm.assume(price < 2**128);\n\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, price);\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(_tokenID0), price);\n    }\n\n    function testSetTokenPriceFromDefault(uint256 price) public {\n        vm.assume(price < 2**128);\n\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0);\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(_tokenID0), 0);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultPrice(price);\n\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0);\n        assertEq(IOpenMarketable(payable(_collection)).tokenPrice(_tokenID0), price);\n    }\n\n    function testFailSetDefaultPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2**128);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultPrice(price);\n    }\n\n    function testFailSetTokenPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2**128);\n\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, price);\n    }\n\n    function testFailSetTokenPriceNoToken() public {\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_notTokenID, 1 ether);\n    }\n\n    function testRoyaltyInfoCalculation(uint256 price, uint96 fee) public {\n        vm.assume(price < 2**128);\n        vm.assume(fee < _maxFee);\n\n        (uint256 tokenID, ) = mintTest(_collection, _owner);\n\n        changePrank(_owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(_minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID, price);\n        assertEq(receiver, _minter);\n\n        assertEq(royalties, (price * fee) / _maxFee);\n    }\n\n    function testTokenOwner() public {\n        changePrank(_minter);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n    }\n\n    function testFailSetTokenRoyaltyNotOwner() public {\n        changePrank(_tester);\n        IOpenMarketable(payable(_collection)).setTokenRoyalty(_tokenID0, _tester, 100);\n    }\n\n    function testFailSetTokenPriceNotOwner() public {\n        changePrank(_tester);\n        IOpenMarketable(payable(_collection)).setTokenPrice(_tokenID0, 1 ether);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(IERC165(_collection).supportsInterface(type(IOpenMarketable).interfaceId));\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ——————————————————————————————————————————————————————————————————————\n//       |                                       |             |              |\n//   OpenERC721                            OpenERC2981    OpenERC173    OpenCloneable\n//     (NFT)                              (RoyaltyInfo)    (ownable)          |\n//       |                                        |            |              |\n//       ——————————————————————————————————————   |     ————————              |\n//       |                        |           |   |     |      |              |\n//  OpenERC721Metadata  OpenERC721Enumerable  |   ———————      |              |\n//       |                        |           |   |            |              |\n//       |                        |      OpenMarketable   OpenPauseable       |\n//       |                        |             |              |              |\n//       ——————————————————————————————————————————————————————————————————————\n//       |\n//    OpenNFTs —— IOpenNFTs\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenCloneable.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTs is IOpenNFTs, OpenERC721Metadata, OpenERC721Enumerable, OpenMarketable, OpenPauseable, OpenCloneable {\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext = 1;\n\n    /// @notice onlyMinter, by default only owner can mint, can be overriden\n    modifier onlyMinter() virtual {\n        require(msg.sender == owner(), \"Not minter\");\n        _;\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID) external override(IOpenNFTs) onlyTokenOwnerOrApproved(tokenID) {\n        _burn(tokenID);\n    }\n\n    /// @notice withdraw token otherwise eth\n    function withdraw(address token) external override(IOpenNFTs) onlyOwner {\n        if ((token.code.length != 0) && (IERC165(token).supportsInterface(type(IERC20).interfaceId))) {\n            require(IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))), \"Withdraw failed\");\n        } else {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    function mint(address minter, string memory tokenURI)\n        public\n        override(IOpenNFTs)\n        onlyMinter\n        returns (uint256 tokenID)\n    {\n        tokenID = tokenIdNext++;\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenMarketable, OpenERC721Metadata, OpenERC721Enumerable, OpenCloneable, OpenPauseable)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTs).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice _initialize\n    /// @param name_ name of the NFT Collection\n    /// @param symbol_ symbol of the NFT Collection\n    /// @param owner_ owner of the NFT Collection\n    // solhint-disable-next-line comprehensive-interface\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) internal {\n        OpenCloneable._initialize(\"OpenNFTs\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n    }\n\n    /// @notice _mint\n    /// @param minter minter address\n    /// @param tokenURI token metdata URI\n    /// @param tokenID token ID\n    function _mint(\n        address minter,\n        string memory tokenURI,\n        uint256 tokenID\n    ) internal override(OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable) {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable) {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal override(OpenERC721, OpenMarketable, OpenERC721Enumerable) {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTsV4 {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        uint256 defaultPrice,\n        address receiver,\n        uint96 fee,\n        bool[] memory options\n    ) external;\n\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(\n        address minter,\n        string memory tokenURI,\n        uint256 price,\n        address receiver,\n        uint96 fee\n    ) external payable returns (uint256 tokenID);\n\n    function buy(uint256 tokenID) external payable;\n\n    function parent() external view returns (address);\n\n    function open() external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenNFTs {\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n\n    function withdraw(address token) external;\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//     OpenERC165\n//          |\n//     OpenERC721\n//          |\n//  OpenERC721Metadata —— IERC721Metadata\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\n\nabstract contract OpenERC721Metadata is IERC721Metadata, OpenERC721 {\n    bool private _openERC721MetadataInitialized;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => string) private _tokenURIs;\n\n    function name() external view virtual override(IERC721Metadata) returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view virtual override(IERC721Metadata) returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenID) external view virtual override(IERC721Metadata) returns (string memory) {\n        return _tokenURIs[tokenID];\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC721) returns (bool) {\n        return interfaceId == 0x5b5e139f || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory name_, string memory symbol_) internal {\n        require(_openERC721MetadataInitialized == false, \"Only once!\");\n        _openERC721MetadataInitialized = true;\n\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function _mint(\n        address to,\n        string memory newTokenURI,\n        uint256 tokenID\n    ) internal virtual override(OpenERC721) {\n        _tokenURIs[tokenID] = newTokenURI;\n\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override(OpenERC721) {\n        delete _tokenURIs[tokenID];\n\n        super._burn(tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/extensions/ERC721Enumerable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/...\n// ...contracts/token/ERC721/extensions/ERC721Enumerable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721Enumerable —— IERC721Enumerable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenERC721Enumerable is IERC721Enumerable, OpenERC721 {\n    // Array of all tokens ID\n    uint256[] private _allTokens;\n\n    // Mapping from owner to list of token IDs owned\n    // mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to owned index\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Mapping from token ID to all index\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < OpenERC721.balanceOf(owner), \"Invalid index!\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() external view override(IERC721Enumerable) returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256) {\n        require(index < _allTokens.length, \"Invalid index!\");\n        return _allTokens[index];\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC721) returns (bool) {\n        return interfaceId == 0x780e9d63 || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(\n        address to,\n        string memory tokenURI,\n        uint256 tokenID\n    ) internal virtual override(OpenERC721) {\n        _addOwnedToken(to, tokenID);\n\n        _allTokensIndex[tokenID] = _allTokens.length;\n        _allTokens.push(tokenID);\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override(OpenERC721) {\n        address from = ownerOf(tokenID);\n\n        _removeOwnedToken(from, tokenID);\n\n        uint256 allBurnIndex = _allTokensIndex[tokenID];\n        uint256 allLastIndex = _allTokens.length - 1;\n        uint256 allLastTokenId = _allTokens[allLastIndex];\n\n        _allTokensIndex[allLastTokenId] = allBurnIndex;\n        delete _allTokensIndex[tokenID];\n\n        _allTokens[allBurnIndex] = allLastTokenId;\n        _allTokens.pop();\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal virtual override(OpenERC721) {\n        _removeOwnedToken(from, tokenID);\n        _addOwnedToken(to, tokenID);\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _addOwnedToken(address owner, uint256 tokenID) private {\n        _ownedTokensIndex[tokenID] = _ownedTokens[owner].length;\n        _ownedTokens[owner].push(tokenID);\n    }\n\n    function _removeOwnedToken(address owner, uint256 tokenID) private {\n        uint256 burnIndex = _ownedTokensIndex[tokenID];\n        uint256 lastIndex = OpenERC721.balanceOf(owner) - 1;\n\n        if (burnIndex != lastIndex) {\n            uint256 lastTokenId = _ownedTokens[owner][lastIndex];\n            _ownedTokens[owner][burnIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = burnIndex;\n        }\n\n        delete _ownedTokensIndex[tokenID];\n        _ownedTokens[owner].pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//        |\n//        ————————————————————————————\n//        |            |             |\n//   OpenERC721    OpenERC173   OpenERC2981\n//      (NFT)      (Ownable)   (RoyaltyInfo)\n//        |            |             |\n//        ————————————————————————————\n//        |\n//  OpenMarketable —— IOpenMarketable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenMarketable is IOpenMarketable, OpenERC721, OpenERC173, OpenERC2981 {\n    mapping(uint256 => uint256) public tokenPrice;\n    uint256 public defaultPrice;\n\n    receive() external payable override(IOpenMarketable) {}\n\n    function setTokenPrice(uint256 tokenID) external override(IOpenMarketable) {\n        setTokenPrice(tokenID, defaultPrice);\n    }\n\n    /// @notice SET default royalty configuration\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10000\n    function setDefaultRoyalty(address receiver, uint96 fee)\n        public\n        override(IOpenMarketable)\n        onlyOwner\n        lessThanMaxFee(fee)\n    {\n        _royaltyInfo = RoyaltyInfo(receiver, fee);\n        emit SetDefaultRoyalty(receiver, fee);\n    }\n\n    function setDefaultPrice(uint256 price) public override(IOpenMarketable) onlyOwner notTooExpensive(price) {\n        defaultPrice = price;\n\n        emit SetDefaultPrice(price);\n    }\n\n    /// @notice SET token royalty configuration\n    /// @param tokenID : token ID\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10000\n    function setTokenRoyalty(\n        uint256 tokenID,\n        address receiver,\n        uint96 fee\n    ) public override(IOpenMarketable) onlyTokenOwnerOrApproved(tokenID) lessThanMaxFee(fee) {\n        _setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function setTokenPrice(uint256 tokenID, uint256 price)\n        public\n        override(IOpenMarketable)\n        onlyTokenOwnerOrApproved(tokenID)\n        notTooExpensive(price)\n    {\n        _setTokenPrice(tokenID, price);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721, OpenERC173, OpenERC2981)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenMarketable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(\n        address to,\n        string memory tokenURI,\n        uint256 tokenID\n    ) internal virtual override(OpenERC721) {\n        super._mint(to, tokenURI, tokenID);\n\n        _pay(tokenID, defaultPrice, to, owner());\n    }\n\n    function _burn(uint256 tokenID) internal virtual override(OpenERC721) {\n        delete _tokenRoyaltyInfo[tokenID];\n        delete tokenPrice[tokenID];\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal virtual override(OpenERC721) {\n        /// Transfer: pay token price (including royalties) to previous token owner (and royalty receiver)\n        _pay(tokenID, tokenPrice[tokenID], to, ownerOf(tokenID));\n        delete tokenPrice[tokenID];\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _pay(\n        uint256 tokenID,\n        uint256 price,\n        address payer,\n        address payee\n    ) private {\n        uint256 unspent = msg.value;\n\n        if (price > 0) {\n            /// Require enough value sent\n            require(unspent >= price, \"Not enough funds\");\n\n            (address receiver, uint256 royalties) = royaltyInfo(tokenID, price);\n\n            require(royalties <= price, \"Invalid royalties\");\n            uint256 paid = price - royalties;\n\n            /// Transfer amount to previous payee\n            if (paid > 0) {\n                payable(payee).transfer(paid);\n                unspent = unspent - paid;\n            }\n\n            /// Transfer royalties to receiver\n            if (royalties > 0) {\n                payable(receiver).transfer(royalties);\n                unspent = unspent - royalties;\n            }\n\n            emit Pay(tokenID, price, payer, payee);\n        }\n\n        /// Transfer back unspent funds to payer\n        if (unspent > 0) payable(payer).transfer(unspent);\n    }\n\n    function _setTokenRoyalty(\n        uint256 tokenID,\n        address receiver,\n        uint96 fee\n    ) private {\n        _tokenRoyaltyInfo[tokenID] = RoyaltyInfo(receiver, fee);\n\n        emit SetTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function _setTokenPrice(uint256 tokenID, uint256 price) private {\n        tokenPrice[tokenID] = price;\n\n        emit SetTokenPrice(tokenID, price);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenPauseable –– IOpenPauseable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseable is IOpenPauseable, OpenERC173 {\n    bool private _paused;\n\n    modifier onlyWhenNotPaused() {\n        require(!_paused, \"Paused!\");\n        _;\n    }\n\n    function togglePause() external override(IOpenPauseable) onlyOwner {\n        _setPaused(!_paused);\n    }\n\n    function paused() external view override(IOpenPauseable) returns (bool) {\n        return _paused;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC173) returns (bool) {\n        return interfaceId == type(IOpenPauseable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _setPaused(bool paused_) private {\n        _paused = paused_;\n        emit SetPaused(_paused, msg.sender);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenCloneable —— IOpenCloneable\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloneable is IOpenCloneable, OpenERC165 {\n    bool public initialized;\n    string public template;\n    uint256 public version;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC165) returns (bool) {\n        return interfaceId == type(IOpenCloneable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory template_, uint256 version_) internal {\n        require(initialized == false, \"Only once!\");\n        initialized = true;\n\n        template = template_;\n        version = version_;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-173: Contract Ownership Standard\n// https://eips.ethereum.org/EIPS/eip-173\n//\n// Derived from OpenZeppelin Contracts (access/Ownable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/access/Ownable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC173 —— IERC173\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenERC173 is IERC173, OpenERC165 {\n    bool private _openERC173Initialized;\n    address private _owner;\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Not owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external override(IERC173) onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function owner() public view override(IERC173) returns (address) {\n        return _owner;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC165) returns (bool) {\n        return interfaceId == 0x7f5828d0 || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(address owner_) internal {\n        require(_openERC173Initialized == false, \"Init already call\");\n        _openERC173Initialized = true;\n\n        _transferOwnership(owner_);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-2981: NFT Royalty Standard\n// https://eips.ethereum.org/EIPS/eip-2981\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/common/ERC2981.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC2981 —— IERC2981\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nabstract contract OpenERC2981 is IERC2981, OpenERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 fraction;\n    }\n\n    RoyaltyInfo internal _royaltyInfo;\n    mapping(uint256 => RoyaltyInfo) internal _tokenRoyaltyInfo;\n\n    uint96 private constant _MAX_FEE = 10000;\n\n    modifier notTooExpensive(uint256 price) {\n        /// otherwise may overflow\n        require(price < 2**128, \"Too expensive\");\n        _;\n    }\n\n    modifier lessThanMaxFee(uint256 fee) {\n        require(fee <= _MAX_FEE, \"Royalty fee exceed price\");\n        _;\n    }\n\n    function royaltyInfo(uint256 tokenID, uint256 price)\n        public\n        view\n        override(IERC2981)\n        notTooExpensive(price)\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenID];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _royaltyInfo;\n        }\n\n        royaltyAmount = (price * royalty.fraction) / _MAX_FEE;\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC165) returns (bool) {\n        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenMarketable {\n    event SetDefaultRoyalty(address receiver, uint96 fee);\n\n    event SetTokenRoyalty(uint256 tokenID, address receiver, uint96 fee);\n\n    event SetDefaultPrice(uint256 price);\n\n    event SetTokenPrice(uint256 tokenID, uint256 price);\n\n    event Pay(uint256 tokenID, uint256 price, address payer, address payee);\n\n    receive() external payable;\n\n    function defaultPrice() external returns (uint256 defPrice);\n\n    function tokenPrice(uint256 tokenID) external returns (uint256 price);\n\n    function setDefaultRoyalty(address receiver, uint96 fee) external;\n\n    function setTokenRoyalty(\n        uint256 tokenID,\n        address receiver,\n        uint96 fee\n    ) external;\n\n    function setDefaultPrice(uint256 price) external;\n\n    function setTokenPrice(uint256 tokenID) external;\n\n    function setTokenPrice(uint256 tokenID, uint256 price) external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function transferOwnership(address newOwner) external;\n\n    function owner() external view returns (address currentOwner);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC2981 {\n    function royaltyInfo(uint256 tokenID, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenPauseable {\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function paused() external returns (bool);\n\n    function togglePause() external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenCloneable {\n    function initialized() external view returns (bool);\n\n    function template() external view returns (string memory);\n\n    function version() external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC4973.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\n"
    },
    "contracts/next/NFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//    OpenERC165\n//        |\n//  OpenResolver\n//        |\n//  NFTsResolver —— INFTsResolver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenResolver.sol\";\nimport \"../interfaces/INFTsResolver.sol\";\nimport \"../interfaces/IAll.sol\";\n\ncontract NFTsResolver is INFTsResolver, OpenResolver {\n    bytes4[] private _interfaceIds = new bytes4[](11);\n\n    function initialize(address owner_) external override(INFTsResolver) {\n        OpenERC173._initialize(owner_);\n\n        uint256 i;\n\n        _interfaceIds[i++] = type(IOpenNFTs).interfaceId;\n        _interfaceIds[i++] = type(IOpenChecker).interfaceId;\n        _interfaceIds[i++] = type(IOpenCloneable).interfaceId;\n        _interfaceIds[i++] = type(IOpenMarketable).interfaceId;\n        _interfaceIds[i++] = type(IOpenPauseable).interfaceId;\n\n        _interfaceIds[i++] = type(IOpenNFTsV0).interfaceId;\n        _interfaceIds[i++] = type(IOpenNFTsV1).interfaceId;\n        _interfaceIds[i++] = type(IOpenNFTsV2).interfaceId;\n        _interfaceIds[i++] = type(IOpenNFTsV3).interfaceId;\n        _interfaceIds[i++] = type(IOpenNFTsV4).interfaceId;\n        _interfaceIds[i++] = type(IOpenBound).interfaceId;\n    }\n\n    function getNFTsResolverCollectionInfos(address collection, address account)\n        external\n        view\n        override(INFTsResolver)\n        returns (CollectionInfos memory collectionInfos)\n    {\n        collectionInfos = _getCollectionInfos(collection, account, _interfaceIds);\n    }\n\n    function getNFTsResolverCollectionsInfos(address account)\n        external\n        view\n        override(INFTsResolver)\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        collectionsInfos = _getCollectionsInfos(account, _interfaceIds);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(OpenResolver) returns (bool) {\n        return interfaceId == type(INFTsResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.9;\n\ninterface IERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155METADATAURI.sol)\n\npragma solidity ^0.8.9;\n\ninterface IERC1155MetadataURI {\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155TokenReceiver.sol)\n\npragma solidity ^0.8.9;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external returns (bytes4);\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC4973 {\n    event Attest(address indexed to, uint256 indexed tokenID);\n\n    // event Revoke(address indexed to, uint256 indexed tokenID);\n\n    function ownerOf(uint256 tokenID) external view returns (address);\n\n    // function burn(uint256 tokenID) external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenChecker {\n    function checkErcInterfaces(address smartcontract) external view returns (bool[] memory interfaceIdsChecks);\n\n    function checkSupportedInterfaces(\n        address smartcontract,\n        bool erc,\n        bytes4[] memory interfaceIds\n    ) external view returns (bool[] memory interfaceIdsChecks);\n\n    function isCollection(address collection) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//        ————————————————\n//        |              |\n//   OpenChecker     OpenERC173\n//        |              |\n//    OpenGetter    OpenRegistry\n//        |              |\n//        ————————————————\n//        |\n//  OpenResolver —— IOpenResolver\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenRegistry.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenResolver.sol\";\n\nabstract contract OpenResolver is IOpenResolver, OpenRegistry, OpenGetter {\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address addr) override(OpenRegistry) {\n        require(isCollection(addr), \"Not Collection\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenRegistry, OpenGetter)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    ) public view override(IOpenResolver) returns (CollectionInfos[] memory collectionsInfos) {\n        collectionsInfos = new CollectionInfos[](collections.length);\n        for (uint256 i = 0; i < collections.length; i++) {\n            collectionsInfos[i] = _getCollectionInfos(collections[i], account, interfaceIds);\n        }\n    }\n\n    function _getCollectionsInfos(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        CollectionInfos[] memory collectionsInfosAll = getCollectionsInfos(getAddresses(), account, interfaceIds);\n\n        uint256 len;\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) len++;\n        }\n\n        collectionsInfos = new CollectionInfos[](len);\n\n        uint256 j;\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account)\n                collectionsInfos[j++] = collectionsInfosAll[i];\n        }\n    }\n}\n"
    },
    "contracts/interfaces/INFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Infos.sol\";\n\ninterface INFTsResolver is IERC721Infos {\n    function initialize(address owner) external;\n\n    function getNFTsResolverCollectionsInfos(address account)\n        external\n        view\n        returns (CollectionInfos[] memory collectionsInfos);\n\n    function getNFTsResolverCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos);\n}\n"
    },
    "contracts/interfaces/IAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Infos.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC20.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport \"./ICloneFactory.sol\";\nimport \"./ICloneFactoryV2.sol\";\nimport \"./INFTsFactory.sol\";\nimport \"./INFTsFactoryV2.sol\";\nimport \"./INFTsFactoryV3.sol\";\n\nimport \"./IOpenNFTsV0.sol\";\nimport \"./IOpenNFTsV1.sol\";\nimport \"./IOpenNFTsV2.sol\";\nimport \"./IOpenNFTsV3.sol\";\nimport \"./IOpenNFTsV4.sol\";\nimport \"./IOpenBound.sol\";\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenRegistry —— IOpenRegistry\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\nimport \"forge-std/console.sol\";\n\nabstract contract OpenRegistry is IOpenRegistry, OpenERC173 {\n    mapping(address => bool) public isRegistered;\n    address[] private _addresses;\n\n    /// @notice onlyRegisterer, by default owner is registerer and can add addresses, can be overriden\n    modifier onlyRegisterer() virtual {\n        require(msg.sender == owner(), \"Not registerer\");\n        _;\n    }\n\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address) virtual {\n        _;\n    }\n\n    function addAddresses(address[] memory addrs) external override(IOpenRegistry) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            _addAddress(addrs[i]);\n        }\n    }\n\n    function addAddress(address addr) external override(IOpenRegistry) {\n        _addAddress(addr);\n    }\n\n    function removeAddress(uint256 index) external override(IOpenRegistry) {\n        _removeAddress(index);\n    }\n\n    function countAddresses() external view override(IOpenRegistry) returns (uint256) {\n        return _addresses.length;\n    }\n\n    function getAddresses() public view override(IOpenRegistry) returns (address[] memory) {\n        return _addresses;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC173) returns (bool) {\n        return interfaceId == type(IOpenRegistry).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _addAddress(address addr) private onlyRegisterer onlyValid(addr) {\n        require(!isRegistered[addr], \"Already registered\");\n\n        _addresses.push(addr);\n        isRegistered[addr] = true;\n    }\n\n    function _removeAddress(uint256 index) private onlyRegisterer {\n        require(index < _addresses.length, \"Invalid index\");\n        require(isRegistered[_addresses[index]], \"Not registered\");\n\n        delete (isRegistered[_addresses[index]]);\n        if (index != _addresses.length - 1) _addresses[index] = _addresses[_addresses.length - 1];\n        _addresses.pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenChecker\n//        |\n//  OpenGetter —— IOpenGetter\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenGetter is IOpenGetter, OpenChecker {\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenChecker) returns (bool) {\n        return interfaceId == type(IOpenGetter).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionInfos(address collection)\n        public\n        view\n        override(IOpenGetter)\n        returns (CollectionInfos memory collectionInfos)\n    {\n        collectionInfos = _getCollectionInfos(collection, msg.sender, new bytes4[](0));\n    }\n\n    function _getCollectionInfos(\n        address collection,\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (CollectionInfos memory collectionInfos) {\n        require(collection.code.length != 0, \"Not smartcontract\");\n\n        bool[] memory supported = checkSupportedInterfaces(collection, true, interfaceIds);\n        collectionInfos.supported = supported;\n\n        // ERC165 must be supported\n        require(!supported[0] && supported[1], \"Not ERC165\");\n\n        // ERC721 or ERC1155 must be supported\n        require(supported[2] || supported[6], \"Not NFT smartcontract\");\n\n        collectionInfos.collection = collection;\n\n        // IF ERC173 supported\n        if (supported[9]) {\n            collectionInfos.owner = IERC173(collection).owner();\n        }\n\n        // IF ERC721 supported\n        if (supported[2]) {\n            // IF ERC721Metadata supported\n            if (supported[3]) {\n                collectionInfos.name = IERC721Metadata(collection).name();\n                collectionInfos.symbol = IERC721Metadata(collection).symbol();\n            }\n\n            // IF ERC721Enumerable supported\n            if (supported[4]) {\n                collectionInfos.totalSupply = IERC721Enumerable(collection).totalSupply();\n            }\n\n            if (account != address(0)) {\n                collectionInfos.balanceOf = IERC721(collection).balanceOf(account);\n            }\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Infos.sol\";\n\ninterface IOpenResolver is IERC721Infos {\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    ) external view returns (CollectionInfos[] memory collectionsInfos);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenRegistry {\n    function removeAddress(uint256 index) external;\n\n    function addAddress(address addr) external;\n\n    function addAddresses(address[] memory addrs) external;\n\n    function getAddresses() external view returns (address[] memory);\n\n    function countAddresses() external view returns (uint256);\n\n    function isRegistered(address addr) external view returns (bool registered);\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenChecker —— IOpenChecker\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\n\nabstract contract OpenChecker is IOpenChecker, OpenERC165 {\n    /// _ercInterfaceIds : ERC interfacesIds\n    /// 0xffffffff :  O Invalid\n    /// 0x01ffc9a7 :  1 ERC165\n    /// 0x80ac58cd :  2 ERC721\n    /// 0x5b5e139f :  3 ERC721Metadata\n    /// 0x780e9d63 :  4 ERC721Enumerable\n    /// 0x150b7a02 :  5 ERC721TokenReceiver\n    /// 0xd9b67a26 :  6 ERC1155\n    /// 0x0e89341c :  7 ERC1155MetadataURI\n    /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n    /// 0x7f5828d0 :  9 ERC173\n    /// 0x2a55205a : 10 ERC2981\n    bytes4[] private _ercInterfaceIds = [\n        bytes4(0xffffffff),\n        bytes4(0x01ffc9a7),\n        bytes4(0x80ac58cd),\n        bytes4(0x5b5e139f),\n        bytes4(0x780e9d63),\n        bytes4(0x150b7a02),\n        bytes4(0xd9b67a26),\n        bytes4(0x0e89341c),\n        bytes4(0x4e2312e0),\n        bytes4(0x7f5828d0),\n        bytes4(0x2a55205a)\n    ];\n\n    function isCollection(address collection) public view override(IOpenChecker) returns (bool) {\n        bool[] memory checks = checkErcInterfaces(collection);\n\n        return !checks[0] && checks[1] && (checks[2] || checks[6]);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC165) returns (bool) {\n        return interfaceId == type(IOpenChecker).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function checkErcInterfaces(address smartcontract)\n        public\n        view\n        override(IOpenChecker)\n        returns (bool[] memory ercInterfacesChecks)\n    {\n        ercInterfacesChecks = checkSupportedInterfaces(smartcontract, true, new bytes4[](0));\n    }\n\n    function checkSupportedInterfaces(\n        address smartcontract,\n        bool erc,\n        bytes4[] memory interfaceIds\n    ) public view override(IOpenChecker) returns (bool[] memory interfaceIdsChecks) {\n        uint256 i;\n        uint256 len = (erc ? _ercInterfaceIds.length : 0) + interfaceIds.length;\n\n        interfaceIdsChecks = new bool[](len);\n\n        if (erc) {\n            for (uint256 j = 0; j < _ercInterfaceIds.length; j++) {\n                interfaceIdsChecks[i++] = IERC165(smartcontract).supportsInterface(_ercInterfaceIds[j]);\n            }\n        }\n        for (uint256 k = 0; k < interfaceIds.length; k++) {\n            interfaceIdsChecks[i++] = IERC165(smartcontract).supportsInterface(interfaceIds[k]);\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Infos.sol\";\n\ninterface IOpenGetter is IERC721Infos {\n    function getCollectionInfos(address collection) external view returns (CollectionInfos memory collectionInfos);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Infos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721Infos {\n    struct CollectionInfos {\n        address collection;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n        uint256 balanceOf;\n        bool[] supported;\n    }\n}\n"
    },
    "contracts/interfaces/ICloneFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICloneFactoryV2 {\n    /// @notice New Implementation Event\n    /// @param implementation Address of the implementation\n    /// @param creator Address of the creator\n    /// @return index Index inside implementations array (starts at 0)\n    event ImplementationNew(address indexed implementation, address indexed creator, uint256 index);\n\n    /// @notice Set Template Event\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    event TemplateSet(string indexed templateName, address indexed template);\n\n    /// @notice Set Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template) external;\n\n    /// @notice Add Implementation\n    /// @param implementationToAdd Addresses of implementations to add\n    function implementationsAdd(address[] calldata implementationToAdd) external;\n\n    /// @notice Get Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templates(string calldata templateName) external view returns (address template);\n\n    /// @notice Count Implementations\n    /// @return count Number of implementations\n    function implementationsCount() external view returns (uint256 count);\n\n    /// @notice Get Implementation from Implementations array\n    /// @param index Index of implementation\n    /// @return implementation Address of implementation\n    function implementations(uint256 index) external view returns (address implementation);\n}\n"
    },
    "contracts/interfaces/INFTsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface INFTsFactoryV2 {\n    struct NftData {\n        address nft;\n        uint256 balanceOf;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external returns (address);\n\n    function balancesOf(address owner) external view returns (NftData[] memory);\n}\n"
    },
    "contracts/interfaces/INFTsFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface INFTsFactoryV3 {\n    event Clone(string indexed templateName, address indexed clone, string indexed name, string symbol, bool[] options);\n\n    event SetResolver(address indexed resolver);\n\n    event SetTemplate(string indexed templateName, address indexed template, uint256 index);\n\n    function setResolver(address resolver) external;\n\n    function setTemplate(string memory templateName, address template) external;\n\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external returns (address);\n\n    function template(string memory templateName) external view returns (address);\n\n    function templates(uint256 num) external view returns (address);\n\n    function countTemplates() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV0 {\n    function addUser(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV1 {\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "contracts/interfaces/IOpenNFTsV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenNFTsV3 {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bool[] memory options\n    ) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenBound {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        uint256 maxSupply\n    ) external;\n\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getTokenID(address addr, uint256 cid) external view returns (uint256 tokenID);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n}\n"
    },
    "contracts/testsOld/OpenNFTs.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"../../lib/forge-std/src/Test.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\n\nimport \"../next/OpenNFTsV4.sol\";\n\ncontract OpenNFTsOldTest is Test {\n    OpenNFTsV4 internal op;\n    OpenNFTsV4 internal opn;\n    bytes4 internal opId;\n\n    address owner = address(0x1);\n    address minter = address(0x2);\n    address buyer = address(0x3);\n    address tester = address(0x4);\n\n    string internal constant _TOKEN_URI = \"ipfs://bafkreidfhassyaujwpbarjwtrc6vgn2iwfjmukw3v7hvgggvwlvdngzllm\";\n\n    uint96 maxFee = 10000;\n    uint256 maxPrice = uint256(((2**256) - 1)) / maxFee;\n    uint256 tokenID0;\n    uint256 notTokenID = 42;\n\n    bool[] options = new bool[](1);\n\n    function setUp() public {\n        op = new OpenNFTsV4();\n        opn = new OpenNFTsV4();\n        opId = type(IOpenNFTsV4).interfaceId;\n        options[0] = true;\n\n        changePrank(owner);\n        op.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n\n        changePrank(minter);\n        tokenID0 = op.mint(_TOKEN_URI);\n    }\n}\n"
    },
    "lib/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "lib/forge-std/src/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapated from Solmate implementation (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))));\n    }\n\n    function addressFromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n}\n"
    },
    "lib/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns(uint256);\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns(bool);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata,uint256) external returns(uint256);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns(uint256);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns(uint256);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    /// Returns the RPC url for the given alias\n\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address) external;\n    function makePersistent(address, address) external;\n    function makePersistent(address, address, address) external;\n    function makePersistent(address[] calldata) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address) external;\n    function revokePersistent(address[] calldata) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address) external returns (bool);\n\n    function rpcUrl(string calldata) external returns(string memory);\n    /// Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns(string[2][] memory);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n}\n"
    },
    "lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "contracts/testsOld/OpenPriceable.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenMarketableTest is OpenNFTsOldTest {\n    function testSetDefaultRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price < 2**128);\n        vm.assume(fee < 10000);\n\n        changePrank(owner);\n        op.setDefaultRoyalty(tester, fee);\n\n        (address receiver, uint256 royalties) = op.royaltyInfo(tokenID0, price);\n        assertEq(receiver, tester);\n        assertEq(royalties, (price * fee) / maxFee);\n    }\n\n    function testSetTokenRoyalty(uint96 fee, uint256 price) public {\n        vm.assume(price < 2**128);\n        vm.assume(fee < 10000);\n\n        changePrank(minter);\n        op.setTokenRoyalty(tokenID0, tester, fee);\n\n        (address receiver, uint256 royalties) = op.royaltyInfo(tokenID0, price);\n        assertEq(receiver, tester);\n        assertEq(royalties, (price * fee) / maxFee);\n    }\n\n    function testFailSetTokenRoyaltyNoToken() public {\n        op.setTokenRoyalty(notTokenID, tester, 100);\n    }\n\n    function testSetTokenPrice(uint256 price) public {\n        vm.assume(price < 2**128);\n        op.setTokenPrice(tokenID0, price);\n        assertEq(op.tokenPrice(tokenID0), price);\n    }\n\n    function testSetTokenPriceFromDefault(uint256 price) public {\n        vm.assume(price < 2**128);\n        vm.assume(price != 0);\n\n        changePrank(minter);\n        op.setTokenPrice(tokenID0);\n        assertEq(op.tokenPrice(tokenID0), 0);\n\n        changePrank(owner);\n        op.setDefaultPrice(price);\n\n        changePrank(minter);\n        op.setTokenPrice(tokenID0);\n        assertEq(op.tokenPrice(tokenID0), price);\n    }\n\n    function testFailSetDefaultPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2**128);\n        changePrank(owner);\n        op.setDefaultPrice(price);\n    }\n\n    function testFailSetTokenPriceTooExpensive(uint256 price) public {\n        vm.assume(price > 2**128);\n        op.setTokenPrice(tokenID0, price);\n    }\n\n    function testFailSetTokenPriceNoToken() public {\n        op.setTokenPrice(notTokenID, 1 ether);\n    }\n\n    function testRoyaltyInfoCalculation(uint256 price, uint96 fee) public {\n        address _collection = address(op);\n\n        vm.assume(price < 2**128);\n        vm.assume(fee < maxFee);\n\n        changePrank(owner);\n        IOpenMarketable(payable(_collection)).setDefaultRoyalty(minter, fee);\n\n        (address receiver, uint256 royalties) = IERC2981(_collection).royaltyInfo(tokenID0, price);\n        assertEq(receiver, minter);\n        assertEq(royalties, (price * fee) / maxFee);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IOpenMarketable).interfaceId));\n    }\n}\n"
    },
    "contracts/testsOld/OpenPausable.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenPauseableTest is OpenNFTsOldTest {\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function testOnlyWhenNotPaused() public {\n        changePrank(minter);\n        op.mint(_TOKEN_URI);\n    }\n\n    function testFailOnlyWhenNotPaused() public {\n        changePrank(minter);\n        op.togglePause();\n        op.mint(_TOKEN_URI);\n    }\n\n    function testTogglePause() public {\n        changePrank(owner);\n        assertEq(op.paused(), false);\n\n        op.togglePause();\n        assertEq(op.paused(), true);\n\n        op.togglePause();\n        assertEq(op.paused(), false);\n    }\n\n    function testEmitSetPause() public {\n        changePrank(owner);\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(true, owner);\n        op.togglePause();\n\n        vm.expectEmit(true, true, false, false);\n        emit SetPaused(false, owner);\n        op.togglePause();\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IOpenPauseable).interfaceId));\n    }\n}\n"
    },
    "contracts/testsOld/OpenNFTs-token-owner.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenNFTsTokenOwnerTest is OpenNFTsOldTest {\n    function testTokenOwner() public {\n        changePrank(minter);\n        op.setTokenRoyalty(tokenID0, tester, 100);\n        op.setTokenPrice(tokenID0, 1 ether);\n    }\n\n    function testFailSetTokenRoyaltyNotOwner() public {\n        changePrank(buyer);\n        op.setTokenRoyalty(tokenID0, tester, 100);\n    }\n\n    function testFailSetTokenPriceNotOwner() public {\n        changePrank(buyer);\n        op.setTokenPrice(tokenID0, 1 ether);\n    }\n}\n"
    },
    "contracts/testsOld/OpenNFTs-setup.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenNFTsSetupTest is OpenNFTsOldTest {\n    function testContract() public {\n        assertEq(op.name(), \"OpenNFTsOldTest\");\n        assertEq(op.symbol(), \"OPTEST\");\n        assertEq(op.owner(), owner);\n        assertEq(op.open(), true);\n    }\n\n    function testCount() public {\n        assertEq(op.totalSupply(), 1);\n        assertEq(op.balanceOf(minter), 1);\n        assertEq(op.tokenIdNext(), 2);\n    }\n\n    function testToken() public {\n        assertEq(op.tokenByIndex(0), 1);\n        assertEq(op.tokenOfOwnerByIndex(minter, 0), 1);\n        assertEq(op.ownerOf(1), minter);\n        assertEq(op.tokenURI(1), _TOKEN_URI);\n    }\n\n    function testPrice() public {\n        assertEq(op.tokenPrice(1), 0);\n    }\n\n    function testRoyalties() public {\n        (address receiver, uint256 royalties) = op.royaltyInfo(1, 1);\n        assertEq(receiver, address(0));\n        assertEq(royalties, 0);\n    }\n}\n"
    },
    "contracts/testsOld/OpenNFTs-intitialize.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenNFTsInitializeTest is OpenNFTsOldTest {\n    function testInitialize() public {\n        assertEq(options[0], true);\n        changePrank(owner);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n        assertEq(opn.open(), true);\n    }\n\n    function testInitializeNotOpen() public {\n        options[0] = false;\n        changePrank(owner);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n        assertEq(opn.open(), false);\n    }\n\n    function testFailInitializeTwice() public {\n        options[0] = false;\n        changePrank(owner);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n        opn.initialize(\"OpenNFTsOldTestTwice\", \"OPTEST2\", owner, 0, address(0), 0, options);\n    }\n}\n"
    },
    "contracts/testsOld/OpenNFTs-buy.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenNFTsBuyTest is OpenNFTsOldTest {\n    function testBuyOk() public {\n        changePrank(minter);\n        IERC721(op).setApprovalForAll(address(op), true);\n\n        op.setTokenRoyalty(tokenID0, tester, 100);\n        op.setTokenPrice(tokenID0, 1 ether);\n\n        changePrank(buyer);\n        deal(buyer, 10 ether);\n        uint256 balMinter = minter.balance;\n\n        assertEq(op.ownerOf(tokenID0), minter);\n        op.buy{value: 1.5 ether}(tokenID0);\n        assertEq(op.ownerOf(tokenID0), buyer);\n\n        assertEq(buyer.balance, 9 ether);\n        assertEq(address(op).balance, 0 ether);\n        assertEq(tester.balance, 0.01 ether);\n        assertEq(minter.balance, balMinter + 0.99 ether);\n    }\n\n    function testFailBuyTwice() public {\n        op.setTokenRoyalty(tokenID0, tester, 100);\n        op.setTokenPrice(tokenID0, 1 ether);\n\n        changePrank(buyer);\n        deal(buyer, 10 ether);\n\n        op.buy{value: 1 ether}(tokenID0);\n        op.buy{value: 1 ether}(tokenID0);\n    }\n\n    function testFailBuyNotEnoughFunds() public {\n        op.setTokenRoyalty(tokenID0, tester, 100);\n        op.setTokenPrice(tokenID0, 1 ether);\n\n        changePrank(buyer);\n        deal(buyer, 10 ether);\n\n        op.buy{value: 0.5 ether}(tokenID0);\n    }\n\n    function testFailBuyNotToSell() public {\n        op.setTokenPrice(tokenID0, 0);\n\n        changePrank(buyer);\n        deal(buyer, 10 ether);\n\n        assertEq(op.ownerOf(tokenID0), minter);\n        op.buy{value: 1 ether}(tokenID0);\n    }\n}\n"
    },
    "contracts/testsOld/OpenNFTs-burn.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenNFTsBurnTest is OpenNFTsOldTest {\n    function testBurn() public {\n        uint256 totalSupply = op.totalSupply();\n        op.burn(tokenID0);\n        assertEq(op.totalSupply(), totalSupply - 1);\n    }\n\n    function testFailBurnTokenByIndex() public {\n        op.burn(tokenID0);\n        op.tokenByIndex(0);\n    }\n\n    function testFailBurnTokenOfOwnerByIndex() public {\n        op.burn(tokenID0);\n        op.tokenOfOwnerByIndex(minter, 0);\n    }\n\n    function testBurnSecondOne() public {\n        changePrank(tester);\n        uint256 tokenID = op.mint(_TOKEN_URI);\n        op.burn(tokenID);\n\n        assertEq(op.totalSupply(), 1);\n        assertEq(op.tokenByIndex(0), tokenID0);\n        assertEq(op.tokenOfOwnerByIndex(minter, 0), tokenID0);\n    }\n\n    function testFailBurnSecondOneTokenByIndex() public {\n        changePrank(tester);\n        uint256 tokenID = op.mint(_TOKEN_URI);\n        op.burn(tokenID);\n        op.tokenByIndex(1);\n    }\n\n    function testFailBurnSecondOneTokenOfOwnerByIndex() public {\n        changePrank(tester);\n        uint256 tokenID = op.mint(_TOKEN_URI);\n        op.burn(tokenID);\n        op.tokenOfOwnerByIndex(tester, 0);\n    }\n}\n"
    },
    "contracts/testsOld/OpenERC721Metadata.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenERC721MetadataTest is OpenNFTsOldTest {\n    function testInitialize() public {\n        changePrank(owner);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n\n        assertEq(opn.name(), \"OpenNFTsOldTest\");\n        assertEq(opn.symbol(), \"OPTEST\");\n    }\n\n    function testFailInitializeTwice() public {\n        changePrank(owner);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n    }\n\n    function testName() public {\n        assertEq(op.name(), \"OpenNFTsOldTest\");\n    }\n\n    function testSymbol() public {\n        assertEq(op.symbol(), \"OPTEST\");\n    }\n\n    function testURI() public {\n        assertEq(op.tokenURI(tokenID0), _TOKEN_URI);\n    }\n\n    function testFull() public {\n        changePrank(minter);\n        opn.initialize(\"NAME_TEST\", \"SYMBOL_TEST\", minter, 0, address(0), 0, options);\n\n        assertEq(opn.name(), \"NAME_TEST\");\n        assertEq(opn.symbol(), \"SYMBOL_TEST\");\n\n        uint256 tokenID = opn.mint(\"URL_TEST\");\n        assertEq(opn.tokenURI(tokenID), \"URL_TEST\");\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IERC721Metadata).interfaceId));\n    }\n}\n"
    },
    "contracts/testsOld/OpenERC721Enumerable.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenERC721EnumerableTest is OpenNFTsOldTest {\n    function testTotalSupply() public {\n        assertEq(op.totalSupply(), 1);\n        op.mint(_TOKEN_URI);\n        assertEq(op.totalSupply(), 2);\n        op.mint(_TOKEN_URI);\n        assertEq(op.totalSupply(), 3);\n    }\n\n    function testTokenByIndex() public {\n        assertEq(op.tokenByIndex(0), 1);\n        op.mint(_TOKEN_URI);\n        assertEq(op.tokenByIndex(1), 2);\n    }\n\n    function testTokenOfOwnerByIndex() public {\n        assertEq(op.tokenOfOwnerByIndex(minter, 0), 1);\n        op.mint(_TOKEN_URI);\n        assertEq(op.tokenOfOwnerByIndex(minter, 1), 2);\n        changePrank(tester);\n        op.mint(_TOKEN_URI);\n        assertEq(op.tokenOfOwnerByIndex(minter, 1), 2);\n        assertEq(op.tokenOfOwnerByIndex(tester, 0), 3);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IERC721Enumerable).interfaceId));\n    }\n}\n"
    },
    "contracts/testsOld/OpenERC721.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenERC721Test is OpenNFTsOldTest {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function testBalanceOf() public {\n        assertEq(op.balanceOf(minter), 1);\n        assertEq(op.balanceOf(tester), 0);\n    }\n\n    function testOwnerOf() public {\n        assertEq(op.ownerOf(1), minter);\n        op.mint(_TOKEN_URI);\n        assertEq(op.ownerOf(2), minter);\n    }\n\n    function testSafeTransferFrom() public {\n        op.safeTransferFrom(minter, tester, 1);\n        assertEq(op.ownerOf(1), tester);\n    }\n\n    function testSafeTransferFromWithData() public {\n        op.safeTransferFrom(minter, tester, 1, \"data\");\n        assertEq(op.ownerOf(1), tester);\n    }\n\n    function testSafeTransferFromEmit() public {\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(minter, tester, 1);\n        op.safeTransferFrom(minter, tester, 1);\n    }\n\n    function testSafeTransferFromWithDataEmit() public {\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(minter, tester, 1);\n        op.safeTransferFrom(minter, tester, 1, \"data\");\n    }\n\n    function testSafeTransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        changePrank(from);\n        op.mint(_TOKEN_URI);\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, 2);\n        op.safeTransferFrom(from, to, 2);\n        assertEq(op.ownerOf(2), to);\n    }\n\n    function testFailSafeTransferFromNotERC721TokenReceiver() public {\n        op.safeTransferFrom(minter, address(op), 1);\n    }\n\n    function testTransferFromNotERC721TokenReceiver() public {\n        op.transferFrom(minter, address(op), 1);\n        assertEq(op.ownerOf(1), address(op));\n    }\n\n    function testTransferFrom() public {\n        op.transferFrom(minter, tester, 1);\n        assertEq(op.ownerOf(1), tester);\n    }\n\n    function testTransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        changePrank(from);\n        op.mint(_TOKEN_URI);\n        vm.expectEmit(true, true, true, false);\n        emit Transfer(from, to, 2);\n        op.transferFrom(from, to, 2);\n        assertEq(op.ownerOf(2), to);\n    }\n\n    function testOnlyTokenOwner() public {\n        changePrank(minter);\n        op.burn(tokenID0);\n    }\n\n    function testFailOnlyTokenOwner() public {\n        changePrank(tester);\n        op.burn(tokenID0);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IERC721).interfaceId));\n    }\n}\n"
    },
    "contracts/testsOld/OpenERC2981.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenERC2981Test is OpenNFTsOldTest {\n    function testRoyaltyInfo(uint256 price) public {\n        vm.assume(price < 2**128);\n        op.royaltyInfo(tokenID0, price);\n    }\n\n    function testFailRoyaltyInfoTooExpensive(uint256 price) public {\n        vm.assume(price >= 2**128);\n        op.royaltyInfo(tokenID0, price);\n    }\n\n    function testRoyaltyInfoCalculation(uint256 price, uint96 fee) public {\n        vm.assume(price < 2**128);\n        vm.assume(fee < maxFee);\n\n        changePrank(owner);\n        op.setDefaultRoyalty(minter, fee);\n\n        (address receiver, uint256 royalties) = op.royaltyInfo(tokenID0, price);\n        assertEq(receiver, minter);\n        assertEq(royalties, (price * fee) / maxFee);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IERC2981).interfaceId));\n    }\n}\n"
    },
    "contracts/testsOld/OpenERC173.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenERC173Text is OpenNFTsOldTest {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function testInitialize() public {\n        changePrank(owner);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n        assertEq(opn.owner(), owner);\n    }\n\n    function testFailInitializeTwice() public {\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", owner, 0, address(0), 0, options);\n        opn.initialize(\"OpenNFTsOldTest\", \"OPTEST\", tester, 0, address(0), 0, options);\n    }\n\n    function testOwner() public {\n        assertEq(op.owner(), owner);\n    }\n\n    function testOnlyOwner() public {\n        changePrank(owner);\n        op.togglePause();\n    }\n\n    function testFailOnlyOwner() public {\n        changePrank(tester);\n        op.togglePause();\n    }\n\n    function testTransferOwnership() public {\n        changePrank(owner);\n        op.transferOwnership(tester);\n        assertEq(op.owner(), tester);\n    }\n\n    function testEmitTransferOwnership() public {\n        changePrank(owner);\n        vm.expectEmit(true, true, false, false);\n        emit OwnershipTransferred(owner, tester);\n        op.transferOwnership(tester);\n    }\n\n    function testFailTransferOwnership() public {\n        changePrank(tester);\n        op.transferOwnership(minter);\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IERC173).interfaceId));\n    }\n}\n"
    },
    "contracts/NFTsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IOpenNFTsV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./CloneFactoryV2.sol\";\nimport \"./interfaces/INFTsFactoryV2.sol\";\nimport \"./interfaces/IOpenNFTs.old.sol\";\nimport \"./interfaces/IERC173.sol\";\n\n/// @title NFTsFactory smartcontract\n/// @dev is CloneFactory\n/// @notice Templates are OPEN_NFTS contracts\n/// @notice Implementations are ERC721 contracts (including OPEN_NFTS clones)\n/// @notice Factory can clone OPEN_NFTs templates to implementations\n/// @notice Factory can also add ERC721 contracts to implementations\ncontract NFTsFactoryV2 is CloneFactoryV2, INFTsFactoryV2 {\n    using ERC165Checker for address;\n\n    uint8 internal constant _IERC721 = 0;\n    uint8 internal constant _IERC721_METADATA = 1;\n    uint8 internal constant _IERC721_ENUMERABLE = 2;\n    uint8 internal constant _IERC173 = 3;\n    uint8 internal constant _IOPEN_NFTS = 4;\n\n    bytes4 internal constant _IERC721_SIG = bytes4(0x80ac58cd);\n    bytes4 internal constant _IERC721_METADATA_SIG = bytes4(0x780e9d63);\n    bytes4 internal constant _IERC721_ENUMERABLE_SIG = (0x780e9d63);\n    bytes4 internal constant _IERC173_SIG = bytes4(0x7f5828d0);\n    bytes4 internal constant _IOPEN_NFTS_SIG = type(IOpenNFTs).interfaceId;\n\n    constructor(address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    /// @notice clone template\n    /// @param name name of Clone collection\n    /// @param symbol symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external override(INFTsFactoryV2) returns (address clone_) {\n        clone_ = _clone(templateName);\n        IOpenNFTs(clone_).initialize(name, symbol, _msgSender(), options);\n    }\n\n    /// @notice balancesOf address for each implementations\n    /// @param addr  address of account\n    /// @return nftData Array of nftData balances\n    function balancesOf(address addr) external view override(INFTsFactoryV2) returns (NftData[] memory nftData) {\n        nftData = new NftData[](implementations.length);\n        for (uint256 i = 0; i < implementations.length; i += 1) {\n            nftData[i] = _balanceOf(implementations[i], addr);\n        }\n    }\n\n    /// @notice Set Template, overrides generic CloneFactory\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template) public override(CloneFactoryV2) onlyOwner {\n        require(template.supportsInterface(_IOPEN_NFTS_SIG), \"Not valid OpenNFTs Template\");\n\n        super.templateSet(templateName, template);\n    }\n\n    /// @notice New Implementation internal, overrides generic CloneFactory\n    /// @param  implementation : implementation address\n    function _implementationNew(address implementation) internal override(CloneFactoryV2) {\n        require(implementation.supportsInterface(_IERC721_SIG), \"Not ERC721\");\n\n        super._implementationNew(implementation);\n    }\n\n    /// @notice _balanceOf\n    /// @param nft nft address of NFT collection\n    /// @param owner address of account\n    /// @return nftData nftData balances\n    function _balanceOf(address nft, address owner) internal view returns (NftData memory nftData) {\n        bytes4[] memory iface = new bytes4[](5);\n        iface[_IERC721] = _IERC721_SIG;\n        iface[_IERC721_METADATA] = _IERC721_METADATA_SIG;\n        iface[_IERC721_ENUMERABLE] = _IERC721_ENUMERABLE_SIG;\n        iface[_IERC173] = _IERC173_SIG;\n\n        bool[] memory supportInterface = nft.getSupportedInterfaces(iface);\n\n        if (supportInterface[_IERC721]) {\n            nftData.nft = nft;\n            nftData.balanceOf = IERC721(nft).balanceOf(owner);\n\n            if (supportInterface[_IERC721_METADATA]) {\n                nftData.name = IERC721Metadata(nft).name();\n                nftData.symbol = IERC721Metadata(nft).symbol();\n            }\n\n            if (supportInterface[_IERC721_ENUMERABLE]) {\n                nftData.totalSupply = IERC721Enumerable(nft).totalSupply();\n            }\n\n            if (supportInterface[_IERC173]) {\n                nftData.owner = IERC173(nft).owner();\n            }\n        }\n    }\n}\n"
    },
    "contracts/CloneFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/ICloneFactoryV2.sol\";\n\n/// @title Abstract Clone Factory V2\n/// @notice Generic Clone Factory to clone Templates\n/// @dev CloneFactory is ICloneFactory and Ownable\nabstract contract CloneFactoryV2 is ICloneFactoryV2, Ownable {\n    /// @notice Implementations addresses\n    address[] public implementations;\n\n    /// @notice Named Templates\n    mapping(string => address) public templates;\n\n    /// @notice Add Implementations, public onlyOwner\n    /// @param  implementationsToAdd : new implementations addresses\n    function implementationsAdd(address[] calldata implementationsToAdd) external override(ICloneFactoryV2) onlyOwner {\n        for (uint256 i = 0; i < implementationsToAdd.length; i += 1) {\n            _implementationNew(implementationsToAdd[i]);\n        }\n    }\n\n    /// @notice Implementations count\n    /// @return count : number of implementations\n    function implementationsCount() external view override(ICloneFactoryV2) returns (uint256) {\n        return implementations.length;\n    }\n\n    /// @notice Set Template by Name\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template)\n        public\n        virtual\n        override(ICloneFactoryV2)\n        onlyOwner\n    {\n        templates[templateName] = template;\n\n        /// @notice emit event ImplementationNew\n        emit TemplateSet(templateName, template);\n    }\n\n    /// @notice New Implementation\n    /// @param  implementation : implementation address\n    function _implementationNew(address implementation) internal virtual {\n        implementations.push(implementation);\n\n        emit ImplementationNew(implementation, _msgSender(), implementations.length - 1);\n    }\n\n    /// @notice Clone Template\n    /// @param  templateName : template name\n    /// @return clone_ : clone address\n    function _clone(string memory templateName) internal returns (address clone_) {\n        /// @notice clone template and get clone address\n        clone_ = Clones.clone(_template(templateName));\n\n        /// @notice register clone as new implementation\n        _implementationNew(clone_);\n    }\n\n    /// @notice Get Template\n    /// @param  templateName : template name\n    /// @return  template : template address\n    function _template(string memory templateName) internal view virtual returns (address template) {\n        require(templates[templateName] != address(0), \"Bad Template\");\n\n        template = templates[templateName];\n    }\n}\n"
    },
    "contracts/dev/InterfacesIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC165.sol\";\n\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\nimport \"../interfaces/IERC721TokenReceiver.sol\";\n\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IERC1155MetadataURI.sol\";\nimport \"../interfaces/IERC1155TokenReceiver.sol\";\n\nimport \"../interfaces/IERC173.sol\";\nimport \"../interfaces/IERC2981.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport \"../interfaces/IOpenNFTsV0.sol\";\nimport \"../interfaces/IOpenNFTsV1.sol\";\nimport \"../interfaces/IOpenNFTsV2.sol\";\nimport \"../interfaces/IOpenNFTsV3.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\nimport \"../interfaces/IOpenBound.sol\";\n\nimport \"../interfaces/ICloneFactory.sol\";\nimport \"../interfaces/ICloneFactoryV2.sol\";\nimport \"../interfaces/INFTsFactory.sol\";\nimport \"../interfaces/INFTsFactoryV2.sol\";\nimport \"../interfaces/INFTsFactoryV3.sol\";\n\nimport \"../interfaces/INFTsResolver.sol\";\n\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\nimport {IOpenNFTsV3 as IOpenNFTsV3Old} from \"../interfaces/IOpenNFTsV3.old.sol\";\n\nimport \"../interfaces/IInterfacesIds.sol\";\n\n/// @title InterfaceIds calculation\n/// @author zapaz.eth\n/// @notice Calculates various ERC165, ERC721 and ERC1155 interface Ids\n///  @notice and Kredeum OpenNFTs interface Ids\ncontract InterfacesIds is IInterfacesIds {\n    /// @notice Main and only function to calculate Interface Ids\n    /// @notice No params\n    /// @return interfacesIds : Array of all interfaceIds\n    function ids() external pure override(IInterfacesIds) returns (bytes4[] memory interfacesIds) {\n        uint256 i;\n        uint256 imax = 29;\n\n        interfacesIds = new bytes4[](imax);\n\n        interfacesIds[i++] = bytes4(0x01ffc9a7); // IERC165\n\n        interfacesIds[i++] = bytes4(0x80ac58cd); // IERC721\n        interfacesIds[i++] = bytes4(0x780e9d63); // IERC721Enumerable\n        interfacesIds[i++] = bytes4(0x5b5e139f); // IERC721Metadata\n        interfacesIds[i++] = bytes4(0x150b7a02); // IERC721TokenReceiver\n\n        interfacesIds[i++] = bytes4(0xd9b67a26); // IERC1155\n        interfacesIds[i++] = bytes4(0x0e89341c); // IERC1155MetadataURI\n        interfacesIds[i++] = bytes4(0x4e2312e0); // IERC1155TokenReceiver\n\n        interfacesIds[i++] = bytes4(0x7f5828d0); // IERC173\n        interfacesIds[i++] = bytes4(0x2a55205a); // IERC2981\n\n        interfacesIds[i++] = type(IOpenNFTs).interfaceId;\n        interfacesIds[i++] = type(IOpenChecker).interfaceId;\n        interfacesIds[i++] = type(IOpenCloneable).interfaceId;\n        interfacesIds[i++] = type(IOpenMarketable).interfaceId;\n        interfacesIds[i++] = type(IOpenPauseable).interfaceId;\n\n        interfacesIds[i++] = bytes4(0x4b68d431); // IOpenNFTsV0\n        interfacesIds[i++] = bytes4(0xeacabe14); // IOpenNFTsV1\n        interfacesIds[i++] = bytes4(0xd94a1db2); // IOpenNFTsV2\n        interfacesIds[i++] = bytes4(0x5f5f00ef); // IOpenNFTsV3\n        interfacesIds[i++] = type(IOpenNFTsV4).interfaceId;\n        interfacesIds[i++] = type(IOpenBound).interfaceId;\n\n        interfacesIds[i++] = bytes4(0xf73a622c); // ICloneFactory\n        interfacesIds[i++] = bytes4(0xcfc6c434); // ICloneFactoryV2\n        interfacesIds[i++] = bytes4(0x74618347); // INFTsFactory\n        interfacesIds[i++] = bytes4(0x78f5e5c2); // INFTsFactoryV2\n        interfacesIds[i++] = bytes4(0x9e4ace22); // INFTsFactoryV3\n\n        interfacesIds[i++] = bytes4(0x03dc8d64); // IOpenNFTsOld\n        interfacesIds[i++] = bytes4(0x5c838d8b); // IOpenNFTsV3Old\n\n        interfacesIds[i++] = type(IInterfacesIds).interfaceId;\n\n        assert(i == imax);\n    }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function approve(address to, uint256 tokenId) external payable;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721Enumerable {\n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.9;\n\ninterface IERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155METADATAURI.sol)\n\npragma solidity ^0.8.9;\n\ninterface IERC1155MetadataURI {\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155TokenReceiver.sol)\n\npragma solidity ^0.8.9;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external returns (bytes4);\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC2981 {\n    function royaltyInfo(uint256 tokenID, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "contracts/interfaces/IInterfacesIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IInterfacesIds {\n    function ids() external pure returns (bytes4[] memory interfacesIds);\n}\n"
    },
    "contracts/tests/OpenNFTsV2Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nimport \"../OpenNFTsV2.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\nimport {ERC721TransferableTest} from \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\n\ncontract OpenNFTsV2Test is ITest, ERC721FullTest, ERC721TransferableTest {\n    function constructorTest(address owner) public override(ERC721FullTest, ERC721TransferableTest) returns (address) {\n        changePrank(owner);\n        OpenNFTsV2 op = new OpenNFTsV2();\n        op.initialize(\"OpenNFTsV2Test\", \"OPTEST\");\n\n        return address(op);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(ERC721FullTest, ERC721TransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV2(collection).mintNFT(minter, _TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override {}\n\n    function setUp() public override {\n        setUpERC721Full(\"OpenNFTsV2Test\", \"OPTEST\");\n        setUpERC721Transferable();\n    }\n}\n"
    },
    "contracts/OpenNFTsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"./interfaces/IOpenNFTsV2.sol\";\n\ncontract OpenNFTsV2 is ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721URIStorageUpgradeable, OwnableUpgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    constructor() ERC721Upgradeable() {}\n\n    function initialize(string memory _name, string memory _symbol) external initializer {\n        __Ownable_init();\n        __ERC721_init(_name, _symbol);\n    }\n\n    function mintNFT(address minter, string memory jsonURI) public returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(minter, newItemId);\n        _setTokenURI(newItemId, jsonURI);\n\n        return newItemId;\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        // IOpenNFTsV2 => 0xd94a1db2\n        return interfaceId == type(IOpenNFTsV2).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV1Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nimport {OpenNFTsV1} from \"../OpenNFTsV1.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\nimport {ERC721TransferableTest} from \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\n\ncontract OpenNFTsV1Test is ITest, ERC721FullTest, ERC721TransferableTest {\n    function constructorTest(address owner) public override(ERC721FullTest, ERC721TransferableTest) returns (address) {\n        changePrank(owner);\n        OpenNFTsV1 op = new OpenNFTsV1();\n\n        return address(op);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(ERC721FullTest, ERC721TransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV1(collection).mintNFT(minter, _TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override {}\n\n    function setUp() public override {\n        setUpERC721Full(\"Open NFTs\", \"NFT\");\n        setUpERC721Transferable();\n    }\n}\n"
    },
    "contracts/OpenNFTsV1.sol": {
      "content": "/// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./interfaces/IOpenNFTsV1.sol\";\n\ncontract OpenNFTsV1 is ERC721, ERC721Enumerable, ERC721URIStorage, IOpenNFTsV1 {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    constructor() ERC721(\"Open NFTs\", \"NFT\") {}\n\n    function mintNFT(address minter, string memory jsonURI) public override(IOpenNFTsV1) returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(minter, newItemId);\n        _setTokenURI(newItemId, jsonURI);\n\n        return newItemId;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return interfaceId == type(IOpenNFTsV1).interfaceId || super.supportsInterface(interfaceId);\n        // return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/next/OpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//  OpenERC165 (supports)\n//      |\n//      ———————————————————————————————————————————————\n//      |                 |             |             |\n//  OpenERC721 (NFT)  OpenERC173  OpenChecker  OpenCloneable\n//      |             (ownable)         |             |\n//      |                 |             |             |\n//      |                 |             |             |\n//      |            OpenPauseable      |             |\n//      |                 |             |             |\n//      ———————————————————————————————————————————————\n//      |\n//  OpenBound --- IOpenBound --- IERC721Enumerable --- IERC721Metadata\n//\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\n\nimport \"../interfaces/IOpenBound.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"../interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenBound smartcontract\n/// limited to one nft per address\ncontract OpenBound is\n    IOpenBound,\n    IERC721Enumerable,\n    IERC721Metadata,\n    OpenCloneable,\n    OpenChecker,\n    OpenPauseable,\n    OpenERC721\n{\n    uint256 public maxSupply;\n\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) internal _tokenOfOwner;\n    mapping(address => uint256) internal _tokenIndexOfOwner;\n    mapping(uint256 => uint256) internal _cidOfToken;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    /// IOpenBound\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        uint256 maxSupply_\n    ) external override(IOpenBound) {\n        OpenCloneable._initialize(\"OpenBound\", 1);\n        OpenERC173._initialize(owner_);\n\n        name = name_;\n        symbol = symbol_;\n        maxSupply = maxSupply_;\n    }\n\n    function mint(uint256 cid) external override(IOpenBound) onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, cid);\n    }\n\n    function claim(uint256 tokenID, uint256 cid) external override(IOpenBound) onlyWhenNotPaused {\n        require(tokenID == _tokenID(msg.sender, cid), \"Not owner\");\n        _mint(msg.sender, cid);\n    }\n\n    function burn(uint256 tokenID) external override(IOpenBound) {\n        address from = ownerOf(tokenID);\n        require(from == msg.sender, \"Not owner\");\n\n        _burn(tokenID);\n    }\n\n    function getMyTokenID(uint256 cid) external view override(IOpenBound) returns (uint256 myTokenID) {\n        myTokenID = _tokenID(msg.sender, cid);\n    }\n\n    function getCID(uint256 tokenID) external view override(IOpenBound) returns (uint256 cid) {\n        cid = _cidOfToken[tokenID];\n    }\n\n    /// IERC721Enumerable\n    function totalSupply() external view override(IERC721Enumerable) returns (uint256 tokensLength) {\n        tokensLength = _tokens.length;\n    }\n\n    function tokenOfOwnerByIndex(address tokenOwner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256 tokenID)\n    {\n        require(index == 0 && balanceOf(tokenOwner) == 1, \"Invalid index\");\n\n        tokenID = _tokenOfOwner[tokenOwner];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256 tokenID) {\n        require(index < _tokens.length, \"Invalid index\");\n\n        tokenID = _tokens[index];\n    }\n\n    /// IERC721Metadata\n    function tokenURI(uint256 tokenID) external view override(IERC721Metadata) returns (string memory) {\n        require(_exists(tokenID), \"NFT doesn't exists\");\n\n        return _tokenURI(_cidOfToken[tokenID]);\n    }\n\n    function getTokenID(address addr, uint256 cid) external pure override(IOpenBound) returns (uint256 tokenID) {\n        tokenID = _tokenID(addr, cid);\n    }\n\n    /// IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(OpenPauseable, OpenCloneable, OpenERC721, OpenChecker)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenBound).interfaceId ||\n            interfaceId == type(IOpenNFTsOld).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, uint256 cid) internal returns (uint256 tokenID) {\n        require((maxSupply == 0) || _tokens.length < maxSupply, \"Max supply reached\");\n        require(balanceOf(to) == 0, \"Already minted or claimed\");\n\n        tokenID = _tokenID(to, cid);\n\n        _tokens.push(tokenID);\n        _tokenOfOwner[to] = tokenID;\n        _tokenIndexOfOwner[to] = _tokens.length - 1;\n        _cidOfToken[tokenID] = cid;\n\n        _mint(to, _tokenURI(cid), tokenID);\n    }\n\n    function _mint(\n        address to,\n        string memory newTokenURI,\n        uint256 tokenID\n    ) internal override(OpenERC721) {\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721) {\n        address from = ownerOf(tokenID);\n        uint256 index = _tokenIndexOfOwner[from];\n        uint256 lastIndex = _tokens.length - 1;\n\n        if (index != lastIndex) {\n            _tokens[index] = _tokens[lastIndex];\n            _tokenIndexOfOwner[ownerOf(_tokens[lastIndex])] = index;\n        }\n        _tokens.pop();\n\n        delete _cidOfToken[tokenID];\n        delete _tokenIndexOfOwner[from];\n        delete _tokenOfOwner[from];\n\n        super._burn(tokenID);\n    }\n\n    function _tokenID(address addr, uint256 cid) internal pure returns (uint256 tokenID) {\n        tokenID = uint256(keccak256(abi.encodePacked(cid, addr)));\n    }\n\n    function _tokenURI(uint256 cid) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(cid)));\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 // tokenId\n    ) internal pure override {\n        require(from == address(0) || to == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "OpenNFTs/contracts/libraries/Bafkrey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nlibrary Bafkrey {\n    bytes32 private constant _BASE32_SYMBOLS = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    /// Transfom uint256 to IPFS CID V1 base32 raw (starting with \"bafkrei\")\n    function uint256ToCid(uint256 id) internal pure returns (string memory) {\n        // IPFS CID V1 base32 raw \"bafrei...\" => 5 bits => uint32\n        // uint256 id  = 256 bits = 1 bit + 51 uint32 = 1 + 51 * 5 = 256\n        // 00 added right =>\n        // uint8 + uint256 + 00 = 258 bits = uint8 + 50 uint32 + (3 bits + 00) = uint8 + 51 uint32 = 3 + 51 * 5 = 258\n\n        bytes memory buffer = new bytes(52);\n        uint8 high3 = uint8(id >> 253);\n        buffer[0] = _BASE32_SYMBOLS[high3 & 0x1f];\n\n        id <<= 2;\n        for (uint256 i = 51; i > 0; i--) {\n            buffer[i] = _BASE32_SYMBOLS[id & 0x1f];\n            id >>= 5;\n        }\n\n        return string(abi.encodePacked(\"bafkrei\", buffer));\n    }\n}\n"
    },
    "contracts/testsOld/OpenBound.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"../../lib/forge-std/src/Test.sol\";\nimport \"../next/OpenBound.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\n\ncontract OpenBoundForgeTest is Test {\n    OpenBound public ob;\n    address owner = address(0x1);\n\n    constructor() {}\n\n    function setUp() public {\n        ob = new OpenBound();\n        ob.initialize(\"OpenBoundTest\", \"OBTEST\", owner, 0);\n    }\n\n    function testInterfaceIds() public {\n        assertTrue(ob.supportsInterface(type(IERC165).interfaceId));\n        assertTrue(ob.supportsInterface(type(IERC721Enumerable).interfaceId));\n        assertTrue(ob.supportsInterface(type(IERC721).interfaceId));\n        assertTrue(ob.supportsInterface(type(IERC721Metadata).interfaceId));\n        assertTrue(ob.supportsInterface(type(IOpenBound).interfaceId));\n\n        assertFalse(ob.supportsInterface(type(IERC1155).interfaceId));\n    }\n\n    function testMint(uint256 tokenID) public {\n        assertEq(ob.totalSupply(), 0);\n\n        changePrank(owner);\n        ob.mint(tokenID);\n\n        assertEq(ob.totalSupply(), 1);\n    }\n\n    function testFailAll(uint256 tokenID) public view {\n        ob.tokenURI(tokenID);\n        ob.tokenByIndex(tokenID);\n        ob.tokenOfOwnerByIndex(msg.sender, tokenID);\n    }\n\n    function testFailTokenURI(uint256 tokenID) public view {\n        ob.tokenURI(tokenID);\n    }\n\n    function testFailTokenByIndex(uint256 tokenID) public view {\n        ob.tokenByIndex(tokenID);\n    }\n\n    function testFailTokenOfOwnerByIndex(uint256 tokenID) public view {\n        ob.tokenOfOwnerByIndex(msg.sender, tokenID);\n    }\n}\n"
    },
    "contracts/tests/OpenBound/OpenBoundTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../next/OpenBound.sol\";\n\nimport \"./OpenBoundSupportsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/sets/OpenNFTsTest.t.sol\";\n\nimport \"OpenNFTs/contracts/tests/units/ERC173Test.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721NonTransferableTest.t.sol\";\nimport \"OpenNFTs/contracts/tests/units/OpenPauseableTest.t.sol\";\n\ncontract OpenBoundTest is\n    OpenNFTsTest,\n    ERC173Test,\n    ERC721NonTransferableTest,\n    OpenPauseableTest,\n    OpenBoundSupportsTest\n{\n    uint256 private _cid = 777;\n\n    function constructorTest(address owner)\n        public\n        override(OpenNFTsTest, ERC173Test, ERC721NonTransferableTest, OpenPauseableTest, OpenBoundSupportsTest)\n        returns (address)\n    {\n        changePrank(owner);\n        bool[] memory options = new bool[](1);\n        options[0] = true;\n\n        OpenBound collection = new OpenBound();\n        collection.initialize(\"OpenBound\", \"BOUND\", owner, 0);\n\n        return address(collection);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(OpenNFTsTest, OpenPauseableTest, ERC721NonTransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        uint256 tokenID = OpenBound(payable(collection)).mint(_cid++);\n        string memory tokenURI = OpenBound(payable(collection)).tokenURI(tokenID);\n        return (tokenID, tokenURI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override(OpenNFTsTest, ERC721NonTransferableTest) {\n        changePrank(OpenBound(payable(collection)).ownerOf(tokenID));\n        OpenBound(payable(collection)).burn(tokenID);\n    }\n\n    function setUp() public {\n        setUpERC173();\n        setUpPausable();\n        setUpOpenNFTs(\"OpenBound\", \"BOUND\");\n        setUpERC721NonTransferable();\n        setUpOpenBoundSupports();\n    }\n}\n"
    },
    "contracts/tests/OpenBound/OpenBoundSupportsTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IAll.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenBoundEx.sol\";\nimport \"OpenNFTs/contracts/templates/OpenResolverEx.sol\";\n\nabstract contract OpenBoundSupportsTest is Test {\n    OpenResolverEx private _resolver;\n    address private _collection;\n    address private _owner = address(0x1);\n    address private _minter = address(0x12);\n    address private _buyer = address(0x13);\n    address private _tester = address(0x4);\n    bool[] private _options = new bool[](1);\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function setUpOpenBoundSupports() public {\n        _collection = constructorTest(_owner);\n\n        _resolver = new OpenResolverEx();\n    }\n\n    function testOpenBoundCheckErcInterfaces() public {\n        bool[11] memory expected = [false, true, true, true, true, false, false, false, false, true, false];\n\n        bool[] memory checks = IOpenChecker(_resolver).checkErcInterfaces(_collection);\n\n        for (uint256 i = 0; i < expected.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n\n    function testOpenBoundCheckSupportedInterfaces() public {\n        bytes4[5] memory ids = [\n            type(IOpenChecker).interfaceId,\n            type(IOpenPauseable).interfaceId,\n            type(IOpenCloneable).interfaceId,\n            type(IOpenBoundEx).interfaceId,\n            type(IOpenMarketable).interfaceId\n        ];\n        bool[5] memory expected = [true, true, true, true, false];\n\n        bytes4[] memory interfaceIds = new bytes4[](5);\n        for (uint256 i = 0; i < ids.length; i++) {\n            interfaceIds[i] = ids[i];\n        }\n\n        bool[] memory checks = IOpenChecker(_resolver).checkSupportedInterfaces(_collection, false, interfaceIds);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            assertEq(checks[i], expected[i]);\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/tests/units/ERC721NonTransferableTest.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Events.sol\";\n\nabstract contract ERC721NonTransferableTest is Test, IERC721Events {\n    address private _collection;\n    bool private _transferable;\n    string private _tokenURI;\n    address private _owner = address(0x1001);\n    address private _minter = address(0x1002);\n    address private _buyer = address(0x1003);\n    address private _tester = address(0x1004);\n    uint256 private _tokenID0;\n\n    function constructorTest(address owner_) public virtual returns (address);\n\n    function mintTest(address collection_, address minter_) public virtual returns (uint256, string memory);\n\n    function burnTest(address collection_, uint256 tokenID_) public virtual;\n\n    function setUpERC721NonTransferable() public {\n        _transferable = false;\n        _collection = constructorTest(_owner);\n\n        (_tokenID0, ) = mintTest(_collection, _minter);\n        assertEq(IERC721(_collection).ownerOf(_tokenID0), _minter);\n    }\n\n    function testFailERC721SafeTransferFrom() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721SafeTransferFromWithData() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, _tester, _tokenID0, \"data\");\n    }\n\n    function testFailERC721SafeTransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID, ) = mintTest(_collection, from);\n        IERC721(_collection).safeTransferFrom(from, to, tokenID);\n    }\n\n    function testFailERC721SafeTransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n        IERC721(_collection).safeTransferFrom(_minter, address(_collection), _tokenID0);\n    }\n\n    function testFailERC721TransferFromNotERC721TokenReceiver() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, address(_collection), _tokenID0);\n    }\n\n    function testFailERC721TransferFrom() public {\n        changePrank(_minter);\n        IERC721(_collection).transferFrom(_minter, _tester, _tokenID0);\n    }\n\n    function testFailERC721TransferFromFuzzy(address from, address to) public {\n        vm.assume(from != address(0));\n        vm.assume(to != address(0));\n        vm.assume(to != from);\n        vm.assume(from.code.length == 0);\n        vm.assume(to.code.length == 0);\n\n        (uint256 tokenID, ) = mintTest(_collection, from);\n        IERC721(_collection).transferFrom(from, to, tokenID);\n    }\n\n    function testFailERC721Approve() public {\n        changePrank(_minter);\n        IERC721(_collection).approve(_tester, _tokenID0);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n\n    function testFailERC721SetApprovalForAll() public {\n        changePrank(_minter);\n        IERC721(_collection).setApprovalForAll(_tester, true);\n\n        changePrank(_tester);\n        IERC721(_collection).safeTransferFrom(_minter, _buyer, _tokenID0);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenBoundEx.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenBoundEx {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        uint256 maxSupply\n    ) external;\n\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n\n    function getTokenID(address addr, uint256 cid) external pure returns (uint256 tokenID);\n}\n"
    },
    "OpenNFTs/contracts/templates/OpenResolverEx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//    OpenERC165\n//        |\n\n//        |\n//   OpenResolver\n//        |\n//  OpenResolverEx —— IOpenResolverEx\n//\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenResolver.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenResolverEx.sol\";\n\ncontract OpenResolverEx is IOpenResolverEx, OpenResolver {\n    bytes4[] private _interfaceIds = new bytes4[](5);\n\n    function initialize(address owner_) external override(IOpenResolverEx) {\n        OpenERC173._initialize(owner_);\n\n        _interfaceIds[0] = type(IOpenChecker).interfaceId;\n        _interfaceIds[1] = type(IOpenGetter).interfaceId;\n        _interfaceIds[2] = type(IOpenRegistry).interfaceId;\n        _interfaceIds[3] = type(IOpenResolver).interfaceId;\n        _interfaceIds[4] = type(IOpenResolverEx).interfaceId;\n    }\n\n    function getResolverExCollectionInfos(address collection, address account)\n        external\n        view\n        override(IOpenResolverEx)\n        returns (CollectionInfos memory collectionInfos)\n    {\n        collectionInfos = _getCollectionInfos(collection, account, _interfaceIds);\n    }\n\n    function getResolverExCollectionsInfos(address account)\n        external\n        view\n        override(IOpenResolverEx)\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        collectionsInfos = _getCollectionsInfos(account, _interfaceIds);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(OpenResolver) returns (bool) {\n        return interfaceId == type(IOpenResolverEx).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenResolverEx.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/interfaces/IERC721Infos.sol\";\n\ninterface IOpenResolverEx is IERC721Infos {\n    function initialize(address owner) external;\n\n    function getResolverExCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos);\n\n    function getResolverExCollectionsInfos(address account)\n        external\n        view\n        returns (CollectionInfos[] memory collectionsInfos);\n}\n"
    },
    "contracts/next/NFTsFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\nimport \"../interfaces/INFTsFactoryV3.sol\";\nimport \"../interfaces/IOpenNFTsV4.sol\";\nimport \"./NFTsResolver.sol\";\n\n/// @title NFTsFactory smartcontract\n/// @dev is CloneFactory\n/// @notice Templates are OPEN_NFTS contracts\n/// @notice Implementations are ERC721 contracts (including OPEN_NFTS clones)\n/// @notice Factory can clone OPEN_NFTs templates to implementations\n/// @notice Factory can also add ERC721 contracts to implementations\ncontract NFTsFactoryV3 is INFTsFactoryV3, OpenERC173 {\n    /// @notice Named Templates\n\n    mapping(string => uint256) private _numTemplates;\n    address[] public templates;\n\n    address public nftsResolver;\n\n    constructor(address initialOwner, address resolver) {\n        _transferOwnership(initialOwner);\n        nftsResolver = resolver;\n    }\n\n    /// @notice clone template\n    /// @param name name of Clone collection\n    /// @param symbol symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(\n        string memory name,\n        string memory symbol,\n        string memory templateName,\n        bool[] memory options\n    ) external override(INFTsFactoryV3) returns (address clone_) {\n        clone_ = _clone(template(templateName));\n\n        IOpenNFTsV4(clone_).initialize(name, symbol, msg.sender, 0, address(0), 0, options);\n\n        IOpenRegistry(nftsResolver).addAddress(clone_);\n\n        emit Clone(templateName, clone_, name, symbol, options);\n    }\n\n    function countTemplates() external view override(INFTsFactoryV3) returns (uint256 count) {\n        count = templates.length;\n    }\n\n    function setResolver(address resolver_) public override(INFTsFactoryV3) onlyOwner {\n        nftsResolver = resolver_;\n\n        emit SetResolver(nftsResolver);\n    }\n\n    /// @notice Set Template by Name\n    /// @param templateName_ Name of the template\n    /// @param template_ Address of the template\n    function setTemplate(string memory templateName_, address template_) public override(INFTsFactoryV3) onlyOwner {\n        require(IERC165(template_).supportsInterface(type(IOpenCloneable).interfaceId), \"Not OpenCloneable\");\n        require(IOpenCloneable(template_).initialized(), \"Not initialized\");\n        require(template_.code.length != 45, \"Clone not valid template\");\n\n        templates.push(template_);\n        uint256 num = templates.length;\n\n        _numTemplates[templateName_] = num;\n\n        IOpenRegistry(nftsResolver).addAddress(template_);\n\n        emit SetTemplate(templateName_, template_, num);\n    }\n\n    /// @notice Get Template\n    /// @param  templateName : template name\n    /// @return template_ : template address\n    function template(string memory templateName) public view override(INFTsFactoryV3) returns (address template_) {\n        uint256 num = _numTemplates[templateName];\n        require(num >= 1, \"Invalid Template\");\n\n        template_ = templates[num - 1];\n        require(template_ != address(0), \"No Template\");\n    }\n\n    /// @notice Clone template (via EIP-1167)\n    /// @param  template_ : template address\n    /// @return clone_ : clone address\n    function _clone(address template_) private returns (address clone_) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, template_))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            clone_ := create(0, ptr, 0x37)\n        }\n        assert(clone_ != address(0));\n    }\n}\n"
    },
    "contracts/dev/OpenERC721EnumerableOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/extensions/ERC721Enumerable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/...\n// ...contracts/token/ERC721/extensions/ERC721Enumerable.sol\n\n//\n//                OpenERC165\n//                     |\n//                OpenERC721\n//                     |\n//            OpenERC721EnumerableOz\n//\n\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenERC721EnumerableOz is IERC721Enumerable, OpenERC721 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenERC721) returns (bool) {\n        return interfaceId == 0x780e9d63 || super.supportsInterface(interfaceId);\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < OpenERC721.balanceOf(owner), \"Invalid index!\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view override(IERC721Enumerable) returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view override(IERC721Enumerable) returns (uint256) {\n        require(index < OpenERC721EnumerableOz.totalSupply(), \"Invalid index!\");\n        return _allTokens[index];\n    }\n\n    function _mintEnumerable(address to, uint256 tokenID) internal {\n        uint256 length = OpenERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenID;\n        _ownedTokensIndex[tokenID] = length;\n\n        _allTokensIndex[tokenID] = _allTokens.length;\n        _allTokens.push(tokenID);\n    }\n\n    function _burnEnumerable(uint256 tokenID) internal {\n        _removeTokenFromOwnerEnumeration(ownerOf(tokenID), tokenID);\n        _removeTokenFromAllTokensEnumeration(tokenID);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenID) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = OpenERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenID];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenID];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenID) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenID];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenID];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/dev/OpenProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"../interfaces/IERC4973.sol\";\nimport \"../interfaces/IOpenProof.sol\";\n\n/// @title OpenProof smartcontract\ncontract OpenProof is\n    IOpenProof,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    OwnableUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    event Attest(address indexed to, uint256 indexed tokenId);\n\n    /// @notice onlyMinter, only collection owner can mint\n    modifier onlyMinter() {\n        require((owner() == _msgSender()), \"Not minter\");\n        _;\n    }\n\n    /// @notice initialize\n    /// @param name name of the NFT Collection\n    /// @param symbol symbol of the NFT Collection\n    /// @param owner owner of the NFT Collection\n    // solhint-disable-next-line comprehensive-interface\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner\n    ) external initializer {\n        __Ownable_init();\n        __ERC721_init(name, symbol);\n        transferOwnership(owner);\n    }\n\n    /// @notice mint\n    /// @param to address that will own the NFT minted\n    /// @param jsonURI json URI of NFT metadata\n    function mintOpenProof(address to, string memory jsonURI)\n        external\n        override(IOpenProof)\n        onlyMinter\n        returns (uint256 tokenId)\n    {\n        _tokenIds.increment();\n\n        tokenId = _tokenIds.current();\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, jsonURI);\n    }\n\n    /// @notice Get tokenURI\n    /// @param tokenId tokenId of NFT\n    /// @param tokenURI_ token URI of NFT\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory tokenURI_)\n    {\n        tokenURI_ = super.tokenURI(tokenId);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC4973).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _afterTokenTransfer(\n        address, // from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721Upgradeable) {\n        emit Attest(to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address, // to,\n        uint256 // tokenId\n    ) internal pure override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        require(from == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "contracts/interfaces/IERC4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC4973 {\n    event Attest(address indexed to, uint256 indexed tokenID);\n\n    // event Revoke(address indexed to, uint256 indexed tokenID);\n\n    function ownerOf(uint256 tokenID) external view returns (address);\n\n    // function burn(uint256 tokenID) external;\n}\n"
    },
    "contracts/interfaces/IOpenProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenProof {\n    function mintOpenProof(address minter, string memory jsonURI) external returns (uint256);\n}\n"
    },
    "contracts/dev/OpenBound4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/IOpenBound4973.sol\";\nimport \"../interfaces/IERC4973.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\n\n/// @title OpenBound smartcontract\ncontract OpenBound4973 is IOpenBound4973, IERC4973, IERC173, IERC721Enumerable, IERC721Metadata {\n    address public owner;\n\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping(uint256 => address) internal _owners;\n    mapping(address => uint256[]) internal _tokensOfOwner;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    modifier onlyOwner() {\n        require((owner == msg.sender), \"Not owner\");\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external override(IERC173) {\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function ownerOf(uint256 tokenID) external view override(IERC4973) returns (address nftOwner) {\n        nftOwner = _owners[tokenID];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256 tokenID) {\n        require(index < _tokens.length, \"Invalid index\");\n        tokenID = _tokens[index];\n        // require(_exists(tokenID), \"NFT doesn't exists\");\n    }\n\n    function tokenOfOwnerByIndex(address addr, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256 tokenID)\n    {\n        require(index < _tokens.length, \"Invalid index\");\n        tokenID = _tokensOfOwner[addr][index];\n        // require(_exists(tokenID), \"NFT doesn't exists\");\n    }\n\n    function mint(uint256 tokenID) public override(IOpenBound4973) {\n        _mint(msg.sender, tokenID);\n    }\n\n    function mint(address addr, uint256 tokenID) public override(IOpenBound4973) onlyOwner {\n        _mint(addr, tokenID);\n    }\n\n    // function burn(uint256 tokenID) public override(IERC4973) {\n    //     require(_exists(tokenID), \"NFT does not exists\");\n    //     totalSupply -= 1;\n    //     _owners[tokenID] = address(0);\n    //     emit Revoke(address(0), tokenID);\n    // }\n\n    function tokenURI(uint256 tokenId) public view override(IERC721Metadata) returns (string memory) {\n        require(_exists(tokenId), \"NFT doesn't exists\");\n\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(tokenId)));\n    }\n\n    function _mint(address addr, uint256 tokenID) internal {\n        require(!_exists(tokenID), \"NFT already exists\");\n        totalSupply += 1;\n        _owners[tokenID] = addr;\n        _tokens.push(tokenID);\n        _tokensOfOwner[addr].push(tokenID);\n        emit Attest(addr, tokenID);\n    }\n\n    function _exists(uint256 tokenID) internal view returns (bool) {\n        return _owners[tokenID] != address(0);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenBound4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenBound4973 {\n    function mint(uint256 tokenID) external;\n\n    function mint(address addr, uint256 tokenID) external;\n}\n"
    },
    "contracts/dev/OpenMulti.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\nimport \"../interfaces/IOpenMulti.sol\";\n\ncontract OpenMulti is IOpenMulti, ERC721, ERC721Enumerable, Ownable {\n    bytes32 private constant _BASE32_SYMBOLS = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    string private constant _BASE_URI = \"https://ipfs.io/ipfs/\";\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function claim(uint256 tokenId) public override(IOpenMulti) {\n        _safeMint(msg.sender, tokenId);\n    }\n\n    function exists(uint256 tokenId) public view override(IOpenMulti) returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId), \"ERC721: token doesn't exists\");\n\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(tokenId)));\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return\n            interfaceId == type(IOpenMulti).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenMulti.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenMulti {\n    function claim(uint256 tokenID) external;\n\n    function exists(uint256) external returns (bool);\n}\n"
    },
    "contracts/OpenNFTsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract OpenNFTsV0 is ERC721, ERC721Enumerable, ERC721URIStorage {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    constructor() ERC721(\"Open NFTs\", \"NFT\") {}\n\n    function adddUser(address minter, string memory jsonURI) public returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _safeMint(minter, newItemId);\n        _setTokenURI(newItemId, jsonURI);\n\n        return newItemId;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/tests/OpenNFTsV0Test.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"OpenNFTs/contracts/tests/sets/ERC721FullTest.t.sol\";\n\nimport {OpenNFTsV0} from \"../OpenNFTsV0.sol\";\nimport \"OpenNFTs/contracts/tests/units/ERC721Test.t.sol\";\nimport \"OpenNFTs/contracts/interfaces/ITest.sol\";\nimport {ERC721TransferableTest} from \"OpenNFTs/contracts/tests/units/ERC721TransferableTest.t.sol\";\n\ncontract OpenNFTsV0Test is ITest, ERC721FullTest, ERC721TransferableTest {\n    function constructorTest(address owner) public override(ERC721FullTest, ERC721TransferableTest) returns (address) {\n        changePrank(owner);\n        OpenNFTsV0 op = new OpenNFTsV0();\n\n        return address(op);\n    }\n\n    function mintTest(address collection, address minter)\n        public\n        override(ERC721FullTest, ERC721TransferableTest)\n        returns (uint256, string memory)\n    {\n        changePrank(minter);\n        return (OpenNFTsV0(collection).adddUser(minter, _TOKEN_URI), _TOKEN_URI);\n    }\n\n    function burnTest(address collection, uint256 tokenID) public override {}\n\n    function setUp() public override {\n        setUpERC721Full(\"Open NFTs\", \"NFT\");\n        setUpERC721Transferable();\n    }\n}\n"
    },
    "contracts/dev/OpenPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"../interfaces/IOpenPass.sol\";\n\ncontract OpenPass is ERC721, IOpenPass, ERC721Burnable, Ownable {\n    using Counters for Counters.Counter;\n\n    string private _tokenURI;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() ERC721(\"NFT Pass\", \"PASS\") {}\n\n    function safeMint(address to) public override(IOpenPass) onlyOwner {\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n        _safeMint(to, tokenId);\n    }\n\n    function setTokenURI(string memory tokenURI_) public override(IOpenPass) onlyOwner {\n        _tokenURI = tokenURI_;\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId), \"Nonexistent token\");\n        return _tokenURI;\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721) {\n        super._burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IOpenPass {\n    function setTokenURI(string memory tokenURI) external;\n\n    function safeMint(address to) external;\n}\n"
    },
    "contracts/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Open1155 is ERC1155, Ownable {\n    constructor() ERC1155(\"\") {}\n\n    // solhint-disable-next-line comprehensive-interface\n    function setURI(string memory newuri) public onlyOwner {\n        _setURI(newuri);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/dev/OpenBoundOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\nimport \"../interfaces/IOpenBoundOz.sol\";\n\n/// @title OpenBound smartcontract\n// contract OpenBound is ERC721, IOpenBoundOz, IERC173, IERC721Enumerable, IERC721Metadata {\ncontract OpenBoundOz is ERC721, IOpenBoundOz, IERC721Enumerable, IOpenPauseable, Ownable {\n    uint256 public maxSupply;\n\n    bool public paused;\n\n    mapping(address => uint256) internal _tokenOfOwner;\n    mapping(address => uint256) internal _tokenIndexOfOwner;\n    mapping(uint256 => uint256) internal _cidOfToken;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    modifier whenNotPaused() {\n        require(!paused, \"Paused !\");\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 maxSupply_\n    ) ERC721(name, symbol) {\n        maxSupply = maxSupply_;\n    }\n\n    function togglePause() external override(IOpenPauseable) onlyOwner {\n        paused = !paused;\n        emit SetPaused(paused, msg.sender);\n    }\n\n    function burn(uint256 tokenID) external override(IOpenBoundOz) {\n        address owner = ownerOf(tokenID);\n        require(owner == msg.sender, \"Not owner\");\n\n        uint256 index = _tokenIndexOfOwner[owner];\n        uint256 lastIndex = _tokens.length - 1;\n\n        _burn(tokenID);\n\n        if (index != lastIndex) {\n            _tokens[index] = _tokens[lastIndex];\n            _tokenIndexOfOwner[ownerOf(_tokens[lastIndex])] = index;\n        }\n        _tokens.pop();\n\n        delete _cidOfToken[tokenID];\n        delete _tokenIndexOfOwner[owner];\n        delete _tokenOfOwner[owner];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256) {\n        require(index < _tokens.length, \"Invalid index\");\n\n        return _tokens[index];\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index == 0 && balanceOf(owner) == 1, \"Invalid index\");\n\n        return _tokenOfOwner[owner];\n    }\n\n    function mint(uint256 cid) public override(IOpenBoundOz) whenNotPaused returns (uint256) {\n        require((maxSupply == 0) || totalSupply() < maxSupply, \"Max supply reached\");\n        require(balanceOf(msg.sender) == 0, \"Already minted or claimed\");\n\n        uint256 tokenID = getMyTokenID(cid);\n\n        _tokens.push(tokenID);\n        _tokenOfOwner[msg.sender] = tokenID;\n        _tokenIndexOfOwner[msg.sender] = _tokens.length - 1;\n        _cidOfToken[tokenID] = cid;\n\n        _mint(msg.sender, tokenID);\n\n        return tokenID;\n    }\n\n    function claim(uint256 tokenID, uint256 cid) public override(IOpenBoundOz) whenNotPaused {\n        require(tokenID == getMyTokenID(cid), \"Not owner\");\n        mint(cid);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721) returns (bool) {\n        return\n            interfaceId == type(IOpenBoundOz).interfaceId ||\n            interfaceId == type(IOpenPauseable).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function getMyTokenID(uint256 cid) public view override(IOpenBoundOz) returns (uint256) {\n        return getTokenID(cid, msg.sender);\n    }\n\n    function getCID(uint256 tokenID) public view override(IOpenBoundOz) returns (uint256) {\n        return _cidOfToken[tokenID];\n    }\n\n    function totalSupply() public view override(IERC721Enumerable) returns (uint256) {\n        return _tokens.length;\n    }\n\n    function tokenURI(uint256 tokenID) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenID), \"NFT doesn't exists\");\n\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(getCID(tokenID))));\n    }\n\n    function getTokenID(uint256 cid, address addr) public pure override(IOpenBoundOz) returns (uint256) {\n        return _tokenID(cid, addr);\n    }\n\n    function _tokenID(uint256 cid, address addr) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(cid, addr)));\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 // tokenId\n    ) internal pure override(ERC721) {\n        require(from == address(0) || to == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "contracts/interfaces/IOpenBoundOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IOpenBoundOz {\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n\n    function getTokenID(uint256 cid, address addr) external pure returns (uint256);\n}\n"
    },
    "contracts/testsOld/OpenERC165.t.sol": {
      "content": "// SPDX-License-Identifier: MITs\npragma solidity 0.8.9;\n\nimport \"./OpenNFTs.t.sol\";\n\ncontract OpenERC165Test is OpenNFTsOldTest {\n    function testERC165() public {\n        assertTrue(op.supportsInterface(type(IERC165).interfaceId));\n        assertFalse(op.supportsInterface(0xffffffff));\n    }\n\n    function testERC721() public {\n        assertTrue(op.supportsInterface(type(IERC721).interfaceId));\n    }\n\n    function testERC721Enumerable() public {\n        assertTrue(op.supportsInterface(type(IERC721Enumerable).interfaceId));\n    }\n\n    function testERC721Metadata() public {\n        assertTrue(op.supportsInterface(type(IERC721Metadata).interfaceId));\n    }\n\n    function testER2981() public {\n        assertTrue(op.supportsInterface(type(IERC2981).interfaceId));\n    }\n\n    function testERC173() public {\n        assertTrue(op.supportsInterface(type(IERC173).interfaceId));\n    }\n\n    function testPausable() public {\n        assertTrue(op.supportsInterface(type(IOpenPauseable).interfaceId));\n    }\n\n    function testMarketable() public {\n        assertTrue(op.supportsInterface(type(IOpenMarketable).interfaceId));\n    }\n\n    function testNot() public {\n        assertFalse(op.supportsInterface(type(IERC1155).interfaceId));\n    }\n\n    function testOpenNFTsVN() public {\n        assertTrue(op.supportsInterface(opId));\n        assertTrue(opn.supportsInterface(opId));\n    }\n\n    function testSupportsInterface() public {\n        assertTrue(op.supportsInterface(type(IERC165).interfaceId));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}