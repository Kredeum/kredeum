{
  "language": "Solidity",
  "sources": {
    "OpenNFTs/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.17;\n\ninterface IERC1155 {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155METADATAURI.sol)\n\npragma solidity ^0.8.17;\n\ninterface IERC1155MetadataURI {\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155TokenReceiver.sol)\n\npragma solidity ^0.8.17;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external returns (bytes4);\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function transferOwnership(address newOwner) external;\n\n    function owner() external view returns (address currentOwner);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC2981 {\n    function royaltyInfo(uint256 tokenID, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external\n        payable;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n    function transferFrom(address from, address to, uint256 tokenId) external payable;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721Enumerable {\n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        returns (bytes4);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IERCNftInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Infos of either ERC721 or ERC1155 NFT\ninterface IERCNftInfos {\n    enum NftType {\n        ERC721,\n        ERC1155\n    }\n\n    struct CollectionInfos {\n        address collection;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n        uint256 balanceOf;\n        bool approvedForAll;\n        bool[] supported;\n        NftType erc;\n    }\n\n    struct NftInfos {\n        uint256 tokenID;\n        string tokenURI;\n        address owner;\n        address approved;\n        uint256 balanceOf;\n        NftType erc;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenChecker {\n    function checkErcInterfaces(address smartcontract)\n        external\n        view\n        returns (bool[] memory interfaceIdsChecks);\n\n    function checkSupportedInterfaces(address smartcontract, bool erc, bytes4[] memory interfaceIds)\n        external\n        view\n        returns (bool[] memory interfaceIdsChecks);\n\n    function isCollection(address collection) external view returns (bool check);\n\n    function isCollections(address[] memory collection)\n        external\n        view\n        returns (bool[] memory checks);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenCloneable {\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bytes memory params\n    ) external;\n\n    function initialized() external view returns (bool);\n\n    function template() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function parent() external view returns (address);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenCloner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenCloner {\n    function clone(address template) external returns (address);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenGetter is IERCNftInfos {\n    function getCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos);\n\n    function getNftInfos(address collection, uint256 tokenID, address account)\n        external\n        view\n        returns (NftInfos memory nftInfos);\n\n    function getNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        external\n        view\n        returns (NftInfos[] memory nftsInfos, uint256 count, uint256 total);\n\n    function getNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        external\n        view\n        returns (NftInfos[] memory nftsInfos);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\ninterface IOpenMarketable is IOpenReceiverInfos {\n    enum Approve {\n        None,\n        One,\n        All\n    }\n\n    event SetDefaultRoyalty(address receiver, uint96 fee);\n\n    event SetTokenRoyalty(uint256 tokenID, address receiver, uint96 fee);\n\n    event SetMintPrice(uint256 price);\n\n    event SetTokenPrice(uint256 tokenID, uint256 price);\n\n    event Pay(\n        uint256 tokenID,\n        uint256 price,\n        address seller,\n        uint256 paid,\n        address receiver,\n        uint256 royalties,\n        uint256 fee,\n        address buyer,\n        uint256 unspent\n    );\n\n    function withdraw() external returns (uint256);\n\n    function setMintPrice(uint256 price) external;\n\n    function setDefaultRoyalty(address receiver, uint96 fee) external;\n\n    function setTokenPrice(uint256 tokenID, uint256 price) external;\n\n    function setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee) external;\n\n    function minimal() external view returns (bool);\n\n    function getMintPrice() external view returns (uint256 price);\n\n    function getDefaultRoyalty() external view returns (ReceiverInfos memory receiver);\n\n    function getTokenPrice(uint256 tokenID) external view returns (uint256 price);\n\n    function getTokenRoyalty(uint256 tokenID)\n        external\n        view\n        returns (ReceiverInfos memory receiver);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTs {\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenPauseable {\n    event SetPaused(bool indexed paused, address indexed account);\n\n    function paused() external returns (bool);\n\n    function togglePause() external;\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenReceiverInfos {\n    struct ReceiverInfos {\n        address account;\n        uint96 fee;\n        uint256 minimum;\n    }\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenRegistry {\n    function setRegisterer(address registerer) external;\n\n    function removeAddress(address addr) external;\n\n    function addAddress(address addr) external;\n\n    function addAddresses(address[] memory addrs) external;\n\n    function getAddresses() external view returns (address[] memory);\n\n    function registerer() external view returns (address);\n\n    function countAddresses() external view returns (uint256);\n\n    function isRegistered(address addr) external view returns (bool registered);\n}\n"
    },
    "OpenNFTs/contracts/interfaces/IOpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\n\ninterface IOpenResolver is IERCNftInfos {\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    ) external view returns (CollectionInfos[] memory collectionsInfos);\n}\n"
    },
    "OpenNFTs/contracts/libraries/Bafkrey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary Bafkrey {\n    bytes32 private constant _BASE32_SYMBOLS = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    /// Transfom uint256 to IPFS CID V1 base32 raw (starting with \"bafkrei\")\n    function uint256ToCid(uint256 id) internal pure returns (string memory) {\n        // IPFS CID V1 base32 raw \"bafrei...\" => 5 bits => uint32\n        // uint256 id  = 256 bits = 1 bit + 51 uint32 = 1 + 51 * 5 = 256\n        // 00 added right =>\n        // uint8 + uint256 + 00 = 258 bits = uint8 + 50 uint32 + (3 bits + 00) = uint8 + 51 uint32 = 3 + 51 * 5 = 258\n\n        bytes memory buffer = new bytes(52);\n        uint8 high3 = uint8(id >> 253);\n        buffer[0] = _BASE32_SYMBOLS[high3 & 0x1f];\n\n        id <<= 2;\n        for (uint256 i = 51; i > 0; i--) {\n            buffer[i] = _BASE32_SYMBOLS[id & 0x1f];\n            id >>= 5;\n        }\n\n        return string(abi.encodePacked(\"bafkrei\", buffer));\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenCloner/OpenCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenCloneable —— IOpenCloneable\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloneable is IOpenCloneable, OpenERC165 {\n    bool public initialized;\n    string public template;\n    uint256 public version;\n\n    function parent() external view override(IOpenCloneable) returns (address parent_) {\n        // eip1167 deployed code = 45 bytes = 10 bytes + 20 bytes address + 15 bytes\n        // extract bytes 10 to 30: shift 2 bytes (16 bits) then truncate to address 20 bytes (uint160)\n        return (address(this).code.length == 45)\n            ? address(uint160(uint256(bytes32(address(this).code)) >> 16))\n            : address(0);\n    }\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address owner,\n        bytes memory params\n    ) public virtual override(IOpenCloneable);\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenCloneable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory template_, uint256 version_) internal {\n        require(initialized == false, \"Already initialized\");\n        initialized = true;\n\n        template = template_;\n        version = version_;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenCloner/OpenCloner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-1167: Minimal Proxy Contract\n// https://eips.ethereum.org/EIPS/eip-1167\n//\n// Derived from OpenZeppelin Contracts (proxy/Clones.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy/Clones.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//        |\n//   OpenCloner —— IOpenCloner\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IOpenCloner.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\n\nabstract contract OpenCloner is IOpenCloner, OpenERC165 {\n    /// @notice Clone template (via EIP-1167)\n    /// @param  template_ : template address\n    /// @return clone_ : clone address\n    function clone(address template_) public virtual returns (address clone_) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, template_))\n            mstore(\n                add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            clone_ := create(0, ptr, 0x37)\n        }\n        assert(clone_ != address(0));\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenCloner).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-165: Standard Interface Detection\n// https://eips.ethereum.org/EIPS/eip-165\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/utils/introspection/ERC165.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165 —— IERC165\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nabstract contract OpenERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7; //  type(IERC165).interfaceId\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-173: Contract Ownership Standard\n// https://eips.ethereum.org/EIPS/eip-173\n//\n// Derived from OpenZeppelin Contracts (access/Ownable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/access/Ownable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC173 —— IERC173\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenERC173 is IERC173, OpenERC165 {\n    bool private _openERC173Initialized;\n    address private _owner;\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Not owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external override(IERC173) onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function owner() public view override(IERC173) returns (address) {\n        return _owner;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x7f5828d0 || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(address owner_) internal {\n        require(_openERC173Initialized == false, \"Already initialized\");\n        _openERC173Initialized = true;\n\n        _transferOwnership(owner_);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-2981: NFT Royalty Standard\n// https://eips.ethereum.org/EIPS/eip-2981\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/common/ERC2981.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC2981 —— IERC2981 —— IOpenReceiverInfos\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\nabstract contract OpenERC2981 is IERC2981, IOpenReceiverInfos, OpenERC165 {\n    uint256 internal _mintPrice;\n    ReceiverInfos internal _defaultRoyalty;\n    mapping(uint256 => ReceiverInfos) internal _tokenRoyalty;\n\n    uint96 internal constant _MAX_FEE = 10_000;\n\n    modifier notTooExpensive(uint256 price) {\n        /// otherwise may overflow\n        require(price < 2 ** 128, \"Too expensive\");\n        _;\n    }\n\n    modifier lessThanMaxFee(uint256 fee) {\n        require(fee <= _MAX_FEE, \"Royalty fee exceed price\");\n        _;\n    }\n\n    function royaltyInfo(uint256 tokenID, uint256 price)\n        public\n        view\n        override(IERC2981)\n        notTooExpensive(price)\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        ReceiverInfos memory royalty = _tokenRoyalty[tokenID];\n\n        if (royalty.account == address(0)) {\n            royalty = _defaultRoyalty;\n        }\n\n        royaltyAmount = _calculateAmount(price, royalty.fee);\n\n        /// MINIMAL royaltyAmount\n        if (royalty.minimum > 0) {\n            /// With zero price, token owner can bypass royalties...\n            /// SO a defaultRoyaltyAmount is calculated with _mintPrice as a base\n            /// (can only be modified by collection owner)\n            /// BUT collection owner can higher too much mintPrice making fees too high\n            /// SO a royalty.minimum if calculated for each token on minting (and on setTokenRoyalty)\n\n            /// MIN(royalty.minimum, defaultRoyaltyAmount)\n            uint256 defaultRoyaltyAmount = _calculateAmount(_mintPrice, royalty.fee);\n            uint256 minimumRoyaltyAmount =\n                royalty.minimum < defaultRoyaltyAmount ? royalty.minimum : defaultRoyaltyAmount;\n\n            /// MAX(normalRoyaltyAmount, minimumRoyaltyAmount)\n            royaltyAmount =\n                royaltyAmount < minimumRoyaltyAmount ? minimumRoyaltyAmount : royaltyAmount;\n        }\n\n        return (royalty.account, royaltyAmount);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\n    }\n\n    function _calculateAmount(uint256 price, uint96 fee) internal pure returns (uint256) {\n        return (price * fee) / _MAX_FEE;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//  OpenERC165\n//       |\n//  OpenERC721 —— IERC721\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\nabstract contract OpenERC721 is IERC721, OpenERC165 {\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    modifier onlyTokenOwnerOrApproved(uint256 tokenID) {\n        require(_isOwnerOrApproved(msg.sender, tokenID), \"Not token owner nor approved\");\n        _;\n    }\n\n    modifier existsToken(uint256 tokenID) {\n        require(_owners[tokenID] != address(0), \"Invalid token ID\");\n        _;\n    }\n\n    function transferFrom(address from, address to, uint256 tokenID)\n        external\n        payable\n        override(IERC721)\n    {\n        _transferFrom(from, to, tokenID);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data)\n        external\n        payable\n        override(IERC721)\n    {\n        _safeTransferFrom(from, to, tokenID, data);\n    }\n\n    function approve(address spender, uint256 tokenID) public override(IERC721) {\n        require(_isOwnerOrOperator(msg.sender, tokenID), \"Not token owner nor operator\");\n\n        _tokenApprovals[tokenID] = spender;\n        emit Approval(ownerOf(tokenID), spender, tokenID);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721) {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenID)\n        public\n        payable\n        override(IERC721)\n    {\n        _safeTransferFrom(from, to, tokenID, \"\");\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x80ac58cd // = type(IERC721).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view override(IERC721) returns (uint256) {\n        require(owner != address(0), \"Invalid zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenID)\n        public\n        view\n        override(IERC721)\n        existsToken(tokenID)\n        returns (address)\n    {\n        return _owners[tokenID];\n    }\n\n    function getApproved(uint256 tokenID)\n        public\n        view\n        override(IERC721)\n        existsToken(tokenID)\n        returns (address)\n    {\n        return _tokenApprovals[tokenID];\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override(IERC721)\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function _mint(address to, string memory, uint256 tokenID) internal virtual {\n        require(to != address(0), \"Mint to zero address\");\n        require(_owners[tokenID] == address(0), \"Token already minted\");\n        require(_isERC721Receiver(address(0), to, tokenID, \"\"), \"Not ERC721Received\");\n\n        _balances[to] += 1;\n        _owners[tokenID] = to;\n\n        emit Transfer(address(0), to, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual {\n        address owner = ownerOf(tokenID);\n        require(owner != address(0), \"Invalid token ID\");\n\n        assert(_balances[owner] > 0);\n\n        _balances[owner] -= 1;\n        delete _tokenApprovals[tokenID];\n        delete _owners[tokenID];\n\n        emit Transfer(owner, address(0), tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID) internal virtual {}\n\n    function _isOwnerOrOperator(address spender, uint256 tokenID)\n        internal\n        view\n        virtual\n        returns (bool ownerOrOperator)\n    {\n        address tokenOwner = ownerOf(tokenID);\n        ownerOrOperator = (tokenOwner == spender || isApprovedForAll(tokenOwner, spender));\n    }\n\n    function _safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data)\n        private\n    {\n        require(_isERC721Receiver(from, to, tokenID, data), \"Not ERC721Receiver\");\n\n        _transferFrom(from, to, tokenID);\n    }\n\n    function _transferFrom(address from, address to, uint256 tokenID)\n        private\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        require(from != address(0), \"Transfer from zero address\");\n        require(to != address(0), \"Transfer to zero address\");\n        require(from == ownerOf(tokenID), \"From not owner\");\n\n        _transferFromBefore(from, to, tokenID);\n\n        delete _tokenApprovals[tokenID];\n\n        if (from != to) {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n            _owners[tokenID] = to;\n        }\n\n        emit Transfer(from, to, tokenID);\n    }\n\n    function _isERC721Receiver(address from, address to, uint256 tokenID, bytes memory data)\n        private\n        returns (bool)\n    {\n        return to.code.length == 0\n            || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenID, data)\n                == IERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    function _isOwnerOrApproved(address spender, uint256 tokenID)\n        private\n        view\n        returns (bool ownerOrApproved)\n    {\n        ownerOrApproved =\n            (_isOwnerOrOperator(spender, tokenID) || (getApproved(tokenID) == spender));\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/extensions/ERC721Enumerable.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/...\n// ...contracts/token/ERC721/extensions/ERC721Enumerable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//      OpenERC165\n//           |\n//      OpenERC721\n//           |\n//  OpenERC721Enumerable —— IERC721Enumerable\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\n\nabstract contract OpenERC721Enumerable is IERC721Enumerable, OpenERC721 {\n    // Array of all tokens ID\n    uint256[] private _allTokens;\n\n    // Mapping from owner to list of token IDs owned\n    // mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to owned index\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Mapping from token ID to all index\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < OpenERC721.balanceOf(owner), \"Invalid index!\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() external view override(IERC721Enumerable) returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256)\n    {\n        require(index < _allTokens.length, \"Invalid index!\");\n        return _allTokens[index];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721)\n        returns (bool)\n    {\n        return interfaceId == 0x780e9d63 || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, string memory tokenURI, uint256 tokenID)\n        internal\n        virtual\n        override(OpenERC721)\n    {\n        _addOwnedToken(to, tokenID);\n\n        _allTokensIndex[tokenID] = _allTokens.length;\n        _allTokens.push(tokenID);\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override(OpenERC721) {\n        address from = ownerOf(tokenID);\n\n        _removeOwnedToken(from, tokenID);\n\n        uint256 allBurnIndex = _allTokensIndex[tokenID];\n        uint256 allLastIndex = _allTokens.length - 1;\n        uint256 allLastTokenId = _allTokens[allLastIndex];\n\n        _allTokensIndex[allLastTokenId] = allBurnIndex;\n        delete _allTokensIndex[tokenID];\n\n        _allTokens[allBurnIndex] = allLastTokenId;\n        _allTokens.pop();\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        virtual\n        override(OpenERC721)\n    {\n        _removeOwnedToken(from, tokenID);\n        _addOwnedToken(to, tokenID);\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _addOwnedToken(address owner, uint256 tokenID) private {\n        _ownedTokensIndex[tokenID] = _ownedTokens[owner].length;\n        _ownedTokens[owner].push(tokenID);\n    }\n\n    function _removeOwnedToken(address owner, uint256 tokenID) private {\n        uint256 burnIndex = _ownedTokensIndex[tokenID];\n        uint256 lastIndex = OpenERC721.balanceOf(owner) - 1;\n\n        if (burnIndex != lastIndex) {\n            uint256 lastTokenId = _ownedTokens[owner][lastIndex];\n            _ownedTokens[owner][burnIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = burnIndex;\n        }\n\n        delete _ownedTokensIndex[tokenID];\n        _ownedTokens[owner].pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// EIP-721: Non-Fungible Token Standard\n// https://eips.ethereum.org/EIPS/eip-721\n//\n// Derived from OpenZeppelin Contracts (token/ERC721/ERC721.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//     OpenERC165\n//          |\n//     OpenERC721\n//          |\n//  OpenERC721Metadata —— IERC721Metadata\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\n\nabstract contract OpenERC721Metadata is IERC721Metadata, OpenERC721 {\n    bool private _openERC721MetadataInitialized;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => string) private _tokenURIs;\n\n    function name() external view virtual override(IERC721Metadata) returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view virtual override(IERC721Metadata) returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenID)\n        external\n        view\n        virtual\n        override(IERC721Metadata)\n        existsToken(tokenID)\n        returns (string memory)\n    {\n        return _tokenURIs[tokenID];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721)\n        returns (bool)\n    {\n        return interfaceId == 0x5b5e139f || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(string memory name_, string memory symbol_) internal {\n        require(_openERC721MetadataInitialized == false, \"Already initialized\");\n        _openERC721MetadataInitialized = true;\n\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function _mint(address to, string memory newTokenURI, uint256 tokenID)\n        internal\n        virtual\n        override(OpenERC721)\n    {\n        _tokenURIs[tokenID] = newTokenURI;\n\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override(OpenERC721) {\n        delete _tokenURIs[tokenID];\n\n        super._burn(tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenGuard\n//\npragma solidity ^0.8.17;\n\nabstract contract OpenGuard {\n    bool private _locked;\n\n    modifier reEntryGuard() {\n        require(!_locked, \"No re-entry!\");\n\n        _locked = true;\n\n        _;\n\n        _locked = false;\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//        |\n//        ————————————————————————————\n//        |            |             |\n//   OpenERC721    OpenERC173   OpenERC2981\n//      (NFT)      (Ownable)   (RoyaltyInfo)\n//        |            |             |\n//        ————————————————————————————\n//        |\n//  OpenMarketable —— IOpenMarketable - OpenGuard\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC2981.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenGuard.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\n\nabstract contract OpenMarketable is\n    IOpenMarketable,\n    OpenERC721,\n    OpenERC173,\n    OpenERC2981,\n    OpenGuard\n{\n    mapping(uint256 => uint256) internal _tokenPrice;\n\n    bool public minimal;\n\n    ReceiverInfos internal _treasury;\n\n    /// @notice withdraw eth\n    function withdraw() external override(IOpenMarketable) onlyOwner returns (uint256) {\n        return _withdraw();\n    }\n\n    /// @notice SET default mint price\n    /// @param price : default price in wei\n    function setMintPrice(uint256 price) public override(IOpenMarketable) onlyOwner {\n        _setMintPrice(price);\n    }\n\n    /// @notice SET default royalty info\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10000\n    function setDefaultRoyalty(address receiver, uint96 fee)\n        public\n        override(IOpenMarketable)\n        onlyOwner\n    {\n        _setDefaultRoyalty(receiver, fee);\n    }\n\n    /// @notice SET token price\n    /// @param tokenID : token ID\n    /// @param price : token price in wei\n    function setTokenPrice(uint256 tokenID, uint256 price)\n        public\n        override(IOpenMarketable)\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _setTokenPrice(tokenID, price, address(this), Approve.All);\n    }\n\n    /// @notice SET token royalty info\n    /// @param tokenID : token ID\n    /// @param receiver : address of the royalty receiver, or address(0) to reset\n    /// @param fee : fee Numerator, less than 10_000\n    function setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee)\n        public\n        override(IOpenMarketable)\n        existsToken(tokenID)\n        onlyOwner\n        onlyTokenOwnerOrApproved(tokenID)\n    {\n        _setTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    function getMintPrice() public view override(IOpenMarketable) returns (uint256) {\n        return _mintPrice;\n    }\n\n    function getTokenPrice(uint256 tokenID)\n        public\n        view\n        override(IOpenMarketable)\n        returns (uint256)\n    {\n        return _tokenPrice[tokenID];\n    }\n\n    /// @notice GET default royalty info\n    /// @return receiver : default royalty receiver infos\n    function getDefaultRoyalty()\n        public\n        view\n        override(IOpenMarketable)\n        returns (ReceiverInfos memory receiver)\n    {\n        receiver = _defaultRoyalty;\n    }\n\n    /// @notice GET token royalty info\n    /// @param tokenID : token ID\n    /// @return receiver :  token royalty receiver infos\n    function getTokenRoyalty(uint256 tokenID)\n        public\n        view\n        override(IOpenMarketable)\n        returns (ReceiverInfos memory receiver)\n    {\n        receiver = _tokenRoyalty[tokenID];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721, OpenERC173, OpenERC2981)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenMarketable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _initialize(\n        uint256 mintPrice_,\n        address receiver_,\n        uint96 fee_,\n        address treasury_,\n        uint96 treasuryFee_,\n        bool minimal_\n    ) internal {\n        minimal = minimal_;\n        _mintPrice = mintPrice_;\n        _defaultRoyalty = _createReceiverInfos(receiver_, fee_);\n        _treasury = _createReceiverInfos(treasury_, treasuryFee_);\n    }\n\n    function _mint(address to, string memory tokenURI, uint256 tokenID)\n        internal\n        virtual\n        override(OpenERC721)\n    {\n        _setTokenRoyalty(tokenID, _defaultRoyalty.account, _defaultRoyalty.fee);\n\n        _pay(tokenID, _mintPrice, to, owner());\n\n        super._mint(to, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal virtual override(OpenERC721) {\n        delete _tokenRoyalty[tokenID];\n        delete _tokenPrice[tokenID];\n\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        virtual\n        override(OpenERC721)\n    {\n        /// Transfer: pay token price (including royalties) to previous token owner (and royalty receiver)\n        _pay(tokenID, _tokenPrice[tokenID], to, ownerOf(tokenID));\n\n        delete _tokenPrice[tokenID];\n\n        super._transferFromBefore(from, to, tokenID);\n    }\n\n    function _setDefaultRoyalty(address receiver, uint96 fee) internal lessThanMaxFee(fee) {\n        _defaultRoyalty = _createReceiverInfos(receiver, fee);\n\n        emit SetDefaultRoyalty(receiver, fee);\n    }\n\n    function _setTokenRoyalty(uint256 tokenID, address receiver, uint96 fee)\n        internal\n        lessThanMaxFee(fee)\n    {\n        _tokenRoyalty[tokenID] = _createReceiverInfos(receiver, fee);\n\n        emit SetTokenRoyalty(tokenID, receiver, fee);\n    }\n\n    /// @notice SET token price\n    /// @param tokenID : token ID\n    /// @param price : token price in wei\n    function _setTokenPrice(uint256 tokenID, uint256 price, address approved, Approve approveType)\n        internal\n        onlyTokenOwnerOrApproved(tokenID)\n        notTooExpensive(price)\n    {\n        _tokenPrice[tokenID] = price;\n\n        emit SetTokenPrice(tokenID, price);\n\n        if (approveType == Approve.All) {\n            setApprovalForAll(approved, true);\n        } else if (approveType == Approve.One) {\n            approve(approved, tokenID);\n        }\n    }\n\n    function _setMintPrice(uint256 price) internal notTooExpensive(price) {\n        _mintPrice = price;\n        _setDefaultRoyalty(_defaultRoyalty.account, _defaultRoyalty.fee);\n\n        emit SetMintPrice(price);\n    }\n\n    function _transferValue(address to, uint256 value) internal virtual returns (uint256) {\n        bool success;\n        if (value > 0) {\n            (success,) = to.call{value: value, gas: 2300}(\"\");\n        }\n        return success ? value : 0;\n    }\n\n    function _withdraw() internal virtual returns (uint256) {\n        return _transferValue(msg.sender, address(this).balance);\n    }\n\n    function _createReceiverInfos(address receiver, uint96 fee)\n        internal\n        view\n        returns (ReceiverInfos memory)\n    {\n        return ReceiverInfos(receiver, fee, minimal ? _calculateAmount(_mintPrice, fee) : 0);\n    }\n\n    function _pay(uint256 tokenID, uint256 price, address buyer, address seller)\n        private\n        reEntryGuard\n    {\n        require(buyer != address(0), \"Invalid buyer\");\n        require(seller != address(0), \"Invalid seller\");\n\n        address receiver;\n        uint256 royalties;\n        uint256 fee;\n        uint256 paid;\n        uint256 unspent;\n\n        (receiver, royalties) = royaltyInfo(tokenID, price);\n        if (receiver == address(0)) royalties = 0;\n\n        // no payment (and no fee) if buyer is seller\n        // no payment (and no fee) if price and royalties are null\n        if (buyer != seller && (price + royalties > 0)) {\n            fee = _calculateAmount(price, _treasury.fee);\n\n            /// Pay seller\n            if (price > royalties + fee) {\n                /// when price is sufficient, royalties and fees are deducted from price\n                require(msg.value >= price, \"Not enough funds\");\n                paid = _transferValue(seller, price - (royalties + fee));\n            } else {\n                /// when price is zero (or too low), royalties and fees are added to price\n                /// this is to enforce royalty payment\n                require(msg.value >= price + royalties + fee, \"Not enough funds\");\n                paid = _transferValue(seller, price);\n            }\n\n            /// Transfer royalties to receiver\n            paid += _transferValue(receiver, royalties);\n\n            /// Transfer fee to protocol treasury\n            paid += _transferValue(_treasury.account, fee);\n        }\n        unspent = msg.value - paid;\n\n        /// Transfer back unspent funds to buyer\n        paid += _transferValue(buyer, unspent);\n\n        emit Pay(tokenID, price, seller, paid, receiver, royalties, fee, buyer, unspent);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ——————————————————————————————————————————————————————————————————————\n//       |                                       |             |              |\n//   OpenERC721                            OpenERC2981    OpenERC173    OpenCloneable\n//     (NFT)                              (RoyaltyInfo)    (ownable)          |\n//       |                                        |            |              |\n//       ——————————————————————————————————————   |     ————————              |\n//       |                        |           |   |     |      |              |\n//  OpenERC721Metadata  OpenERC721Enumerable  |   ———————      |              |\n//       |                        |           |   |            |              |\n//       |                        |      OpenMarketable   OpenPauseable       |\n//       |                        |             |              |              |\n//       ——————————————————————————————————————————————————————————————————————\n//       |\n//    OpenNFTs —— IOpenNFTs\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol\";\nimport \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\n\n/// @title OpenNFTs smartcontract\nabstract contract OpenNFTs is\n    IOpenNFTs,\n    OpenERC721Metadata,\n    OpenERC721Enumerable,\n    OpenMarketable,\n    OpenPauseable,\n    OpenCloneable\n{\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice onlyMinter, by default only owner can mint, can be overriden\n    modifier onlyMinter() virtual {\n        require(msg.sender == owner(), \"Not minter\");\n        _;\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID) external override(IOpenNFTs) onlyTokenOwnerOrApproved(tokenID) {\n        _burn(tokenID);\n    }\n\n    function mint(address minter, string memory tokenURI)\n        public\n        override(IOpenNFTs)\n        onlyMinter\n        returns (uint256 tokenID)\n    {\n        tokenID = tokenIdNext++;\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    /// @notice test if this interface is supported\n    /// @param interfaceId interfaceId to test\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenMarketable, OpenERC721Metadata, OpenERC721Enumerable, OpenCloneable, OpenPauseable)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTs).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice _initialize\n    /// @param name_ name of the NFT Collection\n    /// @param symbol_ symbol of the NFT Collection\n    /// @param owner_ owner of the NFT Collection\n    // solhint-disable-next-line comprehensive-interface\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        uint256 mintPrice_,\n        address receiver_,\n        uint96 fee_,\n        address treasury_,\n        uint96 treasuryFee_,\n        bool minimal_\n    ) internal {\n        tokenIdNext = 1;\n\n        OpenCloneable._initialize(\"OpenNFTs\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n        OpenMarketable._initialize(mintPrice_, receiver_, fee_, treasury_, treasuryFee_, minimal_);\n    }\n\n    /// @notice _mint\n    /// @param minter minter address\n    /// @param tokenURI token metdata URI\n    /// @param tokenID token ID\n    function _mint(address minter, string memory tokenURI, uint256 tokenID)\n        internal\n        override(OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable)\n    {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID)\n        internal\n        override(OpenERC721Enumerable, OpenERC721Metadata, OpenMarketable)\n    {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        override(OpenERC721, OpenMarketable, OpenERC721Enumerable)\n    {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (token/common/ERC2981.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenPauseable –– IOpenPauseable\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nabstract contract OpenPauseable is IOpenPauseable, OpenERC173 {\n    bool private _paused;\n\n    modifier onlyWhenNotPaused() {\n        require(!_paused, \"Paused!\");\n        _;\n    }\n\n    function togglePause() external override(IOpenPauseable) onlyOwner {\n        _setPaused(!_paused);\n    }\n\n    function paused() external view override(IOpenPauseable) returns (bool) {\n        return _paused;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC173)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenPauseable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _setPaused(bool paused_) private {\n        _paused = paused_;\n        emit SetPaused(_paused, msg.sender);\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//  OpenChecker —— IOpenChecker\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\n\nabstract contract OpenChecker is IOpenChecker, OpenERC165 {\n    /// 0xffffffff :  O Invalid\n    /// 0x01ffc9a7 :  1 ERC165\n    /// 0x80ac58cd :  2 ERC721\n    /// 0x5b5e139f :  3 ERC721Metadata\n    /// 0x780e9d63 :  4 ERC721Enumerable\n    /// 0x150b7a02 :  5 ERC721TokenReceiver\n    /// 0xd9b67a26 :  6 ERC1155\n    /// 0x0e89341c :  7 ERC1155MetadataURI\n    /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n    /// 0x7f5828d0 :  9 ERC173\n    /// 0x2a55205a : 10 ERC2981\n    bytes4[] private _ercInterfaceIds = [\n        bytes4(0xffffffff),\n        bytes4(0x01ffc9a7),\n        bytes4(0x80ac58cd),\n        bytes4(0x5b5e139f),\n        bytes4(0x780e9d63),\n        bytes4(0x150b7a02),\n        bytes4(0xd9b67a26),\n        bytes4(0x0e89341c),\n        bytes4(0x4e2312e0),\n        bytes4(0x7f5828d0),\n        bytes4(0x2a55205a)\n    ];\n    uint8 private constant _INVALID = 0;\n    uint8 private constant _ERC165 = 1;\n    uint8 private constant _ERC721 = 2;\n    uint8 private constant _ERC1155 = 6;\n\n    modifier onlyContract(address account) {\n        require(account.code.length > 0, \"Not smartcontract\");\n        _;\n    }\n\n    function isCollections(address[] memory smartcontracts)\n        public\n        view\n        override(IOpenChecker)\n        returns (bool[] memory checks)\n    {\n        uint256 len = smartcontracts.length;\n        checks = new bool[](len);\n\n        for (uint256 i = 0; i < len; i++) {\n            checks[i] = isCollection(smartcontracts[i]);\n        }\n    }\n\n    // TODO check only 4 interfaces\n    function isCollection(address smartcontract)\n        public\n        view\n        override(IOpenChecker)\n        onlyContract(smartcontract)\n        returns (bool)\n    {\n        bool[] memory checks = checkErcInterfaces(smartcontract);\n\n        // (!INVALID and ERC165) and (ERC721 or ERC1155)\n        return !checks[_INVALID] && checks[_ERC165] && (checks[_ERC721] || checks[_ERC1155]);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenChecker).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function checkErcInterfaces(address smartcontract)\n        public\n        view\n        override(IOpenChecker)\n        returns (bool[] memory)\n    {\n        return checkSupportedInterfaces(smartcontract, true, new bytes4[](0));\n    }\n\n    function checkSupportedInterfaces(address smartcontract, bool erc, bytes4[] memory interfaceIds)\n        public\n        view\n        override(IOpenChecker)\n        onlyContract(smartcontract)\n        returns (bool[] memory interfaceIdsChecks)\n    {\n        uint256 len1 = _ercInterfaceIds.length;\n        uint256 len2 = interfaceIds.length;\n        uint256 len = (erc ? len1 : 0) + len2;\n        uint256 i;\n\n        interfaceIdsChecks = new bool[](len);\n\n        if (erc) {\n            for (uint256 j = 0; j < len1; j++) {\n                interfaceIdsChecks[i++] =\n                    IERC165(smartcontract).supportsInterface(_ercInterfaceIds[j]);\n            }\n        }\n        for (uint256 k = 0; k < len2; k++) {\n            interfaceIdsChecks[i++] = IERC165(smartcontract).supportsInterface(interfaceIds[k]);\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenChecker\n//        |\n//  OpenGetter —— IOpenGetter\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport \"OpenNFTs/contracts/interfaces/IERC173.sol\";\n\nabstract contract OpenGetter is IOpenGetter, OpenChecker {\n    uint8 private constant _INVALID = 0;\n    uint8 private constant _ERC165 = 1;\n    uint8 private constant _ERC721 = 2;\n    uint8 private constant _ERC721_ENUMERABLE = 2;\n    uint8 private constant _ERC1155 = 6;\n    bytes4 private constant _ERC721_ID = 0x80ac58cd;\n    bytes4 private constant _ERC1155_ID = 0xd9b67a26;\n    bytes4 private constant _ERC721_METADATA_ID = 0x5b5e139f;\n    bytes4 private constant _ERC1155_METADATA_URI_ID = 0x0e89341c;\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenChecker)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenGetter).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionInfos(address collection, address account)\n        public\n        view\n        override(IOpenGetter)\n        returns (\n            // override(IOpenGetter)\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = _getCollectionInfos(collection, account, new bytes4[](0));\n    }\n\n    function getNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        public\n        view\n        override(IOpenGetter)\n        returns (NftInfos[] memory nftsInfos)\n    {\n        uint256 len = tokenIDs.length;\n        nftsInfos = new NftInfos[](len);\n        for (uint256 i; i < len; i++) {\n            nftsInfos[i] = _getNftInfos(collection, tokenIDs[i], account);\n        }\n    }\n\n    function getNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        public\n        view\n        override(IOpenGetter)\n        returns (NftInfos[] memory nftsInfos, uint256 count, uint256 total)\n    {\n        bool[] memory supported = checkErcInterfaces(collection);\n\n        // IF ERC721 & ERC721Enumerable supported\n        if (supported[_ERC721] && supported[_ERC721_ENUMERABLE]) {\n            if (account == address(0)) {\n                total = IERC721Enumerable(collection).totalSupply();\n\n                require(offset <= total, \"Invalid offset\");\n                count = (offset + limit <= total) ? limit : total - offset;\n\n                nftsInfos = new NftInfos[](count);\n                for (uint256 i; i < count; i++) {\n                    nftsInfos[i] = _getNftInfos(\n                        collection, IERC721Enumerable(collection).tokenByIndex(offset + i), account\n                    );\n                }\n            } else {\n                total = IERC721(collection).balanceOf(account);\n\n                require(offset <= total, \"Invalid offset\");\n                count = (offset + limit <= total) ? limit : total - offset;\n\n                nftsInfos = new NftInfos[](count);\n                for (uint256 i; i < count; i++) {\n                    nftsInfos[i] = _getNftInfos(\n                        collection,\n                        IERC721Enumerable(collection).tokenOfOwnerByIndex(account, offset + i),\n                        account\n                    );\n                }\n            }\n        }\n    }\n\n    function getNftInfos(address collection, uint256 tokenID, address account)\n        public\n        view\n        override(IOpenGetter)\n        returns (NftInfos memory nftInfos)\n    {\n        return _getNftInfos(collection, tokenID, account);\n    }\n\n    function _getNftInfos(address collection, uint256 tokenID, address account)\n        internal\n        view\n        onlyContract(collection)\n        returns (NftInfos memory nftInfos)\n    {\n        nftInfos.tokenID = tokenID;\n\n        if (IERC165(collection).supportsInterface(_ERC721_ID)) {\n            try IERC721(collection).ownerOf(tokenID) returns (address owner) {\n                nftInfos.owner = owner;\n            } catch {}\n\n            // tokenID exists <=> owner != 0\n            if (nftInfos.owner != address(0)) {\n                nftInfos.approved = IERC721(collection).getApproved(tokenID);\n                if (IERC165(collection).supportsInterface(_ERC721_METADATA_ID)) {\n                    nftInfos.tokenURI = IERC721Metadata(collection).tokenURI(tokenID);\n                }\n            }\n        } else if (IERC165(collection).supportsInterface(_ERC1155_ID)) {\n            if (account != address(0)) {\n                nftInfos.balanceOf = IERC1155(collection).balanceOf(account, tokenID);\n            }\n            if (IERC165(collection).supportsInterface(_ERC1155_METADATA_URI_ID)) {\n                nftInfos.tokenURI = IERC1155MetadataURI(collection).uri(tokenID);\n            }\n        }\n    }\n\n    function _getCollectionInfos(address collection, address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        onlyContract(collection)\n        returns (CollectionInfos memory collectionInfos)\n    {\n        bool[] memory supported = checkSupportedInterfaces(collection, true, interfaceIds);\n        collectionInfos.supported = supported;\n\n        // ERC165 must be supported\n        require(!supported[_INVALID] && supported[_ERC165], \"Not ERC165\");\n\n        // ERC721 or ERC1155 must be supported\n        require(supported[_ERC721] || supported[_ERC1155], \"Not NFT smartcontract\");\n\n        collectionInfos.collection = collection;\n\n        // try ERC173 owner\n        try IERC173(collection).owner() returns (address owner) {\n            collectionInfos.owner = owner;\n        } catch {}\n\n        // try ERC721Metadata name\n        try IERC721Metadata(collection).name() returns (string memory name) {\n            collectionInfos.name = name;\n        } catch {}\n\n        // try ERC721Metadata symbol\n        try IERC721Metadata(collection).symbol() returns (string memory symbol) {\n            collectionInfos.symbol = symbol;\n        } catch {}\n\n        // try ERC721Enumerable totalSupply\n        try IERC721Enumerable(collection).totalSupply() returns (uint256 totalSupply) {\n            collectionInfos.totalSupply = totalSupply;\n        } catch {}\n\n        if (account != address(0)) {\n            try IERC721(collection).balanceOf(account) returns (uint256 balanceOf) {\n                collectionInfos.balanceOf = balanceOf;\n            } catch {}\n\n            try IERC721(collection).isApprovedForAll(account, collection) returns (\n                bool approvedForAll\n            ) {\n                collectionInfos.approvedForAll = approvedForAll;\n            } catch {}\n        }\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//   OpenERC173\n//        |\n//  OpenRegistry —— IOpenRegistry\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\n\nabstract contract OpenRegistry is IOpenRegistry, OpenERC173 {\n    mapping(address => uint256) private _numAddress;\n    address[] private _addresses;\n    address public registerer;\n\n    /// @notice onlyRegisterer, by default owner is registerer and can add addresses, can be overriden\n    modifier onlyRegisterer() virtual {\n        require(msg.sender == owner() || msg.sender == registerer, \"Not registerer nor owner\");\n        _;\n    }\n\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address) virtual {\n        _;\n    }\n\n    function setRegisterer(address registerer_) external override(IOpenRegistry) onlyOwner {\n        _setRegisterer(registerer_);\n    }\n\n    function addAddresses(address[] memory addrs) external override(IOpenRegistry) {\n        uint256 len = addrs.length;\n        for (uint256 i = 0; i < len; i++) {\n            _addAddress(addrs[i]);\n        }\n    }\n\n    function addAddress(address addr) external override(IOpenRegistry) {\n        _addAddress(addr);\n    }\n\n    function removeAddress(address addr) external override(IOpenRegistry) {\n        _removeAddress(addr);\n    }\n\n    function countAddresses() external view override(IOpenRegistry) returns (uint256) {\n        return _addresses.length;\n    }\n\n    function isRegistered(address addr) public view returns (bool) {\n        return _numAddress[addr] >= 1;\n    }\n\n    function getAddresses() public view override(IOpenRegistry) returns (address[] memory) {\n        return _addresses;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC173)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenRegistry).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _setRegisterer(address registerer_) internal {\n        registerer = registerer_;\n    }\n\n    function _addAddress(address addr) private onlyRegisterer onlyValid(addr) {\n        if (!isRegistered(addr)) {\n            _addresses.push(addr);\n            _numAddress[addr] = _addresses.length;\n        }\n    }\n\n    function _removeAddress(address addr) private onlyRegisterer {\n        require(isRegistered(addr), \"Not registered\");\n\n        uint256 num = _numAddress[addr];\n        if (num != _addresses.length) {\n            address addrLast = _addresses[_addresses.length - 1];\n            _addresses[num - 1] = addrLast;\n            _numAddress[addrLast] = num;\n        }\n\n        delete (_numAddress[addr]);\n        _addresses.pop();\n    }\n}\n"
    },
    "OpenNFTs/contracts/OpenResolver/OpenResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from OpenZeppelin Contracts (utils/introspection/ERC165Ckecker.sol)\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165Checker.sol\n//\n//       ___           ___         ___           ___              ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\            /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\           \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\           \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\      _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\    /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/    \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~      \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\           \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\           \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/            \\__\\/         \\__\\/                   \\__\\/\n//\n//   OpenERC165\n//        |\n//        ————————————————\n//        |              |\n//   OpenChecker     OpenERC173\n//        |              |\n//    OpenGetter    OpenRegistry\n//        |              |\n//        ————————————————\n//        |\n//  OpenResolver —— IOpenResolver\n//\npragma solidity ^0.8.17;\n\nimport \"OpenNFTs/contracts/OpenResolver/OpenRegistry.sol\";\nimport \"OpenNFTs/contracts/OpenResolver/OpenGetter.sol\";\nimport \"OpenNFTs/contracts/interfaces/IOpenResolver.sol\";\n\nabstract contract OpenResolver is IOpenResolver, OpenRegistry, OpenGetter {\n    /// @notice isValid, by default all addresses valid\n    modifier onlyValid(address addr) override(OpenRegistry) {\n        require(isCollection(addr), \"Not Collection\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenRegistry, OpenGetter)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IOpenResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function getCollectionsInfos(\n        address[] memory collections,\n        address account,\n        bytes4[] memory interfaceIds\n    ) public view override(IOpenResolver) returns (CollectionInfos[] memory collectionsInfos) {\n        uint256 len = collections.length;\n        collectionsInfos = new CollectionInfos[](len);\n        for (uint256 i = 0; i < len; i++) {\n            collectionsInfos[i] = _getCollectionInfos(collections[i], account, interfaceIds);\n        }\n    }\n\n    function _getCollectionsInfos(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (CollectionInfos[] memory collectionsInfos)\n    {\n        CollectionInfos[] memory collectionsInfosAll =\n            getCollectionsInfos(getAddresses(), account, interfaceIds);\n\n        uint256 count;\n        uint256 len = collectionsInfosAll.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                count++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](count);\n\n        uint256 j;\n        for (uint256 i = 0; i < len; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j++] = collectionsInfosAll[i];\n            }\n        }\n    }\n}\n"
    },
    "src/interfaces/ICloneFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ICloneFactoryV2 {\n    /// @notice New Implementation Event\n    /// @param implementation Address of the implementation\n    /// @param creator Address of the creator\n    /// @return index Index inside implementations array (starts at 0)\n    event ImplementationNew(address indexed implementation, address indexed creator, uint256 index);\n\n    /// @notice Set Template Event\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    event TemplateSet(string indexed templateName, address indexed template);\n\n    /// @notice Set Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templateSet(string calldata templateName, address template) external;\n\n    /// @notice Add Implementation\n    /// @param implementationToAdd Addresses of implementations to add\n    function implementationsAdd(address[] calldata implementationToAdd) external;\n\n    /// @notice Get Template\n    /// @param templateName Name of the template\n    /// @param template Address of the template\n    function templates(string calldata templateName) external view returns (address template);\n\n    /// @notice Count Implementations\n    /// @return count Number of implementations\n    function implementationsCount() external view returns (uint256 count);\n\n    /// @notice Get Implementation from Implementations array\n    /// @param index Index of implementation\n    /// @return implementation Address of implementation\n    function implementations(uint256 index) external view returns (address implementation);\n}\n"
    },
    "src/interfaces/IInterfacesIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IInterfacesIds {\n    function ids() external pure returns (bytes4[] memory interfacesIds);\n}\n"
    },
    "src/interfaces/INFTsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface INFTsFactoryV2 {\n    struct NftData {\n        address nft;\n        uint256 balanceOf;\n        address owner;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function clone(string memory name, string memory symbol, string memory templateName, bool[] memory options)\n        external\n        returns (address);\n\n    function balancesOf(address owner) external view returns (NftData[] memory);\n}\n"
    },
    "src/interfaces/IOpenAutoMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOpenAutoMarket {\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(address minter, string memory tokenURI, uint256 price, address receiver, uint96 fee)\n        external\n        payable\n        returns (uint256 tokenID);\n\n    function gift(address to, uint256 tokenID) external payable;\n\n    function buy(uint256 tokenID) external payable;\n\n    function open() external view returns (bool);\n}\n"
    },
    "src/interfaces/IOpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenBound {\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getTokenID(address addr, uint256 cid) external view returns (uint256 tokenID);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n}\n"
    },
    "src/interfaces/IOpenBound4973.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOpenBound4973 {\n    function mint(uint256 tokenID) external;\n\n    function mint(address addr, uint256 tokenID) external;\n}\n"
    },
    "src/interfaces/IOpenBoundOz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenBoundOz {\n    function mint(uint256 tokenID) external returns (uint256);\n\n    function claim(uint256 tokenID, uint256 cid) external;\n\n    function burn(uint256 tokenID) external;\n\n    function getMyTokenID(uint256 cid) external view returns (uint256);\n\n    function getCID(uint256 tokenID) external view returns (uint256);\n\n    function getTokenID(uint256 cid, address addr) external pure returns (uint256);\n}\n"
    },
    "src/interfaces/IOpenMulti.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOpenMulti {\n    function claim(uint256 tokenID) external;\n\n    function exists(uint256) external returns (bool);\n}\n"
    },
    "src/interfaces/IOpenNFTs.old.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTs {\n    function initialize(string memory name, string memory symbol, address owner, bool[] memory options) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n}\n"
    },
    "src/interfaces/IOpenNFTsFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTsFactoryV3 {\n    event Clone(string indexed templateName, address indexed clone, string indexed name, string symbol);\n\n    event SetResolver(address indexed resolver);\n\n    event SetTemplate(string indexed templateName, address indexed template, uint256 index);\n\n    function setResolver(address resolver) external;\n\n    function setTreasury(address treasury, uint96 treasuryFee) external;\n\n    function setTemplate(string memory templateName, address template) external;\n\n    function clone(string memory name, string memory symbol, string memory templateName, bytes memory params)\n        external\n        returns (address);\n\n    function template(string memory templateName) external view returns (address);\n\n    function templates(uint256 num) external view returns (address);\n\n    function countTemplates() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IOpenNFTsInfos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IERCNftInfos} from \"OpenNFTs/contracts/interfaces/IERCNftInfos.sol\";\nimport {IOpenReceiverInfos} from \"OpenNFTs/contracts/interfaces/IOpenReceiverInfos.sol\";\n\ninterface IOpenNFTsInfos is IERCNftInfos, IOpenReceiverInfos {\n    struct OpenNFTsCollectionInfos {\n        uint256 version;\n        string template;\n        bool open;\n        bool minimal;\n        uint256 price;\n        ReceiverInfos receiver;\n    }\n\n    struct OpenNFTsNftInfos {\n        uint256 price;\n        ReceiverInfos receiver;\n    }\n}\n"
    },
    "src/interfaces/IOpenNFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IOpenNFTsInfos} from \"src/interfaces/IOpenNFTsInfos.sol\";\n\ninterface IOpenNFTsResolver is IOpenNFTsInfos {\n    function getOpenNFTsNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        external\n        view\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        );\n\n    function getOpenNFTsNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        external\n        view\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos\n        );\n\n    function getOpenNFTsNftInfos(address collection, uint256 tokenID, address account)\n        external\n        view\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsnftInfos,\n            CollectionInfos memory collectionInfos\n        );\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        );\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos);\n}\n"
    },
    "src/interfaces/IOpenNFTsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTsV0 {\n    function addUser(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "src/interfaces/IOpenNFTsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTsV1 {\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n}\n"
    },
    "src/interfaces/IOpenNFTsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTsV2 {\n    function transferOwnership(address newOwner) external;\n\n    function initialize(string memory name, string memory symbol) external;\n\n    function mintNFT(address minter, string memory jsonURI) external returns (uint256 tokenID_);\n\n    function owner() external view returns (address owner_);\n}\n"
    },
    "src/interfaces/IOpenNFTsV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTsV3 {\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "src/interfaces/IOpenNFTsV3Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IOpenNFTsV3Plus {\n    function initialize(string memory name, string memory symbol, address owner, bool[] memory options) external;\n\n    function mintOpenNFT(address minter, string memory jsonURI) external returns (uint256 tokenID);\n\n    function burnOpenNFT(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n\n    function burnable() external view returns (bool);\n}\n"
    },
    "src/interfaces/IOpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOpenNFTsV4 {\n    function mint(string memory tokenURI) external returns (uint256 tokenID);\n\n    function mint(address minter, string memory tokenURI) external returns (uint256 tokenID);\n\n    function burn(uint256 tokenID) external;\n\n    function open() external view returns (bool);\n}\n"
    },
    "src/interfaces/IOpenPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOpenPass {\n    function setTokenURI(string memory tokenURI) external;\n\n    function safeMint(address to) external;\n}\n"
    },
    "src/interfaces/IOpenProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOpenProof {\n    function mintOpenProof(address minter, string memory jsonURI) external returns (uint256);\n}\n"
    },
    "src/interfaces/ITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ITest {\n    function setUp() external;\n}\n"
    },
    "src/next/InterfacesIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC165} from \"OpenNFTs/contracts/interfaces/IERC165.sol\";\n\nimport {IERC721} from \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport {IERC721Metadata} from \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport {IERC721Enumerable} from \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport {IERC721TokenReceiver} from \"OpenNFTs/contracts/interfaces/IERC721TokenReceiver.sol\";\n\nimport {IERC1155} from \"OpenNFTs/contracts/interfaces/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"OpenNFTs/contracts/interfaces/IERC1155MetadataURI.sol\";\nimport {IERC1155TokenReceiver} from \"OpenNFTs/contracts/interfaces/IERC1155TokenReceiver.sol\";\n\nimport {IERC173} from \"OpenNFTs/contracts/interfaces/IERC173.sol\";\nimport {IERC2981} from \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\n\nimport {IOpenNFTs} from \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport {IOpenChecker} from \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport {IOpenCloneable} from \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport {IOpenMarketable} from \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport {IOpenPauseable} from \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport {IOpenNFTsV0} from \"src/interfaces/IOpenNFTsV0.sol\";\nimport {IOpenNFTsV1} from \"src/interfaces/IOpenNFTsV1.sol\";\nimport {IOpenNFTsV2} from \"src/interfaces/IOpenNFTsV2.sol\";\nimport {IOpenNFTsV3} from \"src/interfaces/IOpenNFTsV3.sol\";\nimport {IOpenNFTsV4} from \"src/interfaces/IOpenNFTsV4.sol\";\nimport {IOpenAutoMarket} from \"src/interfaces/IOpenAutoMarket.sol\";\nimport {IOpenBound} from \"src/interfaces/IOpenBound.sol\";\n\nimport {ICloneFactoryV2} from \"src/interfaces/ICloneFactoryV2.sol\";\nimport {INFTsFactoryV2} from \"src/interfaces/INFTsFactoryV2.sol\";\nimport {IOpenNFTsFactoryV3} from \"src/interfaces/IOpenNFTsFactoryV3.sol\";\n\nimport {IOpenNFTsResolver} from \"src/interfaces/IOpenNFTsResolver.sol\";\n\nimport {IOpenNFTs as IOpenNFTsOld} from \"src/interfaces/IOpenNFTs.old.sol\";\nimport {IOpenNFTsV3Plus} from \"src/interfaces/IOpenNFTsV3Plus.sol\";\n\nimport {IInterfacesIds} from \"src/interfaces/IInterfacesIds.sol\";\n\n/// @title InterfaceIds calculation\n/// @author zapaz.eth\n/// @notice Calculates various ERC165, ERC721 and ERC1155 interface Ids\n///  @notice and Kredeum OpenNFTs interface Ids\ncontract InterfacesIds is IInterfacesIds {\n    /// @notice Main and only function to calculate Interface Ids\n    /// @notice No params\n    /// @return interfacesIds : Array of all interfaceIds\n    function ids() external pure override(IInterfacesIds) returns (bytes4[] memory interfacesIds) {\n        uint256 i;\n        uint256 imax = 28;\n\n        interfacesIds = new bytes4[](imax);\n\n        interfacesIds[i++] = bytes4(0x01ffc9a7); // IERC165\n\n        interfacesIds[i++] = bytes4(0x80ac58cd); // IERC721\n        interfacesIds[i++] = bytes4(0x780e9d63); // IERC721Enumerable\n        interfacesIds[i++] = bytes4(0x5b5e139f); // IERC721Metadata\n        interfacesIds[i++] = bytes4(0x150b7a02); // IERC721TokenReceiver\n\n        interfacesIds[i++] = bytes4(0xd9b67a26); // IERC1155\n        interfacesIds[i++] = bytes4(0x0e89341c); // IERC1155MetadataURI\n        interfacesIds[i++] = bytes4(0x4e2312e0); // IERC1155TokenReceiver\n\n        interfacesIds[i++] = bytes4(0x7f5828d0); // IERC173\n        interfacesIds[i++] = bytes4(0x2a55205a); // IERC2981\n\n        interfacesIds[i++] = type(IOpenNFTs).interfaceId;\n        interfacesIds[i++] = type(IOpenChecker).interfaceId;\n        interfacesIds[i++] = type(IOpenCloneable).interfaceId;\n        interfacesIds[i++] = type(IOpenMarketable).interfaceId;\n        interfacesIds[i++] = type(IOpenPauseable).interfaceId;\n\n        interfacesIds[i++] = bytes4(0x4b68d431); // IOpenNFTsV0\n        interfacesIds[i++] = bytes4(0xeacabe14); // IOpenNFTsV1\n        interfacesIds[i++] = bytes4(0xd94a1db2); // IOpenNFTsV2\n        interfacesIds[i++] = bytes4(0x5c838d8b); // IOpenNFTsV3\n        interfacesIds[i++] = type(IOpenNFTsV4).interfaceId;\n        interfacesIds[i++] = type(IOpenAutoMarket).interfaceId;\n        interfacesIds[i++] = type(IOpenBound).interfaceId;\n\n        interfacesIds[i++] = bytes4(0xcfc6c434); // ICloneFactoryV2\n        interfacesIds[i++] = bytes4(0x78f5e5c2); // INFTsFactoryV2\n        interfacesIds[i++] = type(IOpenNFTsFactoryV3).interfaceId; // IOpenNFTsFactoryV3\n\n        interfacesIds[i++] = bytes4(0x03dc8d64); // IOpenNFTsOld\n        interfacesIds[i++] = bytes4(0x5f5f00ef); // IOpenNFTsV3Plus\n\n        interfacesIds[i++] = type(IInterfacesIds).interfaceId;\n\n        assert(i == imax);\n    }\n}\n"
    },
    "src/next/OpenBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//  OpenERC165 (supports)\n//      |\n//      ———————————————————————————————————————————————\n//      |                 |             |             |\n//  OpenERC721 (NFT)  OpenERC173  OpenChecker  OpenCloneable\n//      |             (ownable)         |             |\n//      |                 |             |             |\n//      |                 |             |             |\n//      |            OpenPauseable      |             |\n//      |                 |             |             |\n//      ———————————————————————————————————————————————\n//      |\n//  OpenBound --- IOpenBound --- IERC721Enumerable --- IERC721Metadata\n//\npragma solidity ^0.8.17;\n\nimport {OpenERC721} from \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport {OpenERC173} from \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\n\nimport {OpenPauseable} from \"OpenNFTs/contracts/OpenNFTs/OpenPauseable.sol\";\nimport {OpenCloneable} from \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport {OpenChecker} from \"OpenNFTs/contracts/OpenResolver/OpenChecker.sol\";\n\nimport {IERC721} from \"OpenNFTs/contracts/interfaces/IERC721.sol\";\nimport {IERC721Enumerable} from \"OpenNFTs/contracts/interfaces/IERC721Enumerable.sol\";\nimport {IERC721Metadata} from \"OpenNFTs/contracts/interfaces/IERC721Metadata.sol\";\nimport {Bafkrey} from \"OpenNFTs/contracts/libraries/Bafkrey.sol\";\n\nimport {IOpenBound} from \"src/interfaces/IOpenBound.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"src/interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenBound smartcontract\n/// limited to one nft per address\ncontract OpenBound is\n    IOpenBound,\n    IERC721Enumerable,\n    IERC721Metadata,\n    OpenCloneable,\n    OpenChecker,\n    OpenPauseable,\n    OpenERC721\n{\n    uint256 public maxSupply;\n\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) internal _tokenOfOwner;\n    mapping(address => uint256) internal _tokenIndexOfOwner;\n    mapping(uint256 => uint256) internal _cidOfToken;\n    uint256[] internal _tokens;\n\n    string private constant _BASE_URI = \"ipfs://\";\n\n    function mint(uint256 cid) external override(IOpenBound) onlyWhenNotPaused returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, cid);\n    }\n\n    function claim(uint256 tokenID, uint256 cid) external override(IOpenBound) onlyWhenNotPaused {\n        require(tokenID == _tokenID(msg.sender, cid), \"Not owner\");\n        _mint(msg.sender, cid);\n    }\n\n    function burn(uint256 tokenID) external override(IOpenBound) {\n        address from = ownerOf(tokenID);\n        require(from == msg.sender, \"Not owner\");\n\n        _burn(tokenID);\n    }\n\n    function getMyTokenID(uint256 cid) external view override(IOpenBound) returns (uint256 myTokenID) {\n        myTokenID = _tokenID(msg.sender, cid);\n    }\n\n    function getCID(uint256 tokenID) external view override(IOpenBound) returns (uint256 cid) {\n        cid = _cidOfToken[tokenID];\n    }\n\n    /// IERC721Enumerable\n    function totalSupply() external view override(IERC721Enumerable) returns (uint256 tokensLength) {\n        tokensLength = _tokens.length;\n    }\n\n    function tokenOfOwnerByIndex(address tokenOwner, uint256 index)\n        external\n        view\n        override(IERC721Enumerable)\n        returns (uint256 tokenID)\n    {\n        require(index == 0 && balanceOf(tokenOwner) == 1, \"Invalid index\");\n\n        tokenID = _tokenOfOwner[tokenOwner];\n    }\n\n    function tokenByIndex(uint256 index) external view override(IERC721Enumerable) returns (uint256 tokenID) {\n        require(index < _tokens.length, \"Invalid index\");\n\n        tokenID = _tokens[index];\n    }\n\n    /// IERC721Metadata\n    function tokenURI(uint256 tokenID)\n        external\n        view\n        override(IERC721Metadata)\n        existsToken(tokenID)\n        returns (string memory)\n    {\n        return _tokenURI(_cidOfToken[tokenID]);\n    }\n\n    function getTokenID(address addr, uint256 cid) external pure override(IOpenBound) returns (uint256 tokenID) {\n        tokenID = _tokenID(addr, cid);\n    }\n\n    function initialize(string memory name_, string memory symbol_, address owner_, bytes memory params_)\n        public\n        override(OpenCloneable)\n    {\n        (bytes memory subparams_,,) = abi.decode(params_, (bytes, address, uint96));\n        maxSupply = abi.decode(subparams_, (uint256));\n\n        OpenCloneable._initialize(\"OpenBound\", maxSupply);\n        OpenERC173._initialize(owner_);\n\n        name = name_;\n        symbol = symbol_;\n    }\n\n    /// IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(OpenPauseable, OpenCloneable, OpenERC721, OpenChecker)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenBound).interfaceId || interfaceId == type(IOpenNFTsOld).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || interfaceId == type(IERC721Enumerable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address to, uint256 cid) internal returns (uint256 tokenID) {\n        require((maxSupply == 0) || _tokens.length < maxSupply, \"Max supply reached\");\n        require(balanceOf(to) == 0, \"Already minted or claimed\");\n\n        tokenID = _tokenID(to, cid);\n\n        _tokens.push(tokenID);\n        _tokenOfOwner[to] = tokenID;\n        _tokenIndexOfOwner[to] = _tokens.length - 1;\n        _cidOfToken[tokenID] = cid;\n\n        _mint(to, _tokenURI(cid), tokenID);\n    }\n\n    function _mint(address to, string memory newTokenURI, uint256 tokenID) internal override(OpenERC721) {\n        super._mint(to, newTokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721) {\n        address from = ownerOf(tokenID);\n        uint256 index = _tokenIndexOfOwner[from];\n        uint256 lastIndex = _tokens.length - 1;\n\n        if (index != lastIndex) {\n            _tokens[index] = _tokens[lastIndex];\n            _tokenIndexOfOwner[ownerOf(_tokens[lastIndex])] = index;\n        }\n        _tokens.pop();\n\n        delete _cidOfToken[tokenID];\n        delete _tokenIndexOfOwner[from];\n        delete _tokenOfOwner[from];\n\n        super._burn(tokenID);\n    }\n\n    function _tokenID(address addr, uint256 cid) internal pure returns (uint256 tokenID) {\n        tokenID = uint256(keccak256(abi.encodePacked(cid, addr)));\n    }\n\n    function _tokenURI(uint256 cid) internal pure returns (string memory) {\n        return string(abi.encodePacked(_BASE_URI, Bafkrey.uint256ToCid(cid)));\n    }\n\n    function _transferFromBefore(\n        address from,\n        address to,\n        uint256 // tokenId\n    ) internal pure override {\n        require(from == address(0) || to == address(0), \"Non transferable NFT\");\n    }\n}\n"
    },
    "src/next/OpenNFTsResolverV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//    OpenERC165\n//        |\n//  OpenResolver\n//        |\n//  OpenNFTsResolver —— IOpenNFTsResolver\n//\npragma solidity ^0.8.17;\n\nimport {OpenERC173} from \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport {OpenResolver} from \"OpenNFTs/contracts/OpenResolver/OpenResolver.sol\";\nimport {OpenRegistry} from \"OpenNFTs/contracts/OpenResolver/OpenRegistry.sol\";\nimport {OpenGetter} from \"OpenNFTs/contracts/OpenResolver/OpenGetter.sol\";\n\nimport {IERC2981} from \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport {IOpenNFTs} from \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport {IOpenChecker} from \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport {IOpenCloneable} from \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport {IOpenMarketable} from \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport {IOpenPauseable} from \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\n\nimport {IOpenNFTsResolver} from \"src/interfaces/IOpenNFTsResolver.sol\";\nimport {IOpenNFTsV0} from \"src/interfaces/IOpenNFTsV0.sol\";\nimport {IOpenNFTsV1} from \"src/interfaces/IOpenNFTsV1.sol\";\nimport {IOpenNFTsV2} from \"src/interfaces/IOpenNFTsV2.sol\";\nimport {IOpenNFTsV3} from \"src/interfaces/IOpenNFTsV3.sol\";\nimport {IOpenNFTsV4} from \"src/interfaces/IOpenNFTsV4.sol\";\nimport {IOpenAutoMarket} from \"src/interfaces/IOpenAutoMarket.sol\";\nimport {IOpenBound} from \"src/interfaces/IOpenBound.sol\";\n\ncontract OpenNFTsResolverV4 is IOpenNFTsResolver, OpenResolver {\n    bytes4[] private _interfaceIds = new bytes4[](12);\n\n    uint8 private constant _IERC_2981 = 10;\n    uint8 private constant _IERC_LENGTH = 11;\n\n    uint8 private constant _IOPEN_NFTS = _IERC_LENGTH + 0;\n    uint8 private constant _IOPEN_CHECKER = _IERC_LENGTH + 1;\n    uint8 private constant _IOPEN_CLONEABLE = _IERC_LENGTH + 2;\n    uint8 private constant _IOPEN_MARKETABLE = _IERC_LENGTH + 3;\n    uint8 private constant _IOPEN_PAUSEABLE = _IERC_LENGTH + 4;\n\n    uint8 private constant _IOPEN_NFTS_V0 = _IERC_LENGTH + 5;\n    uint8 private constant _IOPEN_NFTS_V1 = _IERC_LENGTH + 6;\n    uint8 private constant _IOPEN_NFTS_V2 = _IERC_LENGTH + 7;\n    uint8 private constant _IOPEN_NFTS_V3 = _IERC_LENGTH + 8;\n    uint8 private constant _IOPEN_NFTS_V4 = _IERC_LENGTH + 9;\n    uint8 private constant _IOPEN_AUTOMARKET = _IERC_LENGTH + 10;\n    uint8 private constant _IOPEN_BOUND = _IERC_LENGTH + 11;\n\n    constructor(address owner_, address registerer_) {\n        OpenERC173._initialize(owner_);\n        OpenRegistry._setRegisterer(registerer_);\n\n        /// 0xffffffff :  O Invalid\n        /// 0x01ffc9a7 :  1 ERC165\n        /// 0x80ac58cd :  2 ERC721\n        /// 0x5b5e139f :  3 ERC721Metadata\n        /// 0x780e9d63 :  4 ERC721Enumerable\n        /// 0x150b7a02 :  5 ERC721TokenReceiver\n        /// 0xd9b67a26 :  6 ERC1155\n        /// 0x0e89341c :  7 ERC1155MetadataURI\n        /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n        /// 0x7f5828d0 :  9 ERC173\n        /// 0x2a55205a : 10 ERC2981\n\n        _interfaceIds[_IOPEN_NFTS - _IERC_LENGTH] = type(IOpenNFTs).interfaceId;\n        _interfaceIds[_IOPEN_CHECKER - _IERC_LENGTH] = type(IOpenChecker).interfaceId;\n        _interfaceIds[_IOPEN_CLONEABLE - _IERC_LENGTH] = type(IOpenCloneable).interfaceId;\n        _interfaceIds[_IOPEN_MARKETABLE - _IERC_LENGTH] = type(IOpenMarketable).interfaceId;\n        _interfaceIds[_IOPEN_PAUSEABLE - _IERC_LENGTH] = type(IOpenPauseable).interfaceId;\n\n        _interfaceIds[_IOPEN_NFTS_V0 - _IERC_LENGTH] = type(IOpenNFTsV0).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V1 - _IERC_LENGTH] = type(IOpenNFTsV1).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V2 - _IERC_LENGTH] = type(IOpenNFTsV2).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V3 - _IERC_LENGTH] = type(IOpenNFTsV3).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V4 - _IERC_LENGTH] = type(IOpenNFTsV4).interfaceId;\n        _interfaceIds[_IOPEN_AUTOMARKET - _IERC_LENGTH] = type(IOpenAutoMarket).interfaceId;\n        _interfaceIds[_IOPEN_BOUND - _IERC_LENGTH] = type(IOpenBound).interfaceId;\n    }\n\n    function getOpenNFTsNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftsInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        (nftsInfos, count, total) = OpenGetter.getNftsInfos(collection, account, limit, offset);\n\n        openNTFsNftInfos = new OpenNFTsNftInfos[](nftsInfos.length);\n        for (uint256 i = 0; i < nftsInfos.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, nftsInfos[i].tokenID, collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftsInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, address(0), _interfaceIds);\n\n        nftsInfos = OpenGetter.getNftsInfos(collection, tokenIDs, account);\n        openNTFsNftInfos = new OpenNFTsNftInfos[](tokenIDs.length);\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, tokenIDs[i], collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftInfos(address collection, uint256 tokenID, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        nftInfos = OpenGetter.getNftInfos(collection, tokenID, account);\n        openNTFsNftInfos = _getOpenNFTsNftInfos(collection, tokenID, collectionInfos.supported);\n    }\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        CollectionInfos[] memory collectionsInfosAll = getCollectionsInfos(getAddresses(), account, _interfaceIds);\n        total = collectionsInfosAll.length;\n\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                count++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](count);\n        openNFTsCollectionsInfos = new OpenNFTsCollectionInfos[](count);\n\n        uint256 j;\n        for (uint256 i = 0; i < total; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j] = collectionsInfosAll[i];\n                openNFTsCollectionsInfos[j] =\n                    _getOpenNFTsCollectionInfos(collectionsInfosAll[i].collection, collectionsInfosAll[i].supported);\n                j++;\n            }\n        }\n    }\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos)\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n        openNTFscollectionInfos = _getOpenNFTsCollectionInfos(collection, collectionInfos.supported);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(OpenResolver) returns (bool) {\n        return interfaceId == type(IOpenNFTsResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _getOpenNFTsNftInfos(address collection, uint256 tokenID, bool[] memory supported)\n        internal\n        view\n        returns (OpenNFTsNftInfos memory openNftInfos)\n    {\n        if (supported[_IOPEN_MARKETABLE]) {\n            openNftInfos.receiver = IOpenMarketable(payable(collection)).getTokenRoyalty(tokenID);\n            openNftInfos.price = IOpenMarketable(payable(collection)).getTokenPrice(tokenID);\n        } else if (supported[_IERC_2981]) {\n            (openNftInfos.receiver.account,) = IERC2981(payable(collection)).royaltyInfo(tokenID, 1);\n        }\n    }\n\n    function _getOpenNFTsCollectionInfos(address collection, bool[] memory supported)\n        internal\n        view\n        returns (OpenNFTsCollectionInfos memory collInfos)\n    {\n        if (supported[_IOPEN_CLONEABLE]) {\n            collInfos.version = IOpenCloneable(collection).version(); // 4\n            collInfos.template = IOpenCloneable(collection).template(); // OpenNFTsV4 or OpenBound\n            collInfos.open = IOpenNFTsV4(collection).open();\n        } else if (supported[_IOPEN_NFTS_V3]) {\n            collInfos.version = 3;\n            collInfos.template = \"OpenNFTsV3\";\n            collInfos.open = IOpenNFTsV3(collection).open();\n        } else if (supported[_IOPEN_NFTS_V2]) {\n            collInfos.version = 2;\n        } else if (supported[_IOPEN_NFTS_V1]) {\n            collInfos.version = 1;\n        }\n\n        if (supported[_IOPEN_MARKETABLE]) {\n            collInfos.receiver = IOpenMarketable(payable(collection)).getDefaultRoyalty();\n            collInfos.price = IOpenMarketable(payable(collection)).getMintPrice();\n            collInfos.minimal = IOpenMarketable(payable(collection)).minimal();\n        }\n    }\n}\n"
    },
    "src/next/OpenNFTsV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————————————————————————————————\n//       |                                    |            |\n//   OpenERC721                          OpenERC173  OpenCloneable\n//     (NFT)                              (ownable)        |\n//       |                                    |            |\n//       ——————————————————————————           |            |\n//       |                        |           |            |\n//  OpenERC721Metadata  OpenERC721Enumerable  |            |\n//       |                        |           |            |\n//       ———————————————————————————————————————————————————\n//       |\n//   OpenNFTsV5 —— IOpenNFTsV5\n//\npragma solidity ^0.8.9;\n\nimport {OpenERC721} from \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport {OpenERC721Metadata} from \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport {OpenERC721Enumerable} from \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport {OpenERC173} from \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport {OpenCloneable} from \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\n\nimport {IOpenNFTsV4} from \"src/interfaces/IOpenNFTsV4.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsV5 is IOpenNFTsV4, OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable {\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function mint(string memory tokenURI_) external override(IOpenNFTsV4) returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, tokenURI_);\n    }\n\n    function mint(address minter, string memory tokenURI_)\n        external\n        override(IOpenNFTsV4)\n        onlyOwner\n        returns (uint256 tokenID)\n    {\n        tokenID = _mint(minter, tokenURI_);\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID) external override(IOpenNFTsV4) onlyTokenOwnerOrApproved(tokenID) {\n        _burn(tokenID);\n    }\n\n    function initialize(string memory name_, string memory symbol_, address owner_, bytes memory params_)\n        public\n        override(OpenCloneable)\n    {\n        (bytes memory subparams_,,) = abi.decode(params_, (bytes, address, uint96));\n\n        (,,, bool[] memory options_) = abi.decode(subparams_, (uint256, address, uint96, bool[]));\n        open = options_[0];\n\n        tokenIdNext = 1;\n\n        OpenCloneable._initialize(\"OpenNFTsV4\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTsV4).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address minter, string memory tokenURI) internal returns (uint256 tokenID) {\n        tokenID = tokenIdNext++;\n\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    function _mint(address minter, string memory tokenURI, uint256 tokenID)\n        internal\n        override(OpenERC721Enumerable, OpenERC721Metadata)\n    {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721Enumerable, OpenERC721Metadata) {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        override(OpenERC721, OpenERC721Enumerable)\n    {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    },
    "src/OpenAutoMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————————————————————————————————————————————————————————\n//       |                                                         |               |\n//   OpenERC721                                               OpenERC173     OpenCloneable\n//     (NFT)                                                   (ownable)           |\n//       |                                                         |               |\n//       —————————————————————————————————————————————      ————————               |\n//       |                        |                  |      |      |               |\n//  OpenERC721Metadata  OpenERC721Enumerable   OpenERC2981  |      |               |\n//       |                        |           (RoyaltyInfo) |      |               |\n//       |                        |                  |      |      |               |\n//       |                        |                  ————————      |               |\n//       |                        |                  |             |               |\n//       |                        |            OpenMarketable OpenPauseable        |\n//       |                        |                  |             |               |\n//       ———————————————————————————————————————————————————————————————————————————\n//       |\n//    OpenNFTs\n//       |\n//   OpenAutoMarket —— IOpenAutoMarket\n//\npragma solidity ^0.8.9;\n\nimport {OpenNFTs} from \"OpenNFTs/contracts/OpenNFTs/OpenNFTs.sol\";\nimport {OpenCloneable} from \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport {OpenMarketable} from \"OpenNFTs/contracts/OpenNFTs/OpenMarketable.sol\";\n\nimport {IOpenAutoMarket} from \"src/interfaces/IOpenAutoMarket.sol\";\nimport {IOpenNFTs as IOpenNFTsOld} from \"src/interfaces/IOpenNFTs.old.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenAutoMarket is IOpenAutoMarket, OpenNFTs {\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() override(OpenNFTs) {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function gift(address to, uint256 tokenID) external payable override(IOpenAutoMarket) existsToken(tokenID) {\n        setTokenPrice(tokenID, 0);\n\n        safeTransferFrom(msg.sender, to, tokenID);\n    }\n\n    function buy(uint256 tokenID) external payable override(IOpenAutoMarket) existsToken(tokenID) {\n        /// Get token price\n        uint256 price = _tokenPrice[tokenID];\n\n        /// Require price defined\n        require(price > 0, \"Not to sell\");\n\n        /// Require enough value sent\n        require(msg.value >= price, \"Not enough funds\");\n\n        /// Get previous token owner\n        address from = ownerOf(tokenID);\n        assert(from != address(0));\n        require(from != msg.sender, \"Already token owner!\");\n\n        /// This AutoMarket approves msg.sender (requires AutoMarket isAprovedForAll)\n        this.approve(msg.sender, tokenID);\n\n        /// Transfer token\n        safeTransferFrom(from, msg.sender, tokenID);\n\n        /// Reset token price (to be eventualy defined by new owner)\n        delete _tokenPrice[tokenID];\n    }\n\n    function mint(string memory tokenURI) external override(IOpenAutoMarket) returns (uint256 tokenID) {\n        tokenID = mint(msg.sender, tokenURI, 0, address(0), 0);\n    }\n\n    function mint(address minter_, string memory tokenURI_, uint256 tokenPrice_, address receiver_, uint96 receiverFee_)\n        public\n        payable\n        override(IOpenAutoMarket)\n        onlyMinter\n        onlyWhenNotPaused\n        returns (uint256 tokenID)\n    {\n        tokenID = OpenNFTs.mint(minter_, tokenURI_);\n\n        if (tokenPrice_ > 0) OpenMarketable._setTokenPrice(tokenID, tokenPrice_, address(this), Approve.All);\n        if (receiverFee_ > 0) OpenMarketable._setTokenRoyalty(tokenID, receiver_, receiverFee_);\n    }\n\n    function initialize(string memory name_, string memory symbol_, address owner_, bytes memory params_)\n        public\n        virtual\n        override(OpenCloneable)\n    {\n        (bytes memory subparams_, address treasury_, uint96 treasuryFee_) =\n            abi.decode(params_, (bytes, address, uint96));\n\n        (uint256 mintPrice_, address receiver_, uint96 receiverFee_, bool[] memory options_) =\n            abi.decode(subparams_, (uint256, address, uint96, bool[]));\n        open = options_[0];\n\n        OpenNFTs._initialize(\n            name_, symbol_, owner_, mintPrice_, receiver_, receiverFee_, treasury_, treasuryFee_, options_[1]\n        );\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OpenNFTs) returns (bool) {\n        return interfaceId == type(IOpenAutoMarket).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "src/OpenNFTsFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————\n//       |        |            |\n//       |   OpenERC173    OpenCloner\n//       |    (ownable)        |\n//       |        |            |\n//       ———————————————————————\n//       |\n// OpenNFTsFactoryV3 —— IOpenNFTsFactoryV3\n//\npragma solidity ^0.8.9;\n\nimport {OpenERC173} from \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport {OpenCloner} from \"OpenNFTs/contracts/OpenCloner/OpenCloner.sol\";\nimport {IERC165} from \"OpenNFTs/contracts/interfaces/IERC165.sol\";\nimport {IOpenCloneable} from \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\nimport {IOpenRegistry} from \"OpenNFTs/contracts/interfaces/IOpenRegistry.sol\";\n\nimport {IOpenNFTsFactoryV3} from \"src/interfaces/IOpenNFTsFactoryV3.sol\";\nimport {IOpenNFTsV4} from \"src/interfaces/IOpenNFTsV4.sol\";\nimport {IOpenAutoMarket} from \"src/interfaces/IOpenAutoMarket.sol\";\n\n/// @title OpenNFTsFactoryV3 smartcontract\n/// @notice Factory for NFTs contracts: ERC721 or ERC1155\n/// @notice Create new NFTs Collections smartcontracts by cloning templates\ncontract OpenNFTsFactoryV3 is IOpenNFTsFactoryV3, OpenERC173, OpenCloner {\n    /// @notice Named Templates\n\n    mapping(string => uint256) private _numTemplates;\n    address[] public templates;\n\n    address public nftsResolver;\n\n    address private _treasury;\n    uint96 private _treasuryFee;\n\n    constructor(address initialOwner_, address treasury_, uint96 treasuryFee_) {\n        OpenERC173._transferOwnership(initialOwner_);\n        setTreasury(treasury_, treasuryFee_);\n    }\n\n    /// @notice clone template\n    /// @param name name of Clone collection\n    /// @param symbol symbol of Clone collection\n    /// @return clone_ Address of Clone collection\n    function clone(string memory name, string memory symbol, string memory templateName, bytes memory params)\n        external\n        override(IOpenNFTsFactoryV3)\n        returns (address clone_)\n    {\n        clone_ = clone(template(templateName));\n\n        IOpenCloneable(clone_).initialize(name, symbol, msg.sender, abi.encode(params, _treasury, _treasuryFee));\n\n        IOpenRegistry(nftsResolver).addAddress(clone_);\n\n        emit Clone(templateName, clone_, name, symbol);\n    }\n\n    function countTemplates() external view override(IOpenNFTsFactoryV3) returns (uint256 count) {\n        count = templates.length;\n    }\n\n    function setTreasury(address treasury_, uint96 treasuryFee_) public override(IOpenNFTsFactoryV3) onlyOwner {\n        _treasury = treasury_;\n        _treasuryFee = treasuryFee_;\n    }\n\n    function setResolver(address resolver_) public override(IOpenNFTsFactoryV3) onlyOwner {\n        nftsResolver = resolver_;\n\n        emit SetResolver(nftsResolver);\n    }\n\n    /// @notice Set Template by Name\n    /// @param templateName_ Name of the template\n    /// @param template_ Address of the template\n    function setTemplate(string memory templateName_, address template_)\n        public\n        override(IOpenNFTsFactoryV3)\n        onlyOwner\n    {\n        require(IERC165(template_).supportsInterface(type(IOpenCloneable).interfaceId), \"Not OpenCloneable\");\n        require(IOpenCloneable(template_).initialized(), \"Not initialized\");\n        require(template_.code.length != 45, \"Clone not valid template\");\n\n        uint256 num = _numTemplates[templateName_];\n        if (num >= 1) {\n            templates[num - 1] = template_;\n        } else {\n            templates.push(template_);\n            num = templates.length;\n\n            _numTemplates[templateName_] = num;\n        }\n\n        IOpenRegistry(nftsResolver).addAddress(template_);\n\n        emit SetTemplate(templateName_, template_, num);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC173, OpenCloner)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTsFactoryV3).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get Template\n    /// @param  templateName : template name\n    /// @return template_ : template address\n    function template(string memory templateName)\n        public\n        view\n        override(IOpenNFTsFactoryV3)\n        returns (address template_)\n    {\n        uint256 num = _numTemplates[templateName];\n        require(num >= 1, \"Invalid Template\");\n\n        template_ = templates[num - 1];\n        require(template_ != address(0), \"No Template\");\n    }\n}\n"
    },
    "src/OpenNFTsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n//    OpenERC165\n//        |\n//  OpenResolver\n//        |\n//  OpenNFTsResolver —— IOpenNFTsResolver\n//\npragma solidity ^0.8.9;\n\nimport {IOpenNFTsResolver} from \"src/interfaces/IOpenNFTsResolver.sol\";\nimport {IOpenAutoMarket} from \"src/interfaces/IOpenAutoMarket.sol\";\nimport {IOpenBound} from \"src/interfaces/IOpenBound.sol\";\nimport {IOpenNFTsV0} from \"src/interfaces/IOpenNFTsV0.sol\";\nimport {IOpenNFTsV1} from \"src/interfaces/IOpenNFTsV1.sol\";\nimport {IOpenNFTsV2} from \"src/interfaces/IOpenNFTsV2.sol\";\nimport {IOpenNFTsV3} from \"src/interfaces/IOpenNFTsV3.sol\";\nimport {IOpenNFTsV4} from \"src/interfaces/IOpenNFTsV4.sol\";\n\nimport {OpenERC173, OpenRegistry, OpenResolver, OpenGetter} from \"OpenNFTs/contracts/OpenResolver/OpenResolver.sol\";\nimport {IOpenMarketable} from \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport {IERC2981} from \"OpenNFTs/contracts/interfaces/IERC2981.sol\";\nimport {IOpenNFTs} from \"OpenNFTs/contracts/interfaces/IOpenNFTs.sol\";\nimport {IOpenMarketable} from \"OpenNFTs/contracts/interfaces/IOpenMarketable.sol\";\nimport {IOpenChecker} from \"OpenNFTs/contracts/interfaces/IOpenChecker.sol\";\nimport {IOpenPauseable} from \"OpenNFTs/contracts/interfaces/IOpenPauseable.sol\";\nimport {IOpenCloneable} from \"OpenNFTs/contracts/interfaces/IOpenCloneable.sol\";\n\ncontract OpenNFTsResolver is IOpenNFTsResolver, OpenResolver {\n    bytes4[] private _interfaceIds = new bytes4[](12);\n\n    uint8 private constant _IERC_2981 = 10;\n    uint8 private constant _IERC_LENGTH = 11;\n\n    uint8 private constant _IOPEN_NFTS = _IERC_LENGTH + 0;\n    uint8 private constant _IOPEN_CHECKER = _IERC_LENGTH + 1;\n    uint8 private constant _IOPEN_CLONEABLE = _IERC_LENGTH + 2;\n    uint8 private constant _IOPEN_MARKETABLE = _IERC_LENGTH + 3;\n    uint8 private constant _IOPEN_PAUSEABLE = _IERC_LENGTH + 4;\n\n    uint8 private constant _IOPEN_NFTS_V0 = _IERC_LENGTH + 5;\n    uint8 private constant _IOPEN_NFTS_V1 = _IERC_LENGTH + 6;\n    uint8 private constant _IOPEN_NFTS_V2 = _IERC_LENGTH + 7;\n    uint8 private constant _IOPEN_NFTS_V3 = _IERC_LENGTH + 8;\n    uint8 private constant _IOPEN_NFTS_V4 = _IERC_LENGTH + 9;\n    uint8 private constant _IOPEN_AUTOMARKET = _IERC_LENGTH + 10;\n    uint8 private constant _IOPEN_BOUND = _IERC_LENGTH + 11;\n\n    constructor(address owner_, address registerer_) {\n        OpenERC173._initialize(owner_);\n        OpenRegistry._setRegisterer(registerer_);\n\n        /// 0xffffffff :  O Invalid\n        /// 0x01ffc9a7 :  1 ERC165\n        /// 0x80ac58cd :  2 ERC721\n        /// 0x5b5e139f :  3 ERC721Metadata\n        /// 0x780e9d63 :  4 ERC721Enumerable\n        /// 0x150b7a02 :  5 ERC721TokenReceiver\n        /// 0xd9b67a26 :  6 ERC1155\n        /// 0x0e89341c :  7 ERC1155MetadataURI\n        /// 0x4e2312e0 :  8 ERC1155TokenReceiver\n        /// 0x7f5828d0 :  9 ERC173\n        /// 0x2a55205a : 10 ERC2981\n\n        _interfaceIds[_IOPEN_NFTS - _IERC_LENGTH] = type(IOpenNFTs).interfaceId;\n        _interfaceIds[_IOPEN_CHECKER - _IERC_LENGTH] = type(IOpenChecker).interfaceId;\n        _interfaceIds[_IOPEN_CLONEABLE - _IERC_LENGTH] = type(IOpenCloneable).interfaceId;\n        _interfaceIds[_IOPEN_MARKETABLE - _IERC_LENGTH] = type(IOpenMarketable).interfaceId;\n        _interfaceIds[_IOPEN_PAUSEABLE - _IERC_LENGTH] = type(IOpenPauseable).interfaceId;\n\n        _interfaceIds[_IOPEN_NFTS_V0 - _IERC_LENGTH] = type(IOpenNFTsV0).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V1 - _IERC_LENGTH] = type(IOpenNFTsV1).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V2 - _IERC_LENGTH] = type(IOpenNFTsV2).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V3 - _IERC_LENGTH] = type(IOpenNFTsV3).interfaceId;\n        _interfaceIds[_IOPEN_NFTS_V4 - _IERC_LENGTH] = type(IOpenNFTsV4).interfaceId;\n        _interfaceIds[_IOPEN_AUTOMARKET - _IERC_LENGTH] = type(IOpenAutoMarket).interfaceId;\n        _interfaceIds[_IOPEN_BOUND - _IERC_LENGTH] = type(IOpenBound).interfaceId;\n    }\n\n    function getOpenNFTsNftsInfos(address collection, address account, uint256 limit, uint256 offset)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        (nftInfos, count, total) = OpenGetter.getNftsInfos(collection, account, limit, offset);\n\n        openNTFsNftInfos = new OpenNFTsNftInfos[](nftInfos.length);\n        for (uint256 i = 0; i < nftInfos.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, nftInfos[i].tokenID, collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftsInfos(address collection, uint256[] memory tokenIDs, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos[] memory nftInfos,\n            OpenNFTsNftInfos[] memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, address(0), _interfaceIds);\n\n        nftInfos = OpenGetter.getNftsInfos(collection, tokenIDs, account);\n        openNTFsNftInfos = new OpenNFTsNftInfos[](tokenIDs.length);\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            openNTFsNftInfos[i] = _getOpenNFTsNftInfos(collection, tokenIDs[i], collectionInfos.supported);\n        }\n    }\n\n    function getOpenNFTsNftInfos(address collection, uint256 tokenID, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            NftInfos memory nftInfos,\n            OpenNFTsNftInfos memory openNTFsNftInfos,\n            CollectionInfos memory collectionInfos\n        )\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n\n        nftInfos = OpenGetter.getNftInfos(collection, tokenID, account);\n        openNTFsNftInfos = _getOpenNFTsNftInfos(collection, tokenID, collectionInfos.supported);\n    }\n\n    function getOpenNFTsCollectionsInfos(address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (\n            CollectionInfos[] memory collectionsInfos,\n            OpenNFTsCollectionInfos[] memory openNFTsCollectionsInfos,\n            uint256 count,\n            uint256 total\n        )\n    {\n        CollectionInfos[] memory collectionsInfosAll = getCollectionsInfos(getAddresses(), account, _interfaceIds);\n        total = collectionsInfosAll.length;\n\n        for (uint256 i = 0; i < collectionsInfosAll.length; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                count++;\n            }\n        }\n\n        collectionsInfos = new CollectionInfos[](count);\n        openNFTsCollectionsInfos = new OpenNFTsCollectionInfos[](count);\n\n        uint256 j;\n        for (uint256 i = 0; i < total; i++) {\n            if (collectionsInfosAll[i].balanceOf > 0 || collectionsInfosAll[i].owner == account) {\n                collectionsInfos[j] = collectionsInfosAll[i];\n                openNFTsCollectionsInfos[j] =\n                    _getOpenNFTsCollectionInfos(collectionsInfosAll[i].collection, collectionsInfosAll[i].supported);\n                j++;\n            }\n        }\n    }\n\n    function getOpenNFTsCollectionInfos(address collection, address account)\n        external\n        view\n        override(IOpenNFTsResolver)\n        returns (CollectionInfos memory collectionInfos, OpenNFTsCollectionInfos memory openNTFscollectionInfos)\n    {\n        collectionInfos = OpenGetter._getCollectionInfos(collection, account, _interfaceIds);\n        openNTFscollectionInfos = _getOpenNFTsCollectionInfos(collection, collectionInfos.supported);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(OpenResolver) returns (bool) {\n        return interfaceId == type(IOpenNFTsResolver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _getOpenNFTsNftInfos(address collection, uint256 tokenID, bool[] memory supported)\n        internal\n        view\n        returns (OpenNFTsNftInfos memory nftInfos)\n    {\n        if (supported[_IOPEN_MARKETABLE]) {\n            nftInfos.receiver = IOpenMarketable(payable(collection)).getTokenRoyalty(tokenID);\n            nftInfos.price = IOpenMarketable(payable(collection)).getTokenPrice(tokenID);\n        } else if (supported[_IERC_2981]) {\n            (nftInfos.receiver.account,) = IERC2981(payable(collection)).royaltyInfo(tokenID, 1);\n        }\n    }\n\n    function _getOpenNFTsCollectionInfos(address collection, bool[] memory supported)\n        internal\n        view\n        returns (OpenNFTsCollectionInfos memory collInfos)\n    {\n        if (supported[_IOPEN_CLONEABLE]) {\n            collInfos.version = IOpenCloneable(collection).version(); // 4\n            collInfos.template = IOpenCloneable(collection).template(); // OpenNFTsV4 or OpenBound\n            collInfos.open = IOpenNFTsV4(collection).open();\n        } else if (supported[_IOPEN_NFTS_V3]) {\n            collInfos.version = 3;\n            collInfos.template = \"OpenNFTsV3\";\n            collInfos.open = IOpenNFTsV3(collection).open();\n        } else if (supported[_IOPEN_NFTS_V2]) {\n            collInfos.version = 2;\n        } else if (supported[_IOPEN_NFTS_V1]) {\n            collInfos.version = 1;\n        }\n\n        if (supported[_IOPEN_MARKETABLE]) {\n            collInfos.receiver = IOpenMarketable(payable(collection)).getDefaultRoyalty();\n            collInfos.price = IOpenMarketable(payable(collection)).getMintPrice();\n            collInfos.minimal = IOpenMarketable(payable(collection)).minimal();\n        }\n    }\n}\n"
    },
    "src/OpenNFTsV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// Derived from Kredeum NFTs\n// https://github.com/Kredeum/kredeum\n//\n//       ___           ___         ___           ___                    ___           ___                     ___\n//      /  /\\         /  /\\       /  /\\         /__/\\                  /__/\\         /  /\\        ___        /  /\\\n//     /  /::\\       /  /::\\     /  /:/_        \\  \\:\\                 \\  \\:\\       /  /:/_      /  /\\      /  /:/_\n//    /  /:/\\:\\     /  /:/\\:\\   /  /:/ /\\        \\  \\:\\                 \\  \\:\\     /  /:/ /\\    /  /:/     /  /:/ /\\\n//   /  /:/  \\:\\   /  /:/~/:/  /  /:/ /:/_   _____\\__\\:\\            _____\\__\\:\\   /  /:/ /:/   /  /:/     /  /:/ /::\\\n//  /__/:/ \\__\\:\\ /__/:/ /:/  /__/:/ /:/ /\\ /__/::::::::\\          /__/::::::::\\ /__/:/ /:/   /  /::\\    /__/:/ /:/\\:\\\n//  \\  \\:\\ /  /:/ \\  \\:\\/:/   \\  \\:\\/:/ /:/ \\  \\:\\~~\\~~\\/          \\  \\:\\~~\\~~\\/ \\  \\:\\/:/   /__/:/\\:\\   \\  \\:\\/:/~/:/\n//   \\  \\:\\  /:/   \\  \\::/     \\  \\::/ /:/   \\  \\:\\  ~~~            \\  \\:\\  ~~~   \\  \\::/    \\__\\/  \\:\\   \\  \\::/ /:/\n//    \\  \\:\\/:/     \\  \\:\\      \\  \\:\\/:/     \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\  \\:\\   \\__\\/ /:/\n//     \\  \\::/       \\  \\:\\      \\  \\::/       \\  \\:\\                 \\  \\:\\        \\  \\:\\         \\__\\/     /__/:/\n//      \\__\\/         \\__\\/       \\__\\/         \\__\\/                  \\__\\/         \\__\\/                   \\__\\/\n//\n//\n//   OpenERC165\n//   (supports)\n//       |\n//       ———————————————————————————————————————————————————\n//       |                                    |            |\n//   OpenERC721                          OpenERC173  OpenCloneable\n//     (NFT)                              (ownable)        |\n//       |                                    |            |\n//       ——————————————————————————           |            |\n//       |                        |           |            |\n//  OpenERC721Metadata  OpenERC721Enumerable  |            |\n//       |                        |           |            |\n//       ———————————————————————————————————————————————————\n//       |\n//   OpenNFTsV4 —— IOpenNFTsV4\n//\npragma solidity ^0.8.9;\n\nimport {OpenERC721} from \"OpenNFTs/contracts/OpenERC/OpenERC721.sol\";\nimport {OpenERC721Metadata} from \"OpenNFTs/contracts/OpenERC/OpenERC721Metadata.sol\";\nimport {OpenERC721Enumerable} from \"OpenNFTs/contracts/OpenERC/OpenERC721Enumerable.sol\";\nimport {OpenERC173} from \"OpenNFTs/contracts/OpenERC/OpenERC173.sol\";\nimport {OpenCloneable} from \"OpenNFTs/contracts/OpenCloner/OpenCloneable.sol\";\nimport {IOpenNFTsV4} from \"src/interfaces/IOpenNFTsV4.sol\";\n\n/// @title OpenNFTs smartcontract\ncontract OpenNFTsV4 is IOpenNFTsV4, OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable {\n    /// @notice tokenID of next minted NFT\n    uint256 public tokenIdNext;\n\n    /// @notice Mint NFT allowed to everyone or only collection owner\n    bool public open;\n\n    /// @notice onlyOpenOrOwner, either everybody in open collection,\n    /// @notice either only owner in specific collection\n    modifier onlyMinter() {\n        require(open || (owner() == msg.sender), \"Not minter\");\n        _;\n    }\n\n    function mint(string memory tokenURI_) external override(IOpenNFTsV4) returns (uint256 tokenID) {\n        tokenID = _mint(msg.sender, tokenURI_);\n    }\n\n    function mint(address minter, string memory tokenURI_)\n        external\n        override(IOpenNFTsV4)\n        onlyOwner\n        returns (uint256 tokenID)\n    {\n        tokenID = _mint(minter, tokenURI_);\n    }\n\n    /// @notice burn NFT\n    /// @param tokenID tokenID of NFT to burn\n    function burn(uint256 tokenID) external override(IOpenNFTsV4) onlyTokenOwnerOrApproved(tokenID) {\n        _burn(tokenID);\n    }\n\n    function initialize(string memory name_, string memory symbol_, address owner_, bytes memory params_)\n        public\n        override(OpenCloneable)\n    {\n        (bytes memory subparams_,,) = abi.decode(params_, (bytes, address, uint96));\n\n        (,,, bool[] memory options_) = abi.decode(subparams_, (uint256, address, uint96, bool[]));\n        open = options_[0];\n\n        tokenIdNext = 1;\n\n        OpenCloneable._initialize(\"OpenNFTsV4\", 4);\n        OpenERC721Metadata._initialize(name_, symbol_);\n        OpenERC173._initialize(owner_);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(OpenERC721Metadata, OpenERC721Enumerable, OpenERC173, OpenCloneable)\n        returns (bool)\n    {\n        return interfaceId == type(IOpenNFTsV4).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _mint(address minter, string memory tokenURI) internal returns (uint256 tokenID) {\n        tokenID = tokenIdNext++;\n\n        _mint(minter, tokenURI, tokenID);\n    }\n\n    function _mint(address minter, string memory tokenURI, uint256 tokenID)\n        internal\n        override(OpenERC721Enumerable, OpenERC721Metadata)\n    {\n        super._mint(minter, tokenURI, tokenID);\n    }\n\n    function _burn(uint256 tokenID) internal override(OpenERC721Enumerable, OpenERC721Metadata) {\n        super._burn(tokenID);\n    }\n\n    function _transferFromBefore(address from, address to, uint256 tokenID)\n        internal\n        override(OpenERC721, OpenERC721Enumerable)\n    {\n        super._transferFromBefore(from, to, tokenID);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}